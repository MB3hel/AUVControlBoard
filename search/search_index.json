{"config":{"indexing":"full","lang":["en"],"min_search_length":3,"prebuild_index":false,"separator":"[\\s\\-]+"},"docs":[{"location":"","text":"AUV Control Board Documentation AUV Control Board is a low-cost open-source motion controller for (Autonomous) Underwater Vehicles. It is designed for vehicles with fixed position thrusters and supports motion in 6 degrees of freedom. There are currently two versions of control board. Neither version has more features than the other. Version 2 was developed to be able to use a different chip / board that was easier to get. Version 1 uses an Adafruit ItsyBitsy M4 (Microchip ATSAMD51 chip) Version 2 use a WeAct Studio Black Pill (STMicroelectronics STM32F4) The firmware is capable of running on both versions. License Both the firmware and provided demo and interface scripts are licensed under the GNU General Public License version 3 or later (GPL-3.0-or-later). Note that the firmware includes third party components licensed under their own terms.","title":"Home"},{"location":"#auv-control-board-documentation","text":"AUV Control Board is a low-cost open-source motion controller for (Autonomous) Underwater Vehicles. It is designed for vehicles with fixed position thrusters and supports motion in 6 degrees of freedom. There are currently two versions of control board. Neither version has more features than the other. Version 2 was developed to be able to use a different chip / board that was easier to get. Version 1 uses an Adafruit ItsyBitsy M4 (Microchip ATSAMD51 chip) Version 2 use a WeAct Studio Black Pill (STMicroelectronics STM32F4) The firmware is capable of running on both versions.","title":"AUV Control Board Documentation"},{"location":"#license","text":"Both the firmware and provided demo and interface scripts are licensed under the GNU General Public License version 3 or later (GPL-3.0-or-later). Note that the firmware includes third party components licensed under their own terms.","title":"License"},{"location":"none/","text":"Coming Soon.","title":"None"},{"location":"firmware/build/","text":"Build and Flash Note: Run all commands shown in the firmware folder of the repo. Building Install the Required Tools: CMake (version 3.20.0 or newer) Ninja GNU Arm Toolchain Make sure cmake , ninja , and arm-none-eabi-gcc are in your PATH . Build the firmware using the commands below. Replace [preset] with v1 or v2 . Replace [config] with debug , release , minsizerel , or relwithdebinfo . cmake --preset=[preset] cmake --build --preset=[preset]-[config] Flashing Version Flash Method Tool Alias Required software v1 sam-ba (via bootloader) bossa BOSSA (specifically bossac / bossa-cli) v1 uf2conv (via bootloader) uf2conv None v2 dfu-util (via bootloader) dfu-util dfu-util v2 STM32CubeProgrammer DFU (via bootloader) stm32-dfu STM32CubeProgrammer v2 STM32CubeProgrammer ST-LINK v2 stm32-stlink2 STM32CubeProgrammer Note: required tool ( bossac , dfu-util , STM32_Programmer_CLI ) must be in your PATH . Before flashing, the chip needs to enter its bootloader (unless using a debug probe such as the stlink2 to flash) If a board is already flashed, it can be rebooted into its bootloader using the reboot_bootloader.py script in the firmware directory. Otherwise, use the hardware method described below. v1: Press the reset button twice quickly (double press). v2: Hold the BOOT button. While holding it, press and release the NRST button. Then release the boot button. Note: Sometimes reboot to bootloader mode \"fails\". On v1, this usually means it fails to attach USB (LED remains red not green.) On v2 this usually means it doesn't show up as a USB device. In either case, just try to enter again using the same button combination above. To flash, run the flash.py script. It is a wrapper that will call one of the above tools python3 flash.py [version] [config] -u [tool] [version] is either v1 or v2 [config] is the configuration you want to flash (same as configuration built: Debug , Release , MinSizeRel , or RelWithDebInfo ) [tool] is one of the above upload tool aliases. Flashing Remotely Sometimes, it is useful to flash firmware without connecting directly to the control board. Typically, this is done in-system where the embedded computer using the control board (Jetson, Raspberry Pi, etc) is used to flash the control board without gaining physical access to the control board. Instead an ssh connection to the remote computer is used. There are a few requirements to be able to flash remotely The control board must already be running some version of the firmware. This is necessary to be able to enter bootloader mode without access to the buttons on the board. The remote computer must have a flash tool installed. For v1 this should be bossac and for v2 this should be dfu-util . These are available as packages for most Linux distributions ( bossa-cli and dfu-util respectively for Debian and Ubuntu based systems). You must have ssh (and by extension scp) access to the remote system (typically via ethernet tether) On the build computer (laptop, etc) build the firmware as described above. Then, login to the remote system via ssh and create a directory to hold control board flash stuff (name can be changed as desired) # Run on remote computer (via ssh) cd ~ mkdir cboard-flash Then on the build computer, use scp to copy the flash.py and reboot_bootloader.py scripts to this folder # Run on build laptop scp firmware/flash.py user@remote_ip:cboard-flash/ scp firmware/reboot_bootloader.py user@remote_ip:cboard-flash/ Next copy the build folder. You can just copy the binaries themselves, but the folder hierarchy must be maintained. # Run on remote computer (via ssh) # Delete old build folder first rm -r ~/cboard-flash/build # Run on build laptop scp -r firmware/build user@remote_ip:cboard-flash/ Finally, reboot the control board to bootloader and flash # Run on remote computer (via ssh) ./reboot_bootloader.py [port] ./flash.py [version] [config] -p [port] Note: Sometimes reboot to bootloader mode \"fails\". On v1, this usually means it fails to attach USB (LED remains red not green.) On v2 this usually means it doesn't show up as a USB device. In either case, you will loose USB communication to the board. In this case, a power cycle is required to \"fix\" the board before trying to enter the bootloader again. While inconvenient, it is still usually easier to power cycle the vehicle than to unseal it.","title":"Build and Flash"},{"location":"firmware/build/#build-and-flash","text":"Note: Run all commands shown in the firmware folder of the repo.","title":"Build and Flash"},{"location":"firmware/build/#building","text":"Install the Required Tools: CMake (version 3.20.0 or newer) Ninja GNU Arm Toolchain Make sure cmake , ninja , and arm-none-eabi-gcc are in your PATH . Build the firmware using the commands below. Replace [preset] with v1 or v2 . Replace [config] with debug , release , minsizerel , or relwithdebinfo . cmake --preset=[preset] cmake --build --preset=[preset]-[config]","title":"Building"},{"location":"firmware/build/#flashing","text":"Version Flash Method Tool Alias Required software v1 sam-ba (via bootloader) bossa BOSSA (specifically bossac / bossa-cli) v1 uf2conv (via bootloader) uf2conv None v2 dfu-util (via bootloader) dfu-util dfu-util v2 STM32CubeProgrammer DFU (via bootloader) stm32-dfu STM32CubeProgrammer v2 STM32CubeProgrammer ST-LINK v2 stm32-stlink2 STM32CubeProgrammer Note: required tool ( bossac , dfu-util , STM32_Programmer_CLI ) must be in your PATH . Before flashing, the chip needs to enter its bootloader (unless using a debug probe such as the stlink2 to flash) If a board is already flashed, it can be rebooted into its bootloader using the reboot_bootloader.py script in the firmware directory. Otherwise, use the hardware method described below. v1: Press the reset button twice quickly (double press). v2: Hold the BOOT button. While holding it, press and release the NRST button. Then release the boot button. Note: Sometimes reboot to bootloader mode \"fails\". On v1, this usually means it fails to attach USB (LED remains red not green.) On v2 this usually means it doesn't show up as a USB device. In either case, just try to enter again using the same button combination above. To flash, run the flash.py script. It is a wrapper that will call one of the above tools python3 flash.py [version] [config] -u [tool] [version] is either v1 or v2 [config] is the configuration you want to flash (same as configuration built: Debug , Release , MinSizeRel , or RelWithDebInfo ) [tool] is one of the above upload tool aliases.","title":"Flashing"},{"location":"firmware/build/#flashing-remotely","text":"Sometimes, it is useful to flash firmware without connecting directly to the control board. Typically, this is done in-system where the embedded computer using the control board (Jetson, Raspberry Pi, etc) is used to flash the control board without gaining physical access to the control board. Instead an ssh connection to the remote computer is used. There are a few requirements to be able to flash remotely The control board must already be running some version of the firmware. This is necessary to be able to enter bootloader mode without access to the buttons on the board. The remote computer must have a flash tool installed. For v1 this should be bossac and for v2 this should be dfu-util . These are available as packages for most Linux distributions ( bossa-cli and dfu-util respectively for Debian and Ubuntu based systems). You must have ssh (and by extension scp) access to the remote system (typically via ethernet tether) On the build computer (laptop, etc) build the firmware as described above. Then, login to the remote system via ssh and create a directory to hold control board flash stuff (name can be changed as desired) # Run on remote computer (via ssh) cd ~ mkdir cboard-flash Then on the build computer, use scp to copy the flash.py and reboot_bootloader.py scripts to this folder # Run on build laptop scp firmware/flash.py user@remote_ip:cboard-flash/ scp firmware/reboot_bootloader.py user@remote_ip:cboard-flash/ Next copy the build folder. You can just copy the binaries themselves, but the folder hierarchy must be maintained. # Run on remote computer (via ssh) # Delete old build folder first rm -r ~/cboard-flash/build # Run on build laptop scp -r firmware/build user@remote_ip:cboard-flash/ Finally, reboot the control board to bootloader and flash # Run on remote computer (via ssh) ./reboot_bootloader.py [port] ./flash.py [version] [config] -p [port] Note: Sometimes reboot to bootloader mode \"fails\". On v1, this usually means it fails to attach USB (LED remains red not green.) On v2 this usually means it doesn't show up as a USB device. In either case, you will loose USB communication to the board. In this case, a power cycle is required to \"fix\" the board before trying to enter the bootloader again. While inconvenient, it is still usually easier to power cycle the vehicle than to unseal it.","title":"Flashing Remotely"},{"location":"firmware/developing/","text":"Firmware Development Build and Flash Building and flashing the firmware should follow the same process described here . Debugging OpenOCD config files exist in tools/debug . The following configurations exist ControlBoard Version Debugger / Debug Probe Config Name v1 CMSIS-DAP* cb_v1_via_cmsisdap.cfg v2 ST-LINK v2 cb_v2_via_stlink2.cfg *There is a firmware for a Raspberry Pi Pico to turn it into a CMSIS-DAP debugger. This is a variant of the Picoprobe firmware. Note that OpenOCD must be installed and in the PATH . Generator Projects Each version of ControlBoard has an associated \"Generator\" project. These are projects used with the chip manufacturer's tools to generate startup / configuration / library code for the chip. Note: If you are just building the firmware you do not need to understand the generator projects. The necessary portions of each project are copied to the thirdparty folder. These are used for building. The generator projects are only used if something that was generated needs to be changed (or something new needs to be generated). Why Generators The decision to use generator projects comes down to the following There are multiple versions of Control Board with multiple chips. Using generators to create chip-specific initialization code reduces the chip-specific versions of the firmware that must be written / maintained. The generators are often required to use the manufacturer's HAL (or make using the HAL much easier). Use of the manufacturer's HAL / libraries reduces development time and makes maintenance easier (especially for those less familiar with the codebase). Having a GUI tool (which these generators usually are) to configure the system is an easy way to quickly understand the architecture of the system (clocks, peripheral use, pinout, etc). Running the Generator(s) Control Board v1 Control Board v1 uses an Adafruit ItsyBitsy M4 board (Microchip ATSAMD51G19A chip). The generator used for this project is MCC Standalone . This tool is available for download on Windows, macOS, and Linux. Tested with v5.2.1 of MCC Standalone. Once installed Launch the application Make sure the Harmony Content Path is set in Tools > Options . This should only need to be done once per computer. Recommended path is ~/.mcc/harmony/v3 . File > Load Configuration Choose generator_projects/ControlBoard_v1/firmware/ControlBoard_v1/ControlBoard_v1.mc3 You will likely be prompted to install MPLAB Harmony content. Install it. Click \"Generate\" in the top left. Control Board v2 Control Board v2 uses a WeAct Studio Black Pill board (STMicro STM32F411CEU chip). The generator used for this project is STM32CubeMX . This tool is available for download on Windows, macOS, and Linux. Tested with v6.6.1 of STM32CubeMX. Once installed Launch the application File > Load Project Choose generator_projects/ControlBoard_v2/ControlBoard_v2.ioc Install any required packs (as prompted) Click \"Generate Code\" in the top right. Importing from Generators After running the generator (as described above) the generated code must be imported to the project. The import process is mostly just copying generated files, however some files are modified slightly. The import process is handled by the import_from_generator.py script. If additional components are added in the generator projects, this script may need to be modified to import additional components. When this script is run, it will prompt a version of control board to import generated code for. This script must be run after each time the generator project is modified and code is re-generated. Development using VSCode Install the C/C++ and CMake Tools extensions, then open this folder in VSCode. Choose one of the configure presets on the bottom bar. Then, choose a build preset. Finally, click build. To debug, install the Cortex-Debug extension in VSCode. Copy tools/debug/launch.json to .vscode . MAKE SURE TO BUILD DEBUG CONFIG BEFORE LAUNCHING DEBUG SESSION. IT WILL NOT BUILD AUTOMATICALLY.","title":"Firmware Development"},{"location":"firmware/developing/#firmware-development","text":"","title":"Firmware Development"},{"location":"firmware/developing/#build-and-flash","text":"Building and flashing the firmware should follow the same process described here .","title":"Build and Flash"},{"location":"firmware/developing/#debugging","text":"OpenOCD config files exist in tools/debug . The following configurations exist ControlBoard Version Debugger / Debug Probe Config Name v1 CMSIS-DAP* cb_v1_via_cmsisdap.cfg v2 ST-LINK v2 cb_v2_via_stlink2.cfg *There is a firmware for a Raspberry Pi Pico to turn it into a CMSIS-DAP debugger. This is a variant of the Picoprobe firmware. Note that OpenOCD must be installed and in the PATH .","title":"Debugging"},{"location":"firmware/developing/#generator-projects","text":"Each version of ControlBoard has an associated \"Generator\" project. These are projects used with the chip manufacturer's tools to generate startup / configuration / library code for the chip. Note: If you are just building the firmware you do not need to understand the generator projects. The necessary portions of each project are copied to the thirdparty folder. These are used for building. The generator projects are only used if something that was generated needs to be changed (or something new needs to be generated).","title":"Generator Projects"},{"location":"firmware/developing/#why-generators","text":"The decision to use generator projects comes down to the following There are multiple versions of Control Board with multiple chips. Using generators to create chip-specific initialization code reduces the chip-specific versions of the firmware that must be written / maintained. The generators are often required to use the manufacturer's HAL (or make using the HAL much easier). Use of the manufacturer's HAL / libraries reduces development time and makes maintenance easier (especially for those less familiar with the codebase). Having a GUI tool (which these generators usually are) to configure the system is an easy way to quickly understand the architecture of the system (clocks, peripheral use, pinout, etc).","title":"Why Generators"},{"location":"firmware/developing/#running-the-generators","text":"","title":"Running the Generator(s)"},{"location":"firmware/developing/#control-board-v1","text":"Control Board v1 uses an Adafruit ItsyBitsy M4 board (Microchip ATSAMD51G19A chip). The generator used for this project is MCC Standalone . This tool is available for download on Windows, macOS, and Linux. Tested with v5.2.1 of MCC Standalone. Once installed Launch the application Make sure the Harmony Content Path is set in Tools > Options . This should only need to be done once per computer. Recommended path is ~/.mcc/harmony/v3 . File > Load Configuration Choose generator_projects/ControlBoard_v1/firmware/ControlBoard_v1/ControlBoard_v1.mc3 You will likely be prompted to install MPLAB Harmony content. Install it. Click \"Generate\" in the top left.","title":"Control Board v1"},{"location":"firmware/developing/#control-board-v2","text":"Control Board v2 uses a WeAct Studio Black Pill board (STMicro STM32F411CEU chip). The generator used for this project is STM32CubeMX . This tool is available for download on Windows, macOS, and Linux. Tested with v6.6.1 of STM32CubeMX. Once installed Launch the application File > Load Project Choose generator_projects/ControlBoard_v2/ControlBoard_v2.ioc Install any required packs (as prompted) Click \"Generate Code\" in the top right.","title":"Control Board v2"},{"location":"firmware/developing/#importing-from-generators","text":"After running the generator (as described above) the generated code must be imported to the project. The import process is mostly just copying generated files, however some files are modified slightly. The import process is handled by the import_from_generator.py script. If additional components are added in the generator projects, this script may need to be modified to import additional components. When this script is run, it will prompt a version of control board to import generated code for. This script must be run after each time the generator project is modified and code is re-generated.","title":"Importing from Generators"},{"location":"firmware/developing/#development-using-vscode","text":"Install the C/C++ and CMake Tools extensions, then open this folder in VSCode. Choose one of the configure presets on the bottom bar. Then, choose a build preset. Finally, click build. To debug, install the Cortex-Debug extension in VSCode. Copy tools/debug/launch.json to .vscode . MAKE SURE TO BUILD DEBUG CONFIG BEFORE LAUNCHING DEBUG SESSION. IT WILL NOT BUILD AUTOMATICALLY.","title":"Development using VSCode"},{"location":"firmware/math/","text":"Control Math Coordinate System Definition The coordinate system is defined by the images below Pitch is defined as rotation about the x-axis Roll is defined as rotation about the y-axis Yaw is defined as rotation about the z-axis Positive pitch, roll, and yaw are defined by the right hand rule Point your right thumb in the positive direction of the axis being rotated about. The fingers of the hand curve in the direction of positive rotation. Reference Positive pitch is defined as counter-clockwise rotation in the yz plane when viewed from the +x side Positive roll is defined as counter-clockwise rotation in the xz plan when viewed from the +y side Positive yaw is defined as counter-clockwise rotation in the xy plane when viewed from the +z side Robot Local Coordinate System The robot's local coordinate system is defined as shown below where +y is forward, +x is right, and +z is up. Pitch and roll definitions remain the same as previously defined +pitch raises front of the robot +roll raises left of the robot +yaw moves the front to the left Robot Thruster Arrangement The arrows on the diagrams below are the direction the thrusters push water when given a positive speed (meaning the force excreted on the robot is in the opposite direction). Note: Thruster numbers can be easily switched later if thrusters are connected to different pwm outputs. Note: Thruster directions can be inverted by the control board firmware if needed (without changing the math). 6DOF Motor Control Math The following section covers math to calculate individual motor speeds to achieve the desired motion with a 6 degree of freedom system (6DoF = 3 translation and 3 rotation). The math remains valid for motor configurations where motion in some DoFs is not possible. See: numpy_motor_math.py linked at the top of this page. Motor Matrix The motor matrix is generated based on physical frame and thruster configuration. The motor matrix associates motor numbers with their contributions to motion in different degrees of freedom. The motor matrix can be thought of as a \"table\" where each column represents one degree of freedom and each row represents a motor. Each column is a set of motor speeds that cause motion only in the column's degree of freedom (and in the positive direction and at maximum possible speed). There are always 7 columns in the matrix. The number of rows is equal to the number of motors. Note that the motor numbers can be in any order (ie row order does not matter) whereas columns must be ordered as shown in the image below. To construct the motor matrix for a given thruster configuration, work one column at a time (after assigning motor numbers to rows). For each column determine the speeds for each motor to cause motion only in the positive direction of the column's DoF at the maximum possible speed. The motor speeds in each column must not cause motion in any other DoF (in an ideal scenario; in the real world things are never perfect). Note that all motor speeds are specified as a number between negative one and positive one. The motor matrix for the thruster configuration shown above is as follows DoF Matrix The motor matrix is not directly used in calculations. Only a subset of it is. The DoF Matrix is a submatrix of the motor matrix excluding the first column (motor numbers). This matrix is used for all calculations. The motor number column is extracted and stored as a column vector and used to associate speed calculation results with the correct motor numbers after other calculations. Local Targets Next it is necessary to define a motion target, or a goal for the robot's motion in each DoF. For now, assume this target is relative to the robot, not the world (meaning the robot's orientation in space is irrelevant). A motion target is a column vector where each row corresponds to a DoF (order matches order of DoFs in motor matrix columns). The value in each cell is a number from negative one to positive one and represents the target speed in each degree of freedom. The target can have motion in as many DoFs as desired. This target motion vector can then be used to calculate individual motor speeds by multiplying it by the DoF matrix. The result of this multiplication is a column vector with as many entries as there are motors. Each entry is a motor speed. The motor speeds are in the same order as the motor number column vector (first column of motor matrix). This vector is the speed vector. Motion in multiple DoFs can be used to create any net motion the robot is capable of. For example, positive y translation and positive yaw of equal magnitudes (speeds) will result in the robot moving in a circle in the xy plane about the left edge of the robot (positive directions). The calculation for this scenario is shown below (at 100% speed). Notice that the resultant motor speed vector has motor speeds that exceed 100% speed. This is because it is not possible to move at 100% speed in both of the specified DoFs at the same time. As such, motor speeds will need to be scaled down. This is discussed in the next section. Scaling Motor Outputs The above example illustrates the need to scale down motor speeds. However, doing so is less trivial than it may initially appear. The most intuitive option would be to divide all motor speeds by the largest magnitude ( m = max(abs(speed_vector)) ) if m is larger than 1.0 (no need to divide if no value is larger than 1 because the motion is already possible). This solution works in the above example resulting in the following scaled speed vector While this is the correct result for the above example, consider the following more complex example (where motion in more DoFs is added). If the previously described algorithm is applied m = 3 which results in the following scaled speed vector However, this speed vector is scaled non-optimally. Notice that the maximum speed occurred at motor 5. However, motors 1, 2, 3, and 4 do not affect any of the same directions as motor 5. As such, it is not necessary to divide motor 1, 2, 3, 4 speeds by 3. Instead they should only be divided by 2 otherwise some DoF motions are slowed more than required (artificially reducing max speed). In reality, it is only necessary to divide the speeds of some motors depending on where the max speed is located. If the max speed occurs at motor i , it is only necessary to divide the speed of any motors that \"overlap\" with motor i . Overlap is defined as sharing a contribution in any DoF. In terms of the DoF matrix, two motors i and j overlap if the row for motor i and the row for motor j have a non-zero entry in the same column for at least one column. Mathematically, this is easier to calculate if a contribution matrix is defined as \"the dof matrix is not equal to zero\". The contribution matrix is a \"binary version\" of the dof matrix, where any non-zero entry in the dof matrix becomes a 1 in the contribution matrix (and any zero remains a zero). Then, in terms of the contribution matrix, two motors i and j overlap if the row for motor i and motor j have a one entry in the same column for at least one column. Mathematically, the number of shared non-zero entries is the dot product of the two rows. To simplify later calculations an overlap vector will be generated for each motor in the dof matrix. The overlap vector is a vector of 1's and 0's indicating whether overlap occurs with the corresponding index motor in the speed vector. For motor i the overlap vector ( overlap_vec[i] ) is defined as \"the product of the contribution matrix and the transpose of row i of the contribution matrix is not equal to zero\". For example overlap_vec[0] is defined as follows One overlap vector must be calculated for each motor. These are calculated ahead of time to reduce the number of operations that must be performed to calculate motor speeds (important when this is implemented on a microcontroller). Finally, the following algorithm (described in pseudocode) is used to properly scale each motor. The scaling is done when no speed in the vector has a magnitude greater than 1. while true // index is index in speed_vector at which m occurs m, index = max(abs(speed_vector)) if m <= 1 // No speeds exceed max magnitude, so done scaling break endif // Scale speed_vector as needed for i = 0; i < length(overlap_vector[index]); ++i if overlap_vector[index][i] == 1 speed_vector[i] /= m; endif endfor endwhile Using this algorithm the earlier example results in the following scaled speed vector (which is optimal for the requested motions). Motor 1, 2, 3, 4 speeds divided by 2 and motor 5, 6, 7, 8 speeds divided by 3. This results in the fastest motor within each group being at 100% speed, thus this is optimal scaling. Global Targets Instead of providing desired motion relative to the robot's orientation, it is often easier to specify motion relative to the world (at least partially). This requires knowing information about the robot's orientation in 3D space. However, for this application the robot's heading will be ignored (meaning x and y are relative to the robot's orientation, but z is world-relative). This effectively turns the target vector previously provided into a pseudo world-relative motion target (DoFs are world coordinate system not robot coordinate system). However, y still means forward relative to robot heading not relative to the world coordinate system (same idea for x too). This method is used instead of a true global target for two reasons The method described above does not require knowing the robot's heading in 3D space. As such, the required information can be obtained without use of a magnetometer. This is beneficial as magnetometers become unreliable in close proximity to motors. Note that the gyro alone is sufficient for heading information, but without a magnetometer it will drift significantly over time, making this less effective. Mission level code's knowledge of the robot's position relative to objects of interest often has no knowledge of a world coordinate system. As such, keeping x and y translations robot-relative simplifies mission code and reduces errors for closed loop control in mission code. The target vector can be split into two parts: a translation vector and a rotation vector. Both vectors are in an [x, y, z] order. Translations are along the given axes. Rotations are about the given axes The idea is to determine a rotation matrix to translate the world gravity vector to the robot's measured gravity vector. This is the same rotation that should then be applied to each of the vectors described above (translation and rotation). In practice, an AHRS algorithm can provide robot orientation in 3D space (with absolute pitch and roll due to the accelerometer). This algorithm provides a quaternion representing the robot's orientation in 3d space. Note that this quaternion cannot be directly converted into a rotation matrix, as that does not ignore the yaw component (as is desired for global mode). Thus, instead, the quaternion is used to construct a vector in the direction of gravity ( g_r ) as shown below g_r.x = 2.0 * (-q.x*q.z + q.w*q.y) g_r.y = 2.0 * (-q.w*q.x - q.y*q.z) g_r.z = -q.w*q.w + q.x*q.x + q.y*q.y - q.z*q.z It is assumed that when the robot's coordinate frame matches the world's coordinate frame, the measured gravity vector will be [0, 0, -g] (meaning in the negative z direction). This must be configured to be the case (IMU supports axis remapping internally to allow this regardless of how the IMU is mounted). Then, given a world gravity vector ( g_w ) and a measured gravity vector g_r a rotation matrix ( R ) to rotate vectors from the world coordinate system into the robot's coordinate system can be calculated as shown below Where [v_c]_x is the skew symmetric cross product matrix of v_c defined as follows Then each of the translation and rotation targets can be rotated by multiplication by the rotation matrix R. The translation and rotation vectors are then concatenated to create the full local target vector. Stability Assist Mode Math Stability assist mode is used to abstract a \"2D\" working plane to control the vehicle in. This is done by using closed-loop control to maintain pitch, roll, and depth in 3D space (leaving the x, y, and yaw DoFs). Optionally, closed-loop control can also be used for yaw leaving just the x and y DoFs. This is built on top of global mode. Thus, stability assist mode calculates the current desired speed in each degree of freedom managed by closed loop controllers (pitch, roll, depth, and sometimes yaw). The speeds in other DoFs are specified by the PC just as they would be in global mode. Orientation Closed-Loop Control TODO: Document current and past issues including gimbal lock problem. Document current (partial) solution. Depth Closed-Loop Control Depth closed-loop control is implemented using a PID. This PID's output is used as the target speed in the z DoF. The error is the difference between the current depth sensor reading and the specified target depth (in meters; negative for below the surface). IMU Angle Accumulation The euler and quaternion values provided by the IMU are not directly useful for tracking multiple rotations of the vehicle. Unlike simply integrating gyroscope data, euler angles (pitch, roll, yaw) and quaternions do not track the number of times the vehicle has rotated about a particular axis. While integrating raw gyro data would provide this, such a solution would be rotations about the robot's axes, not the world's axes (gyro z of 500 does not necessarily mean the robot has yawed 500 degrees; the robot could have been oriented at a pitch of 90). Additionally, the drift for accumulated pitch and roll would be significantly worse due to the loss of accelerometer data. To address this, it is necessary to track changes between subsequent quaternions from the IMU. Quaternions are used for three reasons Firmware bugs in some BNO055 firmware versions lead to unstable euler angles It is mathematically easier to determine the shortest rotation between two quaternions Quaternions still allow accumulation to work in gimbal lock situations The idea is to compare each quaternion read from the IMU with the previous quaternion received from the IMU (note that quaternions of all zeros are ignored to avoid issues with invalid IMU data after exiting config mode). For each read quaternion: Calculate the shortest set of rotations from the previous to the current quaternion Convert the shortest angle to euler angles Add the pitch, roll, and yaw from the shortest euler angles to accumulated pitch, roll, and yaw variables Note that if the IMU axis config changes, the accumulated data should be zeroed and the previously read quaternion discarded. This method makes the assumption that the smallest rotation between two quaternions is the most probable path the robot took to change its orientation. This is an approximation, however it is a fairly good one as long as sample rate of data is sufficiently high. The specifics of the path are lost. However, if the sample rate is high enough, the length of the path is sufficiently small that this is a good approximation. The second \"issue\" with this approximation has to do with rotations exceeding 180 degrees. The method for determining shortest path between two quaternions will be incorrect if the vehicle rotates more than 180 degrees in any axis (because the shortest path would have involved rotating the other direction). To guarantee rotations between two samples never exceed 180 degrees, the max measured rotation rate of the gyro is considered. For the BNO055 this is 2000 degrees per second. Thus, with a sample period of l milliseconds, the largest angle change between samples is \\frac{2000 \\textrm{ deg}}{1 \\textrm{ sec}} \\cdot \\frac{1 \\textrm{ sec}}{1000 \\textrm{ ms}} \\cdot \\frac{l \\textrm{ ms}}{1 \\textrm{ sample}} = 2l \\textrm{ deg / sample} To ensure that changes of more than 180 degrees do not occur, the following must be satisfied 2l < 180 \\rightarrow l < 90 \\textrm{ milliseconds} However, it is possible for some samples from the IMU to be delayed (ie I2C bus busy with another sensor) or lost (I2C failure). Thus, it is necessary to choose a value for l that allows for at least one sample to be lost. When a sample is lost, this doubles the effective time between samples. Thus, it is necessary to half l l < 45 \\textrm{ milliseconds} By further reducing l it is possible to allow for larger delays or more lost samples. The current firmware samples IMU data every 15ms (the max rate supported by the BNO055 in fusion mode is 100Hz = 10ms period). Using l=15 \\textrm{ ms} it is possible for 5 consecutive samples to be lost while still guaranteeing that no more than 90ms passes between valid samples (thus still ensuring no more than 180 degree change between samples).","title":"Math"},{"location":"firmware/math/#control-math","text":"","title":"Control Math"},{"location":"firmware/math/#coordinate-system-definition","text":"The coordinate system is defined by the images below Pitch is defined as rotation about the x-axis Roll is defined as rotation about the y-axis Yaw is defined as rotation about the z-axis Positive pitch, roll, and yaw are defined by the right hand rule Point your right thumb in the positive direction of the axis being rotated about. The fingers of the hand curve in the direction of positive rotation. Reference Positive pitch is defined as counter-clockwise rotation in the yz plane when viewed from the +x side Positive roll is defined as counter-clockwise rotation in the xz plan when viewed from the +y side Positive yaw is defined as counter-clockwise rotation in the xy plane when viewed from the +z side","title":"Coordinate System Definition"},{"location":"firmware/math/#robot-local-coordinate-system","text":"The robot's local coordinate system is defined as shown below where +y is forward, +x is right, and +z is up. Pitch and roll definitions remain the same as previously defined +pitch raises front of the robot +roll raises left of the robot +yaw moves the front to the left","title":"Robot Local Coordinate System"},{"location":"firmware/math/#robot-thruster-arrangement","text":"The arrows on the diagrams below are the direction the thrusters push water when given a positive speed (meaning the force excreted on the robot is in the opposite direction). Note: Thruster numbers can be easily switched later if thrusters are connected to different pwm outputs. Note: Thruster directions can be inverted by the control board firmware if needed (without changing the math).","title":"Robot Thruster Arrangement"},{"location":"firmware/math/#6dof-motor-control-math","text":"The following section covers math to calculate individual motor speeds to achieve the desired motion with a 6 degree of freedom system (6DoF = 3 translation and 3 rotation). The math remains valid for motor configurations where motion in some DoFs is not possible. See: numpy_motor_math.py linked at the top of this page.","title":"6DOF Motor Control Math"},{"location":"firmware/math/#motor-matrix","text":"The motor matrix is generated based on physical frame and thruster configuration. The motor matrix associates motor numbers with their contributions to motion in different degrees of freedom. The motor matrix can be thought of as a \"table\" where each column represents one degree of freedom and each row represents a motor. Each column is a set of motor speeds that cause motion only in the column's degree of freedom (and in the positive direction and at maximum possible speed). There are always 7 columns in the matrix. The number of rows is equal to the number of motors. Note that the motor numbers can be in any order (ie row order does not matter) whereas columns must be ordered as shown in the image below. To construct the motor matrix for a given thruster configuration, work one column at a time (after assigning motor numbers to rows). For each column determine the speeds for each motor to cause motion only in the positive direction of the column's DoF at the maximum possible speed. The motor speeds in each column must not cause motion in any other DoF (in an ideal scenario; in the real world things are never perfect). Note that all motor speeds are specified as a number between negative one and positive one. The motor matrix for the thruster configuration shown above is as follows","title":"Motor Matrix"},{"location":"firmware/math/#dof-matrix","text":"The motor matrix is not directly used in calculations. Only a subset of it is. The DoF Matrix is a submatrix of the motor matrix excluding the first column (motor numbers). This matrix is used for all calculations. The motor number column is extracted and stored as a column vector and used to associate speed calculation results with the correct motor numbers after other calculations.","title":"DoF Matrix"},{"location":"firmware/math/#local-targets","text":"Next it is necessary to define a motion target, or a goal for the robot's motion in each DoF. For now, assume this target is relative to the robot, not the world (meaning the robot's orientation in space is irrelevant). A motion target is a column vector where each row corresponds to a DoF (order matches order of DoFs in motor matrix columns). The value in each cell is a number from negative one to positive one and represents the target speed in each degree of freedom. The target can have motion in as many DoFs as desired. This target motion vector can then be used to calculate individual motor speeds by multiplying it by the DoF matrix. The result of this multiplication is a column vector with as many entries as there are motors. Each entry is a motor speed. The motor speeds are in the same order as the motor number column vector (first column of motor matrix). This vector is the speed vector. Motion in multiple DoFs can be used to create any net motion the robot is capable of. For example, positive y translation and positive yaw of equal magnitudes (speeds) will result in the robot moving in a circle in the xy plane about the left edge of the robot (positive directions). The calculation for this scenario is shown below (at 100% speed). Notice that the resultant motor speed vector has motor speeds that exceed 100% speed. This is because it is not possible to move at 100% speed in both of the specified DoFs at the same time. As such, motor speeds will need to be scaled down. This is discussed in the next section.","title":"Local Targets"},{"location":"firmware/math/#scaling-motor-outputs","text":"The above example illustrates the need to scale down motor speeds. However, doing so is less trivial than it may initially appear. The most intuitive option would be to divide all motor speeds by the largest magnitude ( m = max(abs(speed_vector)) ) if m is larger than 1.0 (no need to divide if no value is larger than 1 because the motion is already possible). This solution works in the above example resulting in the following scaled speed vector While this is the correct result for the above example, consider the following more complex example (where motion in more DoFs is added). If the previously described algorithm is applied m = 3 which results in the following scaled speed vector However, this speed vector is scaled non-optimally. Notice that the maximum speed occurred at motor 5. However, motors 1, 2, 3, and 4 do not affect any of the same directions as motor 5. As such, it is not necessary to divide motor 1, 2, 3, 4 speeds by 3. Instead they should only be divided by 2 otherwise some DoF motions are slowed more than required (artificially reducing max speed). In reality, it is only necessary to divide the speeds of some motors depending on where the max speed is located. If the max speed occurs at motor i , it is only necessary to divide the speed of any motors that \"overlap\" with motor i . Overlap is defined as sharing a contribution in any DoF. In terms of the DoF matrix, two motors i and j overlap if the row for motor i and the row for motor j have a non-zero entry in the same column for at least one column. Mathematically, this is easier to calculate if a contribution matrix is defined as \"the dof matrix is not equal to zero\". The contribution matrix is a \"binary version\" of the dof matrix, where any non-zero entry in the dof matrix becomes a 1 in the contribution matrix (and any zero remains a zero). Then, in terms of the contribution matrix, two motors i and j overlap if the row for motor i and motor j have a one entry in the same column for at least one column. Mathematically, the number of shared non-zero entries is the dot product of the two rows. To simplify later calculations an overlap vector will be generated for each motor in the dof matrix. The overlap vector is a vector of 1's and 0's indicating whether overlap occurs with the corresponding index motor in the speed vector. For motor i the overlap vector ( overlap_vec[i] ) is defined as \"the product of the contribution matrix and the transpose of row i of the contribution matrix is not equal to zero\". For example overlap_vec[0] is defined as follows One overlap vector must be calculated for each motor. These are calculated ahead of time to reduce the number of operations that must be performed to calculate motor speeds (important when this is implemented on a microcontroller). Finally, the following algorithm (described in pseudocode) is used to properly scale each motor. The scaling is done when no speed in the vector has a magnitude greater than 1. while true // index is index in speed_vector at which m occurs m, index = max(abs(speed_vector)) if m <= 1 // No speeds exceed max magnitude, so done scaling break endif // Scale speed_vector as needed for i = 0; i < length(overlap_vector[index]); ++i if overlap_vector[index][i] == 1 speed_vector[i] /= m; endif endfor endwhile Using this algorithm the earlier example results in the following scaled speed vector (which is optimal for the requested motions). Motor 1, 2, 3, 4 speeds divided by 2 and motor 5, 6, 7, 8 speeds divided by 3. This results in the fastest motor within each group being at 100% speed, thus this is optimal scaling.","title":"Scaling Motor Outputs"},{"location":"firmware/math/#global-targets","text":"Instead of providing desired motion relative to the robot's orientation, it is often easier to specify motion relative to the world (at least partially). This requires knowing information about the robot's orientation in 3D space. However, for this application the robot's heading will be ignored (meaning x and y are relative to the robot's orientation, but z is world-relative). This effectively turns the target vector previously provided into a pseudo world-relative motion target (DoFs are world coordinate system not robot coordinate system). However, y still means forward relative to robot heading not relative to the world coordinate system (same idea for x too). This method is used instead of a true global target for two reasons The method described above does not require knowing the robot's heading in 3D space. As such, the required information can be obtained without use of a magnetometer. This is beneficial as magnetometers become unreliable in close proximity to motors. Note that the gyro alone is sufficient for heading information, but without a magnetometer it will drift significantly over time, making this less effective. Mission level code's knowledge of the robot's position relative to objects of interest often has no knowledge of a world coordinate system. As such, keeping x and y translations robot-relative simplifies mission code and reduces errors for closed loop control in mission code. The target vector can be split into two parts: a translation vector and a rotation vector. Both vectors are in an [x, y, z] order. Translations are along the given axes. Rotations are about the given axes The idea is to determine a rotation matrix to translate the world gravity vector to the robot's measured gravity vector. This is the same rotation that should then be applied to each of the vectors described above (translation and rotation). In practice, an AHRS algorithm can provide robot orientation in 3D space (with absolute pitch and roll due to the accelerometer). This algorithm provides a quaternion representing the robot's orientation in 3d space. Note that this quaternion cannot be directly converted into a rotation matrix, as that does not ignore the yaw component (as is desired for global mode). Thus, instead, the quaternion is used to construct a vector in the direction of gravity ( g_r ) as shown below g_r.x = 2.0 * (-q.x*q.z + q.w*q.y) g_r.y = 2.0 * (-q.w*q.x - q.y*q.z) g_r.z = -q.w*q.w + q.x*q.x + q.y*q.y - q.z*q.z It is assumed that when the robot's coordinate frame matches the world's coordinate frame, the measured gravity vector will be [0, 0, -g] (meaning in the negative z direction). This must be configured to be the case (IMU supports axis remapping internally to allow this regardless of how the IMU is mounted). Then, given a world gravity vector ( g_w ) and a measured gravity vector g_r a rotation matrix ( R ) to rotate vectors from the world coordinate system into the robot's coordinate system can be calculated as shown below Where [v_c]_x is the skew symmetric cross product matrix of v_c defined as follows Then each of the translation and rotation targets can be rotated by multiplication by the rotation matrix R. The translation and rotation vectors are then concatenated to create the full local target vector.","title":"Global Targets"},{"location":"firmware/math/#stability-assist-mode-math","text":"Stability assist mode is used to abstract a \"2D\" working plane to control the vehicle in. This is done by using closed-loop control to maintain pitch, roll, and depth in 3D space (leaving the x, y, and yaw DoFs). Optionally, closed-loop control can also be used for yaw leaving just the x and y DoFs. This is built on top of global mode. Thus, stability assist mode calculates the current desired speed in each degree of freedom managed by closed loop controllers (pitch, roll, depth, and sometimes yaw). The speeds in other DoFs are specified by the PC just as they would be in global mode.","title":"Stability Assist Mode Math"},{"location":"firmware/math/#orientation-closed-loop-control","text":"TODO: Document current and past issues including gimbal lock problem. Document current (partial) solution.","title":"Orientation Closed-Loop Control"},{"location":"firmware/math/#depth-closed-loop-control","text":"Depth closed-loop control is implemented using a PID. This PID's output is used as the target speed in the z DoF. The error is the difference between the current depth sensor reading and the specified target depth (in meters; negative for below the surface).","title":"Depth Closed-Loop Control"},{"location":"firmware/math/#imu-angle-accumulation","text":"The euler and quaternion values provided by the IMU are not directly useful for tracking multiple rotations of the vehicle. Unlike simply integrating gyroscope data, euler angles (pitch, roll, yaw) and quaternions do not track the number of times the vehicle has rotated about a particular axis. While integrating raw gyro data would provide this, such a solution would be rotations about the robot's axes, not the world's axes (gyro z of 500 does not necessarily mean the robot has yawed 500 degrees; the robot could have been oriented at a pitch of 90). Additionally, the drift for accumulated pitch and roll would be significantly worse due to the loss of accelerometer data. To address this, it is necessary to track changes between subsequent quaternions from the IMU. Quaternions are used for three reasons Firmware bugs in some BNO055 firmware versions lead to unstable euler angles It is mathematically easier to determine the shortest rotation between two quaternions Quaternions still allow accumulation to work in gimbal lock situations The idea is to compare each quaternion read from the IMU with the previous quaternion received from the IMU (note that quaternions of all zeros are ignored to avoid issues with invalid IMU data after exiting config mode). For each read quaternion: Calculate the shortest set of rotations from the previous to the current quaternion Convert the shortest angle to euler angles Add the pitch, roll, and yaw from the shortest euler angles to accumulated pitch, roll, and yaw variables Note that if the IMU axis config changes, the accumulated data should be zeroed and the previously read quaternion discarded. This method makes the assumption that the smallest rotation between two quaternions is the most probable path the robot took to change its orientation. This is an approximation, however it is a fairly good one as long as sample rate of data is sufficiently high. The specifics of the path are lost. However, if the sample rate is high enough, the length of the path is sufficiently small that this is a good approximation. The second \"issue\" with this approximation has to do with rotations exceeding 180 degrees. The method for determining shortest path between two quaternions will be incorrect if the vehicle rotates more than 180 degrees in any axis (because the shortest path would have involved rotating the other direction). To guarantee rotations between two samples never exceed 180 degrees, the max measured rotation rate of the gyro is considered. For the BNO055 this is 2000 degrees per second. Thus, with a sample period of l milliseconds, the largest angle change between samples is \\frac{2000 \\textrm{ deg}}{1 \\textrm{ sec}} \\cdot \\frac{1 \\textrm{ sec}}{1000 \\textrm{ ms}} \\cdot \\frac{l \\textrm{ ms}}{1 \\textrm{ sample}} = 2l \\textrm{ deg / sample} To ensure that changes of more than 180 degrees do not occur, the following must be satisfied 2l < 180 \\rightarrow l < 90 \\textrm{ milliseconds} However, it is possible for some samples from the IMU to be delayed (ie I2C bus busy with another sensor) or lost (I2C failure). Thus, it is necessary to choose a value for l that allows for at least one sample to be lost. When a sample is lost, this doubles the effective time between samples. Thus, it is necessary to half l l < 45 \\textrm{ milliseconds} By further reducing l it is possible to allow for larger delays or more lost samples. The current firmware samples IMU data every 15ms (the max rate supported by the BNO055 in fusion mode is 100Hz = 10ms period). Using l=15 \\textrm{ ms} it is possible for 5 consecutive samples to be lost while still guaranteeing that no more than 90ms passes between valid samples (thus still ensuring no more than 180 degree change between samples).","title":"IMU Angle Accumulation"},{"location":"firmware/overview/","text":"Overview TODO: Project Structure and Build System TODO: Generator projects TODO: System architecture","title":"Overview"},{"location":"firmware/overview/#overview","text":"TODO: Project Structure and Build System TODO: Generator projects TODO: System architecture","title":"Overview"},{"location":"hardware/sensors/","text":"Off-Board Sensors The control board has an integrated IMU (gyro + accel) and is not designed to support off-board IMUs. However, for full functionality, vehicle depth data is also required. This data is provided by an off-board depth sensor. Currently, only one such sensor is supported: MS5837-30BA pressure sensor based depth sensors. The sensor used during development and tested with the control board is BlueRobotics' Bar30 Sensor . The depth sensor is to be connected to the control board via the \"Depth I2C\" header. See the pinout images on the v1 or v2 hardware pages for more details. If using the BlueRobotics sensor, you will need to cut off the connector it comes with and install \"DuPont\" connectors.","title":"Off-Board Sensors"},{"location":"hardware/sensors/#off-board-sensors","text":"The control board has an integrated IMU (gyro + accel) and is not designed to support off-board IMUs. However, for full functionality, vehicle depth data is also required. This data is provided by an off-board depth sensor. Currently, only one such sensor is supported: MS5837-30BA pressure sensor based depth sensors. The sensor used during development and tested with the control board is BlueRobotics' Bar30 Sensor . The depth sensor is to be connected to the control board via the \"Depth I2C\" header. See the pinout images on the v1 or v2 hardware pages for more details. If using the BlueRobotics sensor, you will need to cut off the connector it comes with and install \"DuPont\" connectors.","title":"Off-Board Sensors"},{"location":"hardware/v1/","text":"AUV Control Board v1 Note that some pictures show a version with a pressure / temperature sensor. This is no longer used and should not be included when building the board. The default coordinate system as defined by the IMU is shown below. Note that this is a right hand coordinate system. The red arrows define axes. Rotation about these axes is in the right hand direction (indicated by green arrows). Notice that the green arrows are on top of the red axis arrows, thus a \"left to right\" arrow is left to right across the top of the axis. The axis configuration can be changed to match any plane-aligned mounting position of the control board on a robot. See the BNO055 datasheet for more information. Components 1x Adafruit ItsyBitsy M4 1x Adafruit BNO055 Breakout STEMMA QT version can be substituted, however be aware that the pin order is different. Protoboard (2.54mm spacing; 24 by 18 holes; 5cm by 7cm) These can be found from many vendors Solid Core Wire (22AWG) Female Pin Headers (2.54mm pitch) Two 1x14 headers One 1x6 header One 1x4 header Note: These can be cut between pins carefully Male pin headers (2.54mm pitch) Two 1x8 headers One 1x4 header Two 1x2 headers (optional; for debug interface) Note: These can easily be cut / broken between pins. Two 10K resistors (through hole, 1/4 W) Wiring Diagram Assembly Instructions Solder header strips in the positions shown below. The female headers avoid soldering breakouts / dev boards directly to protoboard which allows easily replacing components if needed (or reusing them for other purposes later). After soldering, breakouts can be populated to make identifying pins easier. The crossed out header can be omitted as it was formerly used for the pressure / temp sensor (not used anymore). Wire the protoboard according to the wiring diagram. Note that the first image shows the pressure / temperature sensor (this should be omitted). The first photo also does not show the pullup resistors or debug headers. The second picture is closer to what a fully assembled Control Board v1 should look like. Hot glue can be used to ensure the resistor leads do not short anything. This photo is an older assembly that includes the temp / pressure sensor (should be omitted) and excludes the pullup resistors and debug headers (should be included). This photo shows the pullup resistors and debug headers Back side wiring","title":"Version 1"},{"location":"hardware/v1/#auv-control-board-v1","text":"Note that some pictures show a version with a pressure / temperature sensor. This is no longer used and should not be included when building the board. The default coordinate system as defined by the IMU is shown below. Note that this is a right hand coordinate system. The red arrows define axes. Rotation about these axes is in the right hand direction (indicated by green arrows). Notice that the green arrows are on top of the red axis arrows, thus a \"left to right\" arrow is left to right across the top of the axis. The axis configuration can be changed to match any plane-aligned mounting position of the control board on a robot. See the BNO055 datasheet for more information.","title":"AUV Control Board v1"},{"location":"hardware/v1/#components","text":"1x Adafruit ItsyBitsy M4 1x Adafruit BNO055 Breakout STEMMA QT version can be substituted, however be aware that the pin order is different. Protoboard (2.54mm spacing; 24 by 18 holes; 5cm by 7cm) These can be found from many vendors Solid Core Wire (22AWG) Female Pin Headers (2.54mm pitch) Two 1x14 headers One 1x6 header One 1x4 header Note: These can be cut between pins carefully Male pin headers (2.54mm pitch) Two 1x8 headers One 1x4 header Two 1x2 headers (optional; for debug interface) Note: These can easily be cut / broken between pins. Two 10K resistors (through hole, 1/4 W)","title":"Components"},{"location":"hardware/v1/#wiring-diagram","text":"","title":"Wiring Diagram"},{"location":"hardware/v1/#assembly-instructions","text":"Solder header strips in the positions shown below. The female headers avoid soldering breakouts / dev boards directly to protoboard which allows easily replacing components if needed (or reusing them for other purposes later). After soldering, breakouts can be populated to make identifying pins easier. The crossed out header can be omitted as it was formerly used for the pressure / temp sensor (not used anymore). Wire the protoboard according to the wiring diagram. Note that the first image shows the pressure / temperature sensor (this should be omitted). The first photo also does not show the pullup resistors or debug headers. The second picture is closer to what a fully assembled Control Board v1 should look like. Hot glue can be used to ensure the resistor leads do not short anything. This photo is an older assembly that includes the temp / pressure sensor (should be omitted) and excludes the pullup resistors and debug headers (should be included). This photo shows the pullup resistors and debug headers Back side wiring","title":"Assembly Instructions"},{"location":"hardware/v2/","text":"AUV Control Board v2 The default coordinate system as defined by the IMU is shown below. Note that this is a right hand coordinate system. The red arrows define axes. Rotation about these axes is in the right hand direction (indicated by green arrows). Notice that the green arrows are on top of the red axis arrows, thus a \"left to right\" arrow is left to right across the top of the axis. The axis configuration can be changed to match any plane-aligned mounting position of the control board on a robot. See the BNO055 datasheet for more information. Components 1x WeAct Studio Black Pill (w / STM32F411 notSTM32F401 ) Note: There are many counterfeit boards sold. These should be avoided. Adafruit Store Aliexpress (Offical WeAct Studio Store) 1x Adafruit BNO055 Breakout STEMMA QT version can be substituted, however be aware that the pin order is different. Protoboard (2.54mm spacing; 24 by 18 holes; 5cm by 7cm) These can be found from many vendors Solid Core Wire (22AWG) Female Pin Headers (2.54mm pitch) Two 1x20 headers One 1x6 header One 1x4 header Note: These can be cut between pins carefully Male pin headers (2.54mm pitch) Two 1x8 headers One 1x4 header Note: These can easily be cut / broken between pins. Resistors (through hole, 1/4 W) Two 10K resistors Two 10 Ohm resistors One 100 Ohm resistor One QBL8RGB60D0-2897 RGB LED Wiring Diagram Assembly Instructions Solder header strips in the positions shown below. The female headers avoid soldering breakouts / dev boards directly to protoboard which allows easily replacing components if needed (or reusing them for other purposes later). After soldering, breakouts can be populated to make identifying pins easier. The location of the LED is also indicated here. Wire the protoboard according to the wiring diagram.","title":"Version 2"},{"location":"hardware/v2/#auv-control-board-v2","text":"The default coordinate system as defined by the IMU is shown below. Note that this is a right hand coordinate system. The red arrows define axes. Rotation about these axes is in the right hand direction (indicated by green arrows). Notice that the green arrows are on top of the red axis arrows, thus a \"left to right\" arrow is left to right across the top of the axis. The axis configuration can be changed to match any plane-aligned mounting position of the control board on a robot. See the BNO055 datasheet for more information.","title":"AUV Control Board v2"},{"location":"hardware/v2/#components","text":"1x WeAct Studio Black Pill (w / STM32F411 notSTM32F401 ) Note: There are many counterfeit boards sold. These should be avoided. Adafruit Store Aliexpress (Offical WeAct Studio Store) 1x Adafruit BNO055 Breakout STEMMA QT version can be substituted, however be aware that the pin order is different. Protoboard (2.54mm spacing; 24 by 18 holes; 5cm by 7cm) These can be found from many vendors Solid Core Wire (22AWG) Female Pin Headers (2.54mm pitch) Two 1x20 headers One 1x6 header One 1x4 header Note: These can be cut between pins carefully Male pin headers (2.54mm pitch) Two 1x8 headers One 1x4 header Note: These can easily be cut / broken between pins. Resistors (through hole, 1/4 W) Two 10K resistors Two 10 Ohm resistors One 100 Ohm resistor One QBL8RGB60D0-2897 RGB LED","title":"Components"},{"location":"hardware/v2/#wiring-diagram","text":"","title":"Wiring Diagram"},{"location":"hardware/v2/#assembly-instructions","text":"Solder header strips in the positions shown below. The female headers avoid soldering breakouts / dev boards directly to protoboard which allows easily replacing components if needed (or reusing them for other purposes later). After soldering, breakouts can be populated to make identifying pins easier. The location of the LED is also indicated here. Wire the protoboard according to the wiring diagram.","title":"Assembly Instructions"},{"location":"user_guide/comm_protocol/","text":"Communication Protocol Communication with the control board relies on sending messages between the control board and PC. This section focuses on how messages are sent, not what messages are sent. Hardware Communication Layer Messages are sent to the control board over the MCU's builtin USB port. The control board acts as a USB ACM CDC device. In practice, this means that it shows up as a serial (UART) port on the computer it is connected to. However, baud rate settings are irrelevant (and changing baud rates has no effect). As such, messages are sent to / received from the control board using \"UART\" with an undefined baud rate*. It is still necessary to set a baud rate when opening a UART port (as that information is provided to the device on the other side), but the rate is unused. Additionally, it is expected to operate in 8N1 data mode (8 data bits, no parity, 1 stop bit). A stream of data is sent to the control board over this port. This data is interpreted as described below. * NOTE: The baud rate 1200 is an exception. Openening then closing the port at this baud rate is used to trigger the control board to reboot to its bootloader. Do not use 1200 baud! Message Format and Construction The messages sent to / received from the control board have a specific format. Each message transfers a raw set of bytes (unsigned byte array). This set of bytes is the \"payload data\" of the message. The \"payload data\" is the data that is actually being send via the message. Messages are limited to a maximum payload size of 96 bytes. To be able to identify what data is part of a single message, it is necessary to add some additional information around the payload. The control board uses a special byte to indicate the start of a message ( START_BYTE ) and another one to identify the end of a message ( END_BYTE ). Since the payload could itself contain a start or end byte, there is also an escape byte ( ESCAPE_BYTE ) used to escape a START_BYTE , END_BYTE , or an ESCAPE_BYTE in the payload. START_BYTE becomes ESCAPE_BYTE , START_BYTE END_BYTE becomes ESCAPE_BYTE , END_BYTE ESCAPE_BYTE becomes ESCAPE_BYTE , ESCAPE_BYTE This is similar to escaping a quote in a string using a backslash. For the control board: START_BYTE = 253 (unsigned 8-bit) = -3 (signed 8-bit) END_BYTE = 254 (unsigned 8-bit) = -2 (signed 8-bit) ESCAPE_BYTE = 255 (unsigned 8-bit) = -1 (signed 8-bit) In addition to the control bytes and the payload, each message contains two other pieces of information: First, each message includes a prepended* ID number (16-bit unsigned big-endian integer). These ID numbers are required to be unique only in one direction . This means that two messages sent from the PC to the control board cannot have the same id. Likewise, two messages sent from the control board to the PC cannot have the same id. However, a message sent from PC to control board can have the same id as another message sent from control board to PC. Note that in practice, eventually (after 65535 messages sent one way) ID numbers must eventually repeat. This is acceptable as long as no two messages that are sent \"close together\" have the same id. Effectively, no two \"active\" messages in a single direction may have the same ID (what \"active\" means can vary, but in practice by the time 65,000 messages have been sent, old messages can be assumed inactive). Second, each message has a CRC appended* to it. This is a 16-bit CRC using the CCITT-FALSE algorithm. It is appended* to the message big endian. The CRC is calculated on the concatenation of the message id bytes and the raw (unescaped) payload bytes. Just like the payload data, when prepending or appending message id or crc, it is necessary to escape bytes that are equal to control bytes (start, end, escape). * Note that append and prepend still mean contained between control (start and end) bytes. This results in message construction looking like the following (the \"payload\" is the raw message being sent).","title":"Communication Protocol"},{"location":"user_guide/comm_protocol/#communication-protocol","text":"Communication with the control board relies on sending messages between the control board and PC. This section focuses on how messages are sent, not what messages are sent.","title":"Communication Protocol"},{"location":"user_guide/comm_protocol/#hardware-communication-layer","text":"Messages are sent to the control board over the MCU's builtin USB port. The control board acts as a USB ACM CDC device. In practice, this means that it shows up as a serial (UART) port on the computer it is connected to. However, baud rate settings are irrelevant (and changing baud rates has no effect). As such, messages are sent to / received from the control board using \"UART\" with an undefined baud rate*. It is still necessary to set a baud rate when opening a UART port (as that information is provided to the device on the other side), but the rate is unused. Additionally, it is expected to operate in 8N1 data mode (8 data bits, no parity, 1 stop bit). A stream of data is sent to the control board over this port. This data is interpreted as described below. * NOTE: The baud rate 1200 is an exception. Openening then closing the port at this baud rate is used to trigger the control board to reboot to its bootloader. Do not use 1200 baud!","title":"Hardware Communication Layer"},{"location":"user_guide/comm_protocol/#message-format-and-construction","text":"The messages sent to / received from the control board have a specific format. Each message transfers a raw set of bytes (unsigned byte array). This set of bytes is the \"payload data\" of the message. The \"payload data\" is the data that is actually being send via the message. Messages are limited to a maximum payload size of 96 bytes. To be able to identify what data is part of a single message, it is necessary to add some additional information around the payload. The control board uses a special byte to indicate the start of a message ( START_BYTE ) and another one to identify the end of a message ( END_BYTE ). Since the payload could itself contain a start or end byte, there is also an escape byte ( ESCAPE_BYTE ) used to escape a START_BYTE , END_BYTE , or an ESCAPE_BYTE in the payload. START_BYTE becomes ESCAPE_BYTE , START_BYTE END_BYTE becomes ESCAPE_BYTE , END_BYTE ESCAPE_BYTE becomes ESCAPE_BYTE , ESCAPE_BYTE This is similar to escaping a quote in a string using a backslash. For the control board: START_BYTE = 253 (unsigned 8-bit) = -3 (signed 8-bit) END_BYTE = 254 (unsigned 8-bit) = -2 (signed 8-bit) ESCAPE_BYTE = 255 (unsigned 8-bit) = -1 (signed 8-bit) In addition to the control bytes and the payload, each message contains two other pieces of information: First, each message includes a prepended* ID number (16-bit unsigned big-endian integer). These ID numbers are required to be unique only in one direction . This means that two messages sent from the PC to the control board cannot have the same id. Likewise, two messages sent from the control board to the PC cannot have the same id. However, a message sent from PC to control board can have the same id as another message sent from control board to PC. Note that in practice, eventually (after 65535 messages sent one way) ID numbers must eventually repeat. This is acceptable as long as no two messages that are sent \"close together\" have the same id. Effectively, no two \"active\" messages in a single direction may have the same ID (what \"active\" means can vary, but in practice by the time 65,000 messages have been sent, old messages can be assumed inactive). Second, each message has a CRC appended* to it. This is a 16-bit CRC using the CCITT-FALSE algorithm. It is appended* to the message big endian. The CRC is calculated on the concatenation of the message id bytes and the raw (unescaped) payload bytes. Just like the payload data, when prepending or appending message id or crc, it is necessary to escape bytes that are equal to control bytes (start, end, escape). * Note that append and prepend still mean contained between control (start and end) bytes. This results in message construction looking like the following (the \"payload\" is the raw message being sent).","title":"Message Format and Construction"},{"location":"user_guide/general_use/","text":"Using Control Board TODO General Procedure Connecting to Control Board System configuration (motor matrix, thruster inversions) Sensor configuration Validating sensor connectivity Modes of operation & setting speed Motor Watchdog Reading Sensor data Example program using python interface script LED Indicator Info","title":"Using Control board"},{"location":"user_guide/general_use/#using-control-board","text":"TODO General Procedure Connecting to Control Board System configuration (motor matrix, thruster inversions) Sensor configuration Validating sensor connectivity Modes of operation & setting speed Motor Watchdog Reading Sensor data Example program using python interface script LED Indicator Info","title":"Using Control Board"},{"location":"user_guide/messages/","text":"Messages This section describes what specific messages are sent to / received from the control board and what they do / mean. This does not address how messages are constructed or sent. For such information, see Communication Protocol . Note: The Communication Protocol page uses the term \"payload\" for the data being transferred and \"message\" for the formatted / fully constructed set of data. Here, what we refer to as \"messages\" are actually the \"payload\" data, not the constructed data. Types of Messages Commands : Messages instructing an action be taken. These messages must be acknowledged upon receipt. The acknowledgement typically contains no data. Sent from PC to control board. Queries : Messages requesting information. These messages must be acknowledged upon receipt. The acknowledgement will contain the requested information. Sent from PC to control board. Acknowledgements : A very specific type of message acknowledging receipt of another message (with an error code and optional data). Sent from control board to PC. Status Messages : Unprompted messages containing information about state / data changes. Sent from control board to PC. Message Definition Conventions In the following sections, the following standard is used to describe message contents: Each message's contents are shown as a comma separated list of bytes. Each comma separated item is a single byte, with one exception for parameters (as described below) Parameters are shown inside square brackets. Parameters represent a value that will be described in more detail below the message structure information. Parameters can be multiple bytes (even though they take only one entry between commas). ASCII characters are shown in single quotes. These are single byte unsigned ASCII characters. Numbers are not contained within any symbols. Numbers may be in hex (prefix 0x), binary (prefix 0b), or decimal (no prefix). Commands Configuration Commands Motor Matrix Set Motor matrix set command is used to set a single row of the motor matrix. It has the following format 'M', 'M', 'A', 'T', 'S', [thruster_num], [x], [y], [z], [pitch], [roll], [yaw] [thruster_num] : A single byte who'se unsigned value is the thruster number the row data should be set for (1-8). [x] , [y] , [z] , [pitch] , [roll] , [yaw] : Columns of the motor matrix row being set. Each is a 32-bit float (little endian). This message will be acknowledged. The acknowledge message will contain no result data. Motor Matrix Update Motor matrix update command is used to inform the control board the motor matrix has changed. Causes the control board to perform some calculations with the new motor matrix. This should be sent after writing all rows of the motor matrix that should change using the motor matrix set command. The motor matrix update command has the following format 'M', 'M', 'A', 'T', 'U' This message will be acknowledged. The acknowledge message will contain no result data. Thruster Inversion Set Thruster inversion set command is used to invert the positive and negative direction of thrusters. It has the following format 'T', 'I', 'N', 'V', [inv] [inv] : A single byte where each bit represents the inversion status of a thruster. The MSB (bit 7) corresponds to thruster 8 and the LSB corresponds to thruster 1 (bit + 1 = thruster). A bit value of 1 means the thruster is inverted. A bit value of 0 means the thruster is not inverted. This message will be acknowledged. The acknowledge message will contain no result data. BNO055 IMU Axis Configure Command Used to configure the BNO055 IMU's axis orientation. Note: This will also reset the accumulated euler angles to zero . 'B', 'N', 'O', '0', '5', '5', 'A', [config] [config] : A single byte. The value of this byte is between 0 and 7 (inclusive) representing on of the BNO055 axis configs (P0 to P7) as described in the BNO055 datasheet. Note: Changing the axis config changes IMU mode. Thus, there will be a brief time afterwards where the IMU may report zeros for all data. This message will be acknowledged. The acknowledge message will contain no result data. Stability Assist Mode PID Tune Command Used to tune stability assist mode PID controllers (note that the depth PID is also used for depth hold mode). It has the following format 'S', 'A', 'S', 'S', 'I', 'S', 'T', 'T', 'N', [which], [kp], [ki], [kd], [limit], [invert] [which] indicates which PID to tune ('P' = pitch hold, 'R' = roll hold, 'Y' = yaw hold, 'D' = depth hold). [kp] , [ki] , [kd] are proportional, integral, derivative, and feed-forward gains (32-bit float little endian). [limit] Is the PID controller's max output (limits max speed in the controlled DoF). Must be between 0.0 and 1.0. 32-bit float little endian. [invert] Set to one to invert PID output. Zero otherwise. Motor Control Commands Raw Speed Set Used to set motor speeds in RAW mode. This command has the following format. 'R', 'A', 'W', [speed_1], [speed_2], [speed_3], [speed_4], [speed_5], [speed_6], [speed_7], [speed_8] [speed_n] : The speed of thruster n from -1.0 to 1.0. A 32-bit float (little endian). This message will be acknowledged. The acknowledge message will contain no result data. Local Speed Set Used to set motor speeds in LOCAL mode. This command has the following format 'L', 'O', 'C', 'A', 'L', [x], [y], [z], [pitch], [roll], [yaw] [x] , [y] , [z] , [pitch] , [roll] , [yaw] : Speed for each DoF relative to the robot -1.0 to 1.0. A 32-bit float (little endian). This message will be acknowledged. The acknowledge message will contain no result data. Global Speed Set Used to set motor speeds in GLOBAL mode. This command has the following format 'G', 'L', 'O', 'B', 'A', 'L', [x], [y], [z], [pitch], [roll], [yaw] [x] , [y] , [z] , [pitch] , [roll] , [yaw] : Speed for each DoF relative to the world (pitch and roll compensated; not yaw compensated) -1.0 to 1.0. A 32-bit float (little endian). This message will be acknowledged. The acknowledge message will contain no result data. Note that if the IMU is not working properly, this command will be acknowledged with the \"Invalid Command\" error code. This can occur if the axis config of the IMU is changed immediately before issuing this command. Stability Assist Speed Set (Variant 1) Used to set motor speeds in STABILITY_ASSIST mode using a speed for yaw. This command has the following format 'S', 'A', 'S', 'S', 'I', 'S', 'T', 'S', 'T', '1', [x], [y], [yaw], [target_pitch], [target_roll], [target_depth] Each value is a 32-bit float little endian. Pitch and roll are euler angles (in degrees). These are intrinsic euler angles (z-x'-y'' convention per the control board's coordinate system). Depth is in meters where negative numbers are below the surface. x, y, and yaw are speeds in the x, y, and yaw DoFs the same as in GLOBAL mode. This message will be acknowledged with no data. Note that if the IMU or depth sensor is not working properly, this command will be acknowledged with the \"Invalid Command\" error code. This can occur if the axis config of the IMU is changed immediately before issuing this command. Stability Assist Speed Set (Variant 2) Used to set motor speeds in STABILITY_ASSIST mode using a PID to maintain a target yaw. This command has the following format 'S', 'A', 'S', 'S', 'I', 'S', 'T', 'S', 'T', '2', [x], [y], [target_pitch], [target_roll], [target_yaw], [target_depth] Each value is a 32-bit float little endian. Pitch, roll, and yaw are euler angles (in degrees). These are intrinsic euler angles (z-x'-y'' convention per the control board's coordinate system). Depth is in meters where negative numbers are below the surface. x and y are speeds in the x and y DoFs the same as in GLOBAL mode. This message will be acknowledged with no data. Note that if the IMU or depth sensor is not working properly, this command will be acknowledged with the \"Invalid Command\" error code. This can occur if the axis config of the IMU is changed immediately before issuing this command. Depth Hold Speed Set Used to set motor speeds in DEPTH_HOLD mode. This command has the following format 'D', 'H', 'O', 'L', 'D', [x], [y], [pitch], [roll], [yaw], [target_depth] Each value is a 32-bit float. Everything except [target_depth] is a speed (same as GLOBAL mode speeds). Target depth is in meters (negative for below surface). Other Commands Feed Motor Watchdog Used to feed the motor watchdog so it does not kill the motors. This command has the following format 'W', 'D', 'G', 'F' This message will be acknowledged. The acknowledge message will contain no result data. BNO055 Periodic Read Used to enable / disable periodic reading of BNO055 data. This will only impact data being sent from control board to the pc. The control board itself will continue to read and use IMU data. 'B', 'N', 'O', '0', '5', '5', 'P', [enable] [enable] is an 8-bit integer with a value of either 1 or 0. If 1, reading data periodically is enabled. If 0, reading data periodically is disabled. This message will be acknowledged. The acknowledge message will contain no result data. MS5837 Periodic Read Used to enable / disable periodic reading of MS5837 data. This will only impact data being sent from control board to the pc. The control board itself will continue to read and use depth sensor data. 'M', 'S', '5', '8', '3', '7', 'P', [enable] [enable] is an 8-bit integer with a value of either 1 or 0. If 1, reading data periodically is enabled. If 0, reading data periodically is disabled. This message will be acknowledged. The acknowledge message will contain no result data. Reset Command This command is used to rest the control board itself. This will reset the microcontroller on the control board, thus the USB device will disconnect and reconnect (note that if your program still holds the port when this happens, the USB device will likely be assigned a different port number). 'R', 'E', 'S', 'E', 'T', 0x0D, 0x1E This message is not acknowledged. Queries Sensor Status Query Gets the status of all sensors (BNO055 and MS5837). 'S', 'S', 'T', 'A', 'T' This message will be acknowledged. If acknowledged with no error, the response will contain data in the following format [status_byte] [status_byte] : Single byte containing bits for the status of all sensors. Bit 0 (LSB) is BNO055 status. Bit 1 is MS5837 status. A status bit of 1 indicates the sensor is \"ready\" (connected and can be used). A status bit of 0 indicates the sensor is \"not ready\". BNO055 Read Reads BNO055 IMU data once. 'B', 'N', 'O', '0', '5', '5', 'R' This message will be acknowledged. If acknowledged with no error, the response will contain data in the following format. Note that this is the same format as the data contained within the BNO055 data status message. [quat_w], [quat_x], [quat_y], [quat_z], [accum_pitch], [accum_roll], [accum_yaw] Each value is a 32-bit float, little endian. quat_ values are components of the orientation quaternion. accum_ values are accumulated euler angles. MS5837 Read Reads MS5837 data once. 'M', 'S', '5', '8', '3', '7', 'R' This message will be acknowledged. If acknowledged with no error, the response will contain data in the following format. Note that this is the same format as the data contained within the MS5837 data status message. [depth_m] depth_m is a 32-bit float, little endian. Last Reset Cause Query Get error code for last system reset cause of the control board. Generally not useful for end users, except for reporting errors. Mainly a debug / development tool. See error codes in firmware source debug.h . 'R', 'S', 'T', 'W', 'H', 'Y' This message will be acknowledged. If acknowledged with no error, the response will contain data in the following format. [error_code] error_code is a 32-bit integer (signed), little endian. Acknowledgements An acknowledgement message has the following format 'A', 'C', 'K', [ack_id], [error_code], [result] [ack_id] : The ID of the message being acknowledged. Unsigned 16-bit integer (big endian). [error_code] : A single byte error code. 0 = None: No error. 1 = Unknown Message: Control board does not recognize the message. 2 = Invalid arguments: Message is recognized, but arguments are invalid 3 = Invalid Command: Command is known, but is not valid at this time. 255 = Reserved: Control board will not use this code. Typically used as timeout. [result] : Optional data of variable size attached to the acknowledge message. Its size, format, and meaning depends on the message being acknowledged. Status Messages Motor Watchdog Status Motor watch status message is used by the control board to notify the PC about changes to motor (watchdog) state. It has the following format 'W', 'D', 'G', 'S', [status] [status] is a single byte. A value of 1 indicates the motors are enabled. A value of zero indicates the motors are currently killed by the watchdog. BNO055 Data Status Used by the control board to periodically send IMU data to the PC. Only sent when BNO055 periodic reads are enabled via the BNO055 periodic read command. The message has the following format 'B', 'N', 'O', '0', '5', '5', 'D', [quat_w], [quat_x], [quat_y], [quat_z], [accum_pitch], [accum_roll], [accum_yaw] Each value is a 32-bit float, little endian. quat_ values are components of the orientation quaternion. accum_ values are accumulated euler angles. MS5837 Data Status Used by the control board to periodically send IMU data to the PC. Only sent when BNO055 periodic reads are enabled via the BNO055 periodic read command. The message has the following format 'M', 'S', '5', '8', '3', '7', 'D', [depth_m] depth_m is a 32-bit float, little endian. Debug Status Messages Used only during development. These will not occur on release builds of the firmware. These are arbitrary messages sent by the control board to the PC for the firmware developer's use during development. They have the following format 'D', 'E', 'B', 'U', 'G', [msg] msg is an ascii string. Debug Data Status Messages Used only during development. These will not occur on release builds of the firmware. These are arbitrary messages sent by the control board to the PC for the firmware developer's use during development. They have the following format 'D', 'B', 'G', 'D', 'A', 'T', [msg] msg is arbitrary data.","title":"Messages"},{"location":"user_guide/messages/#messages","text":"This section describes what specific messages are sent to / received from the control board and what they do / mean. This does not address how messages are constructed or sent. For such information, see Communication Protocol . Note: The Communication Protocol page uses the term \"payload\" for the data being transferred and \"message\" for the formatted / fully constructed set of data. Here, what we refer to as \"messages\" are actually the \"payload\" data, not the constructed data.","title":"Messages"},{"location":"user_guide/messages/#types-of-messages","text":"Commands : Messages instructing an action be taken. These messages must be acknowledged upon receipt. The acknowledgement typically contains no data. Sent from PC to control board. Queries : Messages requesting information. These messages must be acknowledged upon receipt. The acknowledgement will contain the requested information. Sent from PC to control board. Acknowledgements : A very specific type of message acknowledging receipt of another message (with an error code and optional data). Sent from control board to PC. Status Messages : Unprompted messages containing information about state / data changes. Sent from control board to PC.","title":"Types of Messages"},{"location":"user_guide/messages/#message-definition-conventions","text":"In the following sections, the following standard is used to describe message contents: Each message's contents are shown as a comma separated list of bytes. Each comma separated item is a single byte, with one exception for parameters (as described below) Parameters are shown inside square brackets. Parameters represent a value that will be described in more detail below the message structure information. Parameters can be multiple bytes (even though they take only one entry between commas). ASCII characters are shown in single quotes. These are single byte unsigned ASCII characters. Numbers are not contained within any symbols. Numbers may be in hex (prefix 0x), binary (prefix 0b), or decimal (no prefix).","title":"Message Definition Conventions"},{"location":"user_guide/messages/#commands","text":"","title":"Commands"},{"location":"user_guide/messages/#configuration-commands","text":"Motor Matrix Set Motor matrix set command is used to set a single row of the motor matrix. It has the following format 'M', 'M', 'A', 'T', 'S', [thruster_num], [x], [y], [z], [pitch], [roll], [yaw] [thruster_num] : A single byte who'se unsigned value is the thruster number the row data should be set for (1-8). [x] , [y] , [z] , [pitch] , [roll] , [yaw] : Columns of the motor matrix row being set. Each is a 32-bit float (little endian). This message will be acknowledged. The acknowledge message will contain no result data. Motor Matrix Update Motor matrix update command is used to inform the control board the motor matrix has changed. Causes the control board to perform some calculations with the new motor matrix. This should be sent after writing all rows of the motor matrix that should change using the motor matrix set command. The motor matrix update command has the following format 'M', 'M', 'A', 'T', 'U' This message will be acknowledged. The acknowledge message will contain no result data. Thruster Inversion Set Thruster inversion set command is used to invert the positive and negative direction of thrusters. It has the following format 'T', 'I', 'N', 'V', [inv] [inv] : A single byte where each bit represents the inversion status of a thruster. The MSB (bit 7) corresponds to thruster 8 and the LSB corresponds to thruster 1 (bit + 1 = thruster). A bit value of 1 means the thruster is inverted. A bit value of 0 means the thruster is not inverted. This message will be acknowledged. The acknowledge message will contain no result data. BNO055 IMU Axis Configure Command Used to configure the BNO055 IMU's axis orientation. Note: This will also reset the accumulated euler angles to zero . 'B', 'N', 'O', '0', '5', '5', 'A', [config] [config] : A single byte. The value of this byte is between 0 and 7 (inclusive) representing on of the BNO055 axis configs (P0 to P7) as described in the BNO055 datasheet. Note: Changing the axis config changes IMU mode. Thus, there will be a brief time afterwards where the IMU may report zeros for all data. This message will be acknowledged. The acknowledge message will contain no result data. Stability Assist Mode PID Tune Command Used to tune stability assist mode PID controllers (note that the depth PID is also used for depth hold mode). It has the following format 'S', 'A', 'S', 'S', 'I', 'S', 'T', 'T', 'N', [which], [kp], [ki], [kd], [limit], [invert] [which] indicates which PID to tune ('P' = pitch hold, 'R' = roll hold, 'Y' = yaw hold, 'D' = depth hold). [kp] , [ki] , [kd] are proportional, integral, derivative, and feed-forward gains (32-bit float little endian). [limit] Is the PID controller's max output (limits max speed in the controlled DoF). Must be between 0.0 and 1.0. 32-bit float little endian. [invert] Set to one to invert PID output. Zero otherwise.","title":"Configuration Commands"},{"location":"user_guide/messages/#motor-control-commands","text":"Raw Speed Set Used to set motor speeds in RAW mode. This command has the following format. 'R', 'A', 'W', [speed_1], [speed_2], [speed_3], [speed_4], [speed_5], [speed_6], [speed_7], [speed_8] [speed_n] : The speed of thruster n from -1.0 to 1.0. A 32-bit float (little endian). This message will be acknowledged. The acknowledge message will contain no result data. Local Speed Set Used to set motor speeds in LOCAL mode. This command has the following format 'L', 'O', 'C', 'A', 'L', [x], [y], [z], [pitch], [roll], [yaw] [x] , [y] , [z] , [pitch] , [roll] , [yaw] : Speed for each DoF relative to the robot -1.0 to 1.0. A 32-bit float (little endian). This message will be acknowledged. The acknowledge message will contain no result data. Global Speed Set Used to set motor speeds in GLOBAL mode. This command has the following format 'G', 'L', 'O', 'B', 'A', 'L', [x], [y], [z], [pitch], [roll], [yaw] [x] , [y] , [z] , [pitch] , [roll] , [yaw] : Speed for each DoF relative to the world (pitch and roll compensated; not yaw compensated) -1.0 to 1.0. A 32-bit float (little endian). This message will be acknowledged. The acknowledge message will contain no result data. Note that if the IMU is not working properly, this command will be acknowledged with the \"Invalid Command\" error code. This can occur if the axis config of the IMU is changed immediately before issuing this command. Stability Assist Speed Set (Variant 1) Used to set motor speeds in STABILITY_ASSIST mode using a speed for yaw. This command has the following format 'S', 'A', 'S', 'S', 'I', 'S', 'T', 'S', 'T', '1', [x], [y], [yaw], [target_pitch], [target_roll], [target_depth] Each value is a 32-bit float little endian. Pitch and roll are euler angles (in degrees). These are intrinsic euler angles (z-x'-y'' convention per the control board's coordinate system). Depth is in meters where negative numbers are below the surface. x, y, and yaw are speeds in the x, y, and yaw DoFs the same as in GLOBAL mode. This message will be acknowledged with no data. Note that if the IMU or depth sensor is not working properly, this command will be acknowledged with the \"Invalid Command\" error code. This can occur if the axis config of the IMU is changed immediately before issuing this command. Stability Assist Speed Set (Variant 2) Used to set motor speeds in STABILITY_ASSIST mode using a PID to maintain a target yaw. This command has the following format 'S', 'A', 'S', 'S', 'I', 'S', 'T', 'S', 'T', '2', [x], [y], [target_pitch], [target_roll], [target_yaw], [target_depth] Each value is a 32-bit float little endian. Pitch, roll, and yaw are euler angles (in degrees). These are intrinsic euler angles (z-x'-y'' convention per the control board's coordinate system). Depth is in meters where negative numbers are below the surface. x and y are speeds in the x and y DoFs the same as in GLOBAL mode. This message will be acknowledged with no data. Note that if the IMU or depth sensor is not working properly, this command will be acknowledged with the \"Invalid Command\" error code. This can occur if the axis config of the IMU is changed immediately before issuing this command. Depth Hold Speed Set Used to set motor speeds in DEPTH_HOLD mode. This command has the following format 'D', 'H', 'O', 'L', 'D', [x], [y], [pitch], [roll], [yaw], [target_depth] Each value is a 32-bit float. Everything except [target_depth] is a speed (same as GLOBAL mode speeds). Target depth is in meters (negative for below surface).","title":"Motor Control Commands"},{"location":"user_guide/messages/#other-commands","text":"Feed Motor Watchdog Used to feed the motor watchdog so it does not kill the motors. This command has the following format 'W', 'D', 'G', 'F' This message will be acknowledged. The acknowledge message will contain no result data. BNO055 Periodic Read Used to enable / disable periodic reading of BNO055 data. This will only impact data being sent from control board to the pc. The control board itself will continue to read and use IMU data. 'B', 'N', 'O', '0', '5', '5', 'P', [enable] [enable] is an 8-bit integer with a value of either 1 or 0. If 1, reading data periodically is enabled. If 0, reading data periodically is disabled. This message will be acknowledged. The acknowledge message will contain no result data. MS5837 Periodic Read Used to enable / disable periodic reading of MS5837 data. This will only impact data being sent from control board to the pc. The control board itself will continue to read and use depth sensor data. 'M', 'S', '5', '8', '3', '7', 'P', [enable] [enable] is an 8-bit integer with a value of either 1 or 0. If 1, reading data periodically is enabled. If 0, reading data periodically is disabled. This message will be acknowledged. The acknowledge message will contain no result data. Reset Command This command is used to rest the control board itself. This will reset the microcontroller on the control board, thus the USB device will disconnect and reconnect (note that if your program still holds the port when this happens, the USB device will likely be assigned a different port number). 'R', 'E', 'S', 'E', 'T', 0x0D, 0x1E This message is not acknowledged.","title":"Other Commands"},{"location":"user_guide/messages/#queries","text":"Sensor Status Query Gets the status of all sensors (BNO055 and MS5837). 'S', 'S', 'T', 'A', 'T' This message will be acknowledged. If acknowledged with no error, the response will contain data in the following format [status_byte] [status_byte] : Single byte containing bits for the status of all sensors. Bit 0 (LSB) is BNO055 status. Bit 1 is MS5837 status. A status bit of 1 indicates the sensor is \"ready\" (connected and can be used). A status bit of 0 indicates the sensor is \"not ready\". BNO055 Read Reads BNO055 IMU data once. 'B', 'N', 'O', '0', '5', '5', 'R' This message will be acknowledged. If acknowledged with no error, the response will contain data in the following format. Note that this is the same format as the data contained within the BNO055 data status message. [quat_w], [quat_x], [quat_y], [quat_z], [accum_pitch], [accum_roll], [accum_yaw] Each value is a 32-bit float, little endian. quat_ values are components of the orientation quaternion. accum_ values are accumulated euler angles. MS5837 Read Reads MS5837 data once. 'M', 'S', '5', '8', '3', '7', 'R' This message will be acknowledged. If acknowledged with no error, the response will contain data in the following format. Note that this is the same format as the data contained within the MS5837 data status message. [depth_m] depth_m is a 32-bit float, little endian. Last Reset Cause Query Get error code for last system reset cause of the control board. Generally not useful for end users, except for reporting errors. Mainly a debug / development tool. See error codes in firmware source debug.h . 'R', 'S', 'T', 'W', 'H', 'Y' This message will be acknowledged. If acknowledged with no error, the response will contain data in the following format. [error_code] error_code is a 32-bit integer (signed), little endian.","title":"Queries"},{"location":"user_guide/messages/#acknowledgements","text":"An acknowledgement message has the following format 'A', 'C', 'K', [ack_id], [error_code], [result] [ack_id] : The ID of the message being acknowledged. Unsigned 16-bit integer (big endian). [error_code] : A single byte error code. 0 = None: No error. 1 = Unknown Message: Control board does not recognize the message. 2 = Invalid arguments: Message is recognized, but arguments are invalid 3 = Invalid Command: Command is known, but is not valid at this time. 255 = Reserved: Control board will not use this code. Typically used as timeout. [result] : Optional data of variable size attached to the acknowledge message. Its size, format, and meaning depends on the message being acknowledged.","title":"Acknowledgements"},{"location":"user_guide/messages/#status-messages","text":"Motor Watchdog Status Motor watch status message is used by the control board to notify the PC about changes to motor (watchdog) state. It has the following format 'W', 'D', 'G', 'S', [status] [status] is a single byte. A value of 1 indicates the motors are enabled. A value of zero indicates the motors are currently killed by the watchdog. BNO055 Data Status Used by the control board to periodically send IMU data to the PC. Only sent when BNO055 periodic reads are enabled via the BNO055 periodic read command. The message has the following format 'B', 'N', 'O', '0', '5', '5', 'D', [quat_w], [quat_x], [quat_y], [quat_z], [accum_pitch], [accum_roll], [accum_yaw] Each value is a 32-bit float, little endian. quat_ values are components of the orientation quaternion. accum_ values are accumulated euler angles. MS5837 Data Status Used by the control board to periodically send IMU data to the PC. Only sent when BNO055 periodic reads are enabled via the BNO055 periodic read command. The message has the following format 'M', 'S', '5', '8', '3', '7', 'D', [depth_m] depth_m is a 32-bit float, little endian. Debug Status Messages Used only during development. These will not occur on release builds of the firmware. These are arbitrary messages sent by the control board to the PC for the firmware developer's use during development. They have the following format 'D', 'E', 'B', 'U', 'G', [msg] msg is an ascii string. Debug Data Status Messages Used only during development. These will not occur on release builds of the firmware. These are arbitrary messages sent by the control board to the PC for the firmware developer's use during development. They have the following format 'D', 'B', 'G', 'D', 'A', 'T', [msg] msg is arbitrary data.","title":"Status Messages"},{"location":"user_guide/preparing_board/","text":"Preparing a Control Board TODO: Flashing firmware Wiring Testing USB","title":"Preparing a Control Board"},{"location":"user_guide/preparing_board/#preparing-a-control-board","text":"TODO: Flashing firmware Wiring Testing USB","title":"Preparing a Control Board"}]}