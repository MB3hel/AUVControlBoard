{"config":{"indexing":"full","lang":["en"],"min_search_length":3,"prebuild_index":false,"separator":"[\\s\\-]+"},"docs":[{"location":"","text":"AUV Control Board Documentation AUV Control Board is a low-cost open-source motion controller for (Autonomous) Underwater Vehicles. It is designed for vehicles with fixed position thrusters and supports motion in 6 degrees of freedom. There are currently two versions of control board. Neither version has more features than the other. Version 2 was developed to be able to use a different chip / board that was easier to get. Version 1 uses an Adafruit ItsyBitsy M4 (Microchip ATSAMD51 chip) Version 2 use a WeAct Studio Black Pill (STMicroelectronics STM32F4) The firmware is capable of running on both versions. License Both the firmware and provided demo and interface scripts are licensed under the GNU General Public License version 3 or later (GPL-3.0-or-later). Note that the firmware includes third party components licensed under their own terms.","title":"Home"},{"location":"#auv-control-board-documentation","text":"AUV Control Board is a low-cost open-source motion controller for (Autonomous) Underwater Vehicles. It is designed for vehicles with fixed position thrusters and supports motion in 6 degrees of freedom. There are currently two versions of control board. Neither version has more features than the other. Version 2 was developed to be able to use a different chip / board that was easier to get. Version 1 uses an Adafruit ItsyBitsy M4 (Microchip ATSAMD51 chip) Version 2 use a WeAct Studio Black Pill (STMicroelectronics STM32F4) The firmware is capable of running on both versions.","title":"AUV Control Board Documentation"},{"location":"#license","text":"Both the firmware and provided demo and interface scripts are licensed under the GNU General Public License version 3 or later (GPL-3.0-or-later). Note that the firmware includes third party components licensed under their own terms.","title":"License"},{"location":"none/","text":"Coming Soon.","title":"None"},{"location":"devs/build/","text":"Build and Flash Firmware Note: Run all commands shown in the firmware folder of the repo. Building Install the Required Tools: CMake (version 3.20.0 or newer) Ninja GNU Arm Toolchain Make sure cmake , ninja , and arm-none-eabi-gcc are in your PATH . Build the firmware using the commands below. Replace [preset] with v1 or v2 (depending on which version you are building firmware for). Replace [config] with debug , release , minsizerel , or relwithdebinfo . cmake --preset=[preset] cmake --build --preset=[preset]-[config] Flashing Note: Control Board v1 Units must update Adafruit's bootloader before first use. This only needs to be done once, but it must be done. Follow Adafruit's instructions here . DO NOT SKIP THIS!!! Version Flash Method Tool Alias Required software v1 sam-ba (via bootloader) bossa BOSSA (specifically bossac / bossa-cli) v1 uf2conv (via bootloader) uf2conv None v2 dfu-util (via bootloader) dfu-util dfu-util v2 STM32CubeProgrammer DFU (via bootloader) stm32-dfu STM32CubeProgrammer Note: required tool ( bossac , dfu-util , STM32_Programmer_CLI ) must be in your PATH . Before flashing, the chip needs to enter its bootloader (unless using a debug probe such as the stlink2 to flash) If a board is already flashed, it can be rebooted into its bootloader using the reboot_bootloader.py script in the firmware directory. Otherwise, use the hardware method described below. v1: Press the reset button twice quickly (double press). v2: Hold the BOOT button. While holding it, press and release the NRST button. Then release the boot button. Note: Sometimes reboot to bootloader mode \"fails\". On v1, this usually means it fails to attach USB (LED remains red not green.) On v2 this usually means it doesn't show up as a USB device. In either case, just try to enter again using the same button combination above. To flash, run the flash.py script. It is a wrapper that will call one of the above tools python3 flash.py [version] [config] -u [tool] [version] is either v1 or v2 [config] is the configuration you want to flash (same as configuration built: Debug , Release , MinSizeRel , or RelWithDebInfo ) [tool] is one of the above upload tool aliases. Flashing Remotely Sometimes, it is useful to flash firmware without connecting directly to the control board. Typically, this is done in-system where the embedded computer using the control board (Jetson, Raspberry Pi, etc) is used to flash the control board without gaining physical access to the control board. Instead an ssh connection to the remote computer is used. There are a few requirements to be able to flash remotely The control board must already be running some version of the firmware. This is necessary to be able to enter bootloader mode without access to the buttons on the board. The remote computer must have a flash tool installed. For v1 this should be bossac and for v2 this should be dfu-util . These are available as packages for most Linux distributions ( bossa-cli and dfu-util respectively for Debian and Ubuntu based systems). You must have ssh (and by extension scp) access to the remote system (typically via ethernet tether) On the build computer (laptop, etc) build the firmware as described above. Then, login to the remote system via ssh and create a directory to hold control board flash stuff (name can be changed as desired) # Run on remote computer (via ssh) cd ~ mkdir cboard-flash Then on the build computer, use scp to copy the flash.py and reboot_bootloader.py scripts to this folder # Run on build laptop scp firmware/flash.py user@remote_ip:cboard-flash/ scp firmware/reboot_bootloader.py user@remote_ip:cboard-flash/ Next copy the build folder. You can just copy the binaries themselves, but the folder hierarchy must be maintained. # Run on remote computer (via ssh) # Delete old build folder first rm -r ~/cboard-flash/build # Run on build laptop scp -r firmware/build user@remote_ip:cboard-flash/ Finally, reboot the control board to bootloader and flash # Run on remote computer (via ssh) ./reboot_bootloader.py [port] ./flash.py [version] [config] -p [port] Note: Sometimes reboot to bootloader mode \"fails\". On v1, this usually means it fails to attach USB (LED remains red not green.) On v2 this usually means it doesn't show up as a USB device. In either case, you will loose USB communication to the board. In this case, a power cycle is required to \"fix\" the board before trying to enter the bootloader again. While inconvenient, it is still usually easier to power cycle the vehicle than to unseal it.","title":"Build and Flash Firmware"},{"location":"devs/build/#build-and-flash-firmware","text":"Note: Run all commands shown in the firmware folder of the repo.","title":"Build and Flash Firmware"},{"location":"devs/build/#building","text":"Install the Required Tools: CMake (version 3.20.0 or newer) Ninja GNU Arm Toolchain Make sure cmake , ninja , and arm-none-eabi-gcc are in your PATH . Build the firmware using the commands below. Replace [preset] with v1 or v2 (depending on which version you are building firmware for). Replace [config] with debug , release , minsizerel , or relwithdebinfo . cmake --preset=[preset] cmake --build --preset=[preset]-[config]","title":"Building"},{"location":"devs/build/#flashing","text":"Note: Control Board v1 Units must update Adafruit's bootloader before first use. This only needs to be done once, but it must be done. Follow Adafruit's instructions here . DO NOT SKIP THIS!!! Version Flash Method Tool Alias Required software v1 sam-ba (via bootloader) bossa BOSSA (specifically bossac / bossa-cli) v1 uf2conv (via bootloader) uf2conv None v2 dfu-util (via bootloader) dfu-util dfu-util v2 STM32CubeProgrammer DFU (via bootloader) stm32-dfu STM32CubeProgrammer Note: required tool ( bossac , dfu-util , STM32_Programmer_CLI ) must be in your PATH . Before flashing, the chip needs to enter its bootloader (unless using a debug probe such as the stlink2 to flash) If a board is already flashed, it can be rebooted into its bootloader using the reboot_bootloader.py script in the firmware directory. Otherwise, use the hardware method described below. v1: Press the reset button twice quickly (double press). v2: Hold the BOOT button. While holding it, press and release the NRST button. Then release the boot button. Note: Sometimes reboot to bootloader mode \"fails\". On v1, this usually means it fails to attach USB (LED remains red not green.) On v2 this usually means it doesn't show up as a USB device. In either case, just try to enter again using the same button combination above. To flash, run the flash.py script. It is a wrapper that will call one of the above tools python3 flash.py [version] [config] -u [tool] [version] is either v1 or v2 [config] is the configuration you want to flash (same as configuration built: Debug , Release , MinSizeRel , or RelWithDebInfo ) [tool] is one of the above upload tool aliases.","title":"Flashing"},{"location":"devs/build/#flashing-remotely","text":"Sometimes, it is useful to flash firmware without connecting directly to the control board. Typically, this is done in-system where the embedded computer using the control board (Jetson, Raspberry Pi, etc) is used to flash the control board without gaining physical access to the control board. Instead an ssh connection to the remote computer is used. There are a few requirements to be able to flash remotely The control board must already be running some version of the firmware. This is necessary to be able to enter bootloader mode without access to the buttons on the board. The remote computer must have a flash tool installed. For v1 this should be bossac and for v2 this should be dfu-util . These are available as packages for most Linux distributions ( bossa-cli and dfu-util respectively for Debian and Ubuntu based systems). You must have ssh (and by extension scp) access to the remote system (typically via ethernet tether) On the build computer (laptop, etc) build the firmware as described above. Then, login to the remote system via ssh and create a directory to hold control board flash stuff (name can be changed as desired) # Run on remote computer (via ssh) cd ~ mkdir cboard-flash Then on the build computer, use scp to copy the flash.py and reboot_bootloader.py scripts to this folder # Run on build laptop scp firmware/flash.py user@remote_ip:cboard-flash/ scp firmware/reboot_bootloader.py user@remote_ip:cboard-flash/ Next copy the build folder. You can just copy the binaries themselves, but the folder hierarchy must be maintained. # Run on remote computer (via ssh) # Delete old build folder first rm -r ~/cboard-flash/build # Run on build laptop scp -r firmware/build user@remote_ip:cboard-flash/ Finally, reboot the control board to bootloader and flash # Run on remote computer (via ssh) ./reboot_bootloader.py [port] ./flash.py [version] [config] -p [port] Note: Sometimes reboot to bootloader mode \"fails\". On v1, this usually means it fails to attach USB (LED remains red not green.) On v2 this usually means it doesn't show up as a USB device. In either case, you will loose USB communication to the board. In this case, a power cycle is required to \"fix\" the board before trying to enter the bootloader again. While inconvenient, it is still usually easier to power cycle the vehicle than to unseal it.","title":"Flashing Remotely"},{"location":"devs/buildsimcb/","text":"Build and Run SimCB Install the Required Tools: CMake (version 3.20.0 or newer) Ninja C Toolchain for your system MSVC on windows Apple Clang on macOS GNU Toolchain (GCC) on Linux Make sure cmake and ninja are in your PATH . Build the firmware using the commands below. Replace [preset] with simcb-win , simcb-macos , or simcb-linux . Replace [config] with debug , release , minsizerel , or relwithdebinfo . cmake --preset=[preset] cmake --build --preset=[preset]-[config] The SimCB binary will exist in build/[preset]/[config]/SimCB[.exe]","title":"Build and Run SimCB"},{"location":"devs/buildsimcb/#build-and-run-simcb","text":"Install the Required Tools: CMake (version 3.20.0 or newer) Ninja C Toolchain for your system MSVC on windows Apple Clang on macOS GNU Toolchain (GCC) on Linux Make sure cmake and ninja are in your PATH . Build the firmware using the commands below. Replace [preset] with simcb-win , simcb-macos , or simcb-linux . Replace [config] with debug , release , minsizerel , or relwithdebinfo . cmake --preset=[preset] cmake --build --preset=[preset]-[config] The SimCB binary will exist in build/[preset]/[config]/SimCB[.exe]","title":"Build and Run SimCB"},{"location":"devs/details/","text":"Implementation Details TODO: EEPROM Emulation SAMD51 (CBv1) Using NVMCTRL SmartEEPROM Must configure size using NVMCTRL user page (requires write of fuses / config bits then device reset; XC32 compiler uses pragma config to configur this. I see no other way with GCC) Note that as such, configuring fuse settings with MCC Standalone generator will do no good (it assumes XC32) Linker script modified to shorten rom to avoid the data for eeprom STM32 (CBv2) Using code from https://github.com/STMicroelectronics/STM32CubeF4/tree/master/Projects/STM32F411RE-Nucleo/Applications/EEPROM/EEPROM_Emulation as st_eeprom.h/c Using sectors 1 and 2 isr_vectors must be in sector 0, most of this sector is wasted Flash used by program starts at sector 3. Leaves 464k flash for use. Note that since flash is split, flashing must occur in two stages (boot and main) using dfu-util TODO: Threading model mutexes, dataflow details TODO: Generator use and import process details TODO: Calibration of BNO055 (described from code perspective - see calibration page for user facing docs) EEPROM calibration status signature for valid check Erase only invalidates signature (potentially fewer writes) If calibration constants are valid, they are applied during bno055 configuration. Applying constants will prevent BNO055 from running calibration routine in bg. Applied calibration is assumed to be good by the sensor (CALIB_STAT has no relevance). Stored calibration commands Erase triggers reset of sensor causing constants to be lost and auto calibration routine to run Store triggers reset of sensor using the newly stored constants (thus no auto calibration runs) Load will send the stuff from eeprom There are separate BNO055 commands to read its calibration status register and the values from its calibration registers (these are only valid if CALIB_STAT is 3 for sensors used and BNO055 is in config mode) What are each of the calibration constants (offsets, radius)","title":"Firmware Details"},{"location":"devs/details/#implementation-details","text":"TODO: EEPROM Emulation SAMD51 (CBv1) Using NVMCTRL SmartEEPROM Must configure size using NVMCTRL user page (requires write of fuses / config bits then device reset; XC32 compiler uses pragma config to configur this. I see no other way with GCC) Note that as such, configuring fuse settings with MCC Standalone generator will do no good (it assumes XC32) Linker script modified to shorten rom to avoid the data for eeprom STM32 (CBv2) Using code from https://github.com/STMicroelectronics/STM32CubeF4/tree/master/Projects/STM32F411RE-Nucleo/Applications/EEPROM/EEPROM_Emulation as st_eeprom.h/c Using sectors 1 and 2 isr_vectors must be in sector 0, most of this sector is wasted Flash used by program starts at sector 3. Leaves 464k flash for use. Note that since flash is split, flashing must occur in two stages (boot and main) using dfu-util TODO: Threading model mutexes, dataflow details TODO: Generator use and import process details TODO: Calibration of BNO055 (described from code perspective - see calibration page for user facing docs) EEPROM calibration status signature for valid check Erase only invalidates signature (potentially fewer writes) If calibration constants are valid, they are applied during bno055 configuration. Applying constants will prevent BNO055 from running calibration routine in bg. Applied calibration is assumed to be good by the sensor (CALIB_STAT has no relevance). Stored calibration commands Erase triggers reset of sensor causing constants to be lost and auto calibration routine to run Store triggers reset of sensor using the newly stored constants (thus no auto calibration runs) Load will send the stuff from eeprom There are separate BNO055 commands to read its calibration status register and the values from its calibration registers (these are only valid if CALIB_STAT is 3 for sensors used and BNO055 is in config mode) What are each of the calibration constants (offsets, radius)","title":"Implementation Details"},{"location":"devs/developing/","text":"Firmware Development VSCode Setup Often, it is useful to have some sort of code editor / IDE setup. The project is already setup to work easily with Visual Studio Code (VSCode), provided a few extensions are installed. After installing VSCode Install the C/C++ and CMake Tools , and Cortex-Debug extensions for working with the firmware ( firmware/ subfolder) Install the Python extension for working with the interface scripts ( iface/ subfolder) To use, just open one of the folders (eg firmware/ or iface/ ) in VSCode. The useful extensions should automatically load when you open the folders (you may have to open a source code file in some cases). For debugging, a launch.json file is included in the firmware/ project (in .vscode subfolder). This defines debug configurations both for firmware running on physical hardware and for the supported SimCB configurations. Note: Launching a debug session from VSCode will not build the firmware. Make sure to build the \"Debug\" configuration before launching! Debugging Firmware Debugging on Physical System This section discusses debugging of the firmware running on actual hardware (Control Board v1 or v2). Debugging firmware running on a microcontroller requires a \"debug probe\". The supported probes for each version of the control board are listed in the table below. ControlBoard Version Debugger / Debug Probe Config Name in tools/debug v1 CMSIS-DAP* cb_v1_via_cmsisdap.cfg v2 ST-LINK v2 cb_v2_via_stlink2.cfg *The PicoProbe firmware can be used to turn a low cost Raspberry Pi Pico board into a CMSIS-DAP compliant debug probe. You must wire the debug probe to the microcontroller on the control board correctly. Both v1 and v2 use a SWD debug interface. Examples of wiring the debug probes to each are shown below. TODO: Wiring diagrams for v1 and v2 Note: NEVER power the system from both the debug probe and USB at the same time. Generally, power the system over USB and do not connect the power (3.3V) from the debug probe. Signals and GND must be connected from the debug probe. Make sure that OpenOCD must be installed and in the PATH . On Linux systems, you will likely also need to install gdb-multiarch and symlink it to arm-none-eabi-gdb . On ubuntu, this is done with the following commands sudo apt install gdb-multiarch sudo ln -s `which gdb-multiarch` /usr/local/bin/arm-none-eabi-gdb Then, use VSCode to run the correct debug session for the hardware version and debug probe you are using. Alternatively, you may use openocd and gdb directly if you are not using vscode. The config files listed in the table above are just OpenOCD configs. Debugging SimCB For windows, you can attach the windows debugger without any issues / modifications. For macos / linux (using FreeRTOS posix port) the debugger must have some additional configuration to avoid impacting signals used by the port to facilitate context switches. LLDB (macOS): process handle SIGUSR1 --notify false --pass true --stop false process handle SIGALRM --notify false --pass true --stop false GDB (Linux): handle SIGUSR1 nostop noignore noprint handle SIGALRM nostop noignore noprint Generator Projects Note: All paths in this section are relative to the firmware/ subdirectory. Each version of ControlBoard has an associated \"Generator\" project. These are projects used with the chip manufacturer's tools to generate startup / configuration / library code for the chip. You will only need to modify the generator projects to alter configuration of the chip / components of included libraries from these tools. The firmware copies code generated from these tools into the thridparty folder, thus you don't need the generators to modify the firmware, unless you are modifying generated components. Running the Generator(s) Control Board v1 Control Board v1 uses an Adafruit ItsyBitsy M4 board (Microchip ATSAMD51G19A chip). The generator used for this project is MCC Standalone . This tool is available for download on Windows, macOS, and Linux. Tested with v5.2.1 of MCC Standalone. Once installed Launch the application Make sure the Harmony Content Path is set in Tools > Options . This should only need to be done once per computer. Recommended path is ~/.mcc/harmony/v3 . On windows, use C:\\Users\\[YOUR_USERNAME]\\.mcc\\harmony\\v3 (replace [YOUR_USERNAME] ). File > Load Configuration Choose generator_projects/ControlBoard_v1/firmware/ControlBoard_v1/ControlBoard_v1.mc3 You will likely be prompted to install MPLAB Harmony content. Install it. Click \"Generate\" in the top left. Control Board v2 Control Board v2 uses a WeAct Studio Black Pill board (STMicro STM32F411CEU chip). The generator used for this project is STM32CubeMX . This tool is available for download on Windows, macOS, and Linux. Tested with v6.6.1 of STM32CubeMX. Once installed Launch the application File > Load Project Choose generator_projects/ControlBoard_v2/ControlBoard_v2.ioc Install any required packs (as prompted) Click \"Generate Code\" in the top right. Importing from Generators After running the generator (as described above) the generated code must be imported to the project. The import process is mostly just copying generated files, however some files are modified slightly. The import process is handled by the import_from_generator.py script. If additional components are added in the generator projects, this script may need to be modified to import additional components. When this script is run, it will prompt a version of control board to import generated code for. This script must be run after each time the generator project is modified and code is re-generated. To run the importer, run python3 import_from_generator.py then choose which project your are importing. Firmware Development using the Simulator The simulator can be very helpful for developing or debugging firmware. The simulator is capable of connecting to a real control board or SimCB binaries. Thus the firmware can be tested in a simulation environment to validate math or behavior of a vehicle. Testing with the simulator can also be done while the control board firmware is running with a debugger attached (true for both a real control board and SimCB). Testing firmware on a physical control board (v1, v2) with the simulator is fairly simple. It is assumed that you will want the debugger running too: Connect the control board to your PC via USB Connect a debug probe to the control board (do NOT connect power) Build and run the firmware under debugger In the simulator, choose the UART port for the control board Interface scripts can be run as usual using launch.py , but add the -s flag so it will connect to the simulator instead of the physical control board. If you want to debug SimCB using the simulated environment TODO: Requires more work on simulator UI! NYI! There are a few things to know about running under simulation (these are true when the firmware is hijacked by simulator) Sensor drivers are disabled while under simulator control. Additionally, the active sensors will always be reported as the \"SIM\" sensors. This is true even if a real sensor is connected to a physical control board under simulation. When controlled by the simulator, the control board will not generate PWM signals on thruster pins. The thruster pins will maintain a pulse corresponding to no motion (or no pulse at all if no thruster pwm parameters have been applied). Developing Python Interface Scripts TODO","title":"Development Workflows"},{"location":"devs/developing/#firmware-development","text":"","title":"Firmware Development"},{"location":"devs/developing/#vscode-setup","text":"Often, it is useful to have some sort of code editor / IDE setup. The project is already setup to work easily with Visual Studio Code (VSCode), provided a few extensions are installed. After installing VSCode Install the C/C++ and CMake Tools , and Cortex-Debug extensions for working with the firmware ( firmware/ subfolder) Install the Python extension for working with the interface scripts ( iface/ subfolder) To use, just open one of the folders (eg firmware/ or iface/ ) in VSCode. The useful extensions should automatically load when you open the folders (you may have to open a source code file in some cases). For debugging, a launch.json file is included in the firmware/ project (in .vscode subfolder). This defines debug configurations both for firmware running on physical hardware and for the supported SimCB configurations. Note: Launching a debug session from VSCode will not build the firmware. Make sure to build the \"Debug\" configuration before launching!","title":"VSCode Setup"},{"location":"devs/developing/#debugging-firmware","text":"","title":"Debugging Firmware"},{"location":"devs/developing/#debugging-on-physical-system","text":"This section discusses debugging of the firmware running on actual hardware (Control Board v1 or v2). Debugging firmware running on a microcontroller requires a \"debug probe\". The supported probes for each version of the control board are listed in the table below. ControlBoard Version Debugger / Debug Probe Config Name in tools/debug v1 CMSIS-DAP* cb_v1_via_cmsisdap.cfg v2 ST-LINK v2 cb_v2_via_stlink2.cfg *The PicoProbe firmware can be used to turn a low cost Raspberry Pi Pico board into a CMSIS-DAP compliant debug probe. You must wire the debug probe to the microcontroller on the control board correctly. Both v1 and v2 use a SWD debug interface. Examples of wiring the debug probes to each are shown below. TODO: Wiring diagrams for v1 and v2 Note: NEVER power the system from both the debug probe and USB at the same time. Generally, power the system over USB and do not connect the power (3.3V) from the debug probe. Signals and GND must be connected from the debug probe. Make sure that OpenOCD must be installed and in the PATH . On Linux systems, you will likely also need to install gdb-multiarch and symlink it to arm-none-eabi-gdb . On ubuntu, this is done with the following commands sudo apt install gdb-multiarch sudo ln -s `which gdb-multiarch` /usr/local/bin/arm-none-eabi-gdb Then, use VSCode to run the correct debug session for the hardware version and debug probe you are using. Alternatively, you may use openocd and gdb directly if you are not using vscode. The config files listed in the table above are just OpenOCD configs.","title":"Debugging on Physical System"},{"location":"devs/developing/#debugging-simcb","text":"For windows, you can attach the windows debugger without any issues / modifications. For macos / linux (using FreeRTOS posix port) the debugger must have some additional configuration to avoid impacting signals used by the port to facilitate context switches. LLDB (macOS): process handle SIGUSR1 --notify false --pass true --stop false process handle SIGALRM --notify false --pass true --stop false GDB (Linux): handle SIGUSR1 nostop noignore noprint handle SIGALRM nostop noignore noprint","title":"Debugging SimCB"},{"location":"devs/developing/#generator-projects","text":"Note: All paths in this section are relative to the firmware/ subdirectory. Each version of ControlBoard has an associated \"Generator\" project. These are projects used with the chip manufacturer's tools to generate startup / configuration / library code for the chip. You will only need to modify the generator projects to alter configuration of the chip / components of included libraries from these tools. The firmware copies code generated from these tools into the thridparty folder, thus you don't need the generators to modify the firmware, unless you are modifying generated components.","title":"Generator Projects"},{"location":"devs/developing/#running-the-generators","text":"","title":"Running the Generator(s)"},{"location":"devs/developing/#control-board-v1","text":"Control Board v1 uses an Adafruit ItsyBitsy M4 board (Microchip ATSAMD51G19A chip). The generator used for this project is MCC Standalone . This tool is available for download on Windows, macOS, and Linux. Tested with v5.2.1 of MCC Standalone. Once installed Launch the application Make sure the Harmony Content Path is set in Tools > Options . This should only need to be done once per computer. Recommended path is ~/.mcc/harmony/v3 . On windows, use C:\\Users\\[YOUR_USERNAME]\\.mcc\\harmony\\v3 (replace [YOUR_USERNAME] ). File > Load Configuration Choose generator_projects/ControlBoard_v1/firmware/ControlBoard_v1/ControlBoard_v1.mc3 You will likely be prompted to install MPLAB Harmony content. Install it. Click \"Generate\" in the top left.","title":"Control Board v1"},{"location":"devs/developing/#control-board-v2","text":"Control Board v2 uses a WeAct Studio Black Pill board (STMicro STM32F411CEU chip). The generator used for this project is STM32CubeMX . This tool is available for download on Windows, macOS, and Linux. Tested with v6.6.1 of STM32CubeMX. Once installed Launch the application File > Load Project Choose generator_projects/ControlBoard_v2/ControlBoard_v2.ioc Install any required packs (as prompted) Click \"Generate Code\" in the top right.","title":"Control Board v2"},{"location":"devs/developing/#importing-from-generators","text":"After running the generator (as described above) the generated code must be imported to the project. The import process is mostly just copying generated files, however some files are modified slightly. The import process is handled by the import_from_generator.py script. If additional components are added in the generator projects, this script may need to be modified to import additional components. When this script is run, it will prompt a version of control board to import generated code for. This script must be run after each time the generator project is modified and code is re-generated. To run the importer, run python3 import_from_generator.py then choose which project your are importing.","title":"Importing from Generators"},{"location":"devs/developing/#firmware-development-using-the-simulator","text":"The simulator can be very helpful for developing or debugging firmware. The simulator is capable of connecting to a real control board or SimCB binaries. Thus the firmware can be tested in a simulation environment to validate math or behavior of a vehicle. Testing with the simulator can also be done while the control board firmware is running with a debugger attached (true for both a real control board and SimCB). Testing firmware on a physical control board (v1, v2) with the simulator is fairly simple. It is assumed that you will want the debugger running too: Connect the control board to your PC via USB Connect a debug probe to the control board (do NOT connect power) Build and run the firmware under debugger In the simulator, choose the UART port for the control board Interface scripts can be run as usual using launch.py , but add the -s flag so it will connect to the simulator instead of the physical control board. If you want to debug SimCB using the simulated environment TODO: Requires more work on simulator UI! NYI! There are a few things to know about running under simulation (these are true when the firmware is hijacked by simulator) Sensor drivers are disabled while under simulator control. Additionally, the active sensors will always be reported as the \"SIM\" sensors. This is true even if a real sensor is connected to a physical control board under simulation. When controlled by the simulator, the control board will not generate PWM signals on thruster pins. The thruster pins will maintain a pulse corresponding to no motion (or no pulse at all if no thruster pwm parameters have been applied).","title":"Firmware Development using the Simulator"},{"location":"devs/developing/#developing-python-interface-scripts","text":"TODO","title":"Developing Python Interface Scripts"},{"location":"devs/math/","text":"Math Coordinate System Definition The control board uses a coordinate system that is somewhat non-standard. The coordinate system is right handed +y is forward, +z is up, +x is right Pitch is about x, roll is about y, yaw is about z While this coordinate system may seem strange to some (especially those who have worked with aircraft), the name of axes doesn't really matter. The definition of pitch, roll, and yaw relative to the front / top of the vehicle remain standard. 6 Degree of Freedom Motion Control Nomenclature, Notation, and Convention Notes Matrices are assumed to be zero indexed (not 1 indexed). This means the first element of a matrix \\(M\\) is \\(m_{00}\\) not \\(m_{11}\\) . This is because the math will be implemented in C (which uses zero indexed arrays). Thruster numbers (1-8) are used by the control board's user facing components. However, this math will use thruster indices (0-7) where index = number - 1 . This is again because arrays in C are zero indexed. Rotations about axes (angular velocities / DoFs) are referred to as \"xrot\" (about x), \"yrot\" (about y), and \"zrot\" (about z). The terms \"pitch\", \"roll\", and \"yaw\" are used to describe the vehicle's orientation in space. These are a set of intrinsic Euler angles (Tait-Bryan angles to be precise) composed in the order yaw then pitch then roll (z-x'-y'' in the control board's coordinate system). Note that while these do follow the standard meanings of pitch, roll, and yaw relative to the vehicle, the axes have non-standard names. Thus, you cannot simply use standard formulas for converting between quaternions and pitch, roll, yaw. Velocities in DoFs are normalized (meaning -1.0 to 1.0). Euler angles are represented as a set of three values \\(\\begin{pmatrix} pitch & roll & yaw\\end{pmatrix}\\) Quaternions are represented either as a combination of a scalar component, \\(s\\) , and a vector component, \\(v\\) as \\(\\{s,v\\}\\) or they may be represented using the names \\(w\\) , \\(x\\) , \\(y\\) , and \\(z\\) . In such a case this is equivelent to \\(\\{w, (x, y, z)\\}\\) . In other words, \\(x\\) , \\(y\\) , and \\(z\\) are the components of the vector \\(v\\) and \\(w=s\\) . The conjugate of a quaternion, \\(q\\) is denoted \\(q^*\\) System Assumptions Vehicle is capable of motion exclusively in each of 6 degrees of freedom (DoFs). These are three translational DoFs, and three rotational DoFs. The vehicle's speed in positive and negative directions are roughly equal for each DoF. Thruster orientations are fixed. Gimbaled thruster vehicles are not supported. At most 8 thrusters (less is fine) System has 3D orientation information System has depth information System does not have translational position information Example Vehicle The examples on this page will use AquaPack robotics's SeaWolf VIII robot . This robot's thruster configuration is as shown below. The arrows indicate the direction the thruster moves water when powered in the positive direction. These arrows are opposite the direction force is excerpted on the vehicle. Note that the diagram above uses thruster numbers, not indices. DoF Matrix The DoF Matrix , \\(D\\) , is constructed based on the vehicle's thruster configuration. Rows of the matrix correspond to thrusters (by index). And columns of the matrix correspond to vehicle-relative DoFs. Thus, this is an 8x6 matrix (8 thrusters, 6 DoFs). Columns correspond to DoFs in the following order (0-5): x, y, z, xrot, yrot, zrot. \\(D = \\left(\\begin{array}{c|c|c|c|c|c} d_0 & d_1 & d_2 & d_3 & d_4 & d_5 \\end{array}\\right) = \\left(\\begin{array}{c|c|c|c|c|c} d_x & d_y & d_z & d_{xr} & d_{yr} & d_{zr} \\end{array}\\right)\\) Each column of the DoF matrix, \\(d_i\\) is a set of thruster speeds that result in motion exclusively in the column's DoF. Additionally, the resultant motion should be the maximum possible speed, and in the positive direction. Each \\(d_i\\) is an 8 element column vector, with elements corresponding to thrusters (by index). All speeds should be normalized (between -1.0 and 1.0) For the example vehicle shown above, the following is the DoF matrix \\(D = \\begin{pmatrix} -1 & -1 & 0 & 0 & 0 & +1 \\\\ +1 & -1 & 0 & 0 & 0 & -1 \\\\ -1 & +1 & 0 & 0 & 0 & -1 \\\\ +1 & +1 & 0 & 0 & 0 & +1 \\\\ 0 & 0 & -1 & -1 & -1 & 0 \\\\ 0 & 0 & -1 & -1 & +1 & 0 \\\\ 0 & 0 & -1 & +1 & -1 & 0 \\\\ 0 & 0 & -1 & +1 & +1 & 0 \\\\ \\end{pmatrix}\\) Consider the first column: \\(d_0 = d_x\\) . This column's thruster speeds should result in the vehicle moving as fast as possible in the +x direction (only). This is achieved by setting T2, T4 (index 1, 3) to the positive direction and T1, T3 (index 0, 2) to the negative direction at full speed (recall that the arrows are opposite the direction the thruster excerpts force on the vehicle). Thus \\(d_x = \\begin{pmatrix}-1 & +1 & -1 & +1 & 0 & 0 & 0 & 0\\end{pmatrix}^T\\) Note that when constructing the DoF matrix for your vehicle, you should assume an ideal system and environment (ignore variation between thrusters, environmental factors that create motion, etc). LOCAL Mode Motion In LOCAL mode, motion is specified as a set of speeds in vehicle-relative DoFs. The user provides the control board with a local target motion vector ( \\(t_l\\) ) where each element corresponds to a DoF. \\(t_l = \\begin{pmatrix} x & y & z & r_x & r_y & r_z \\end{pmatrix}^T\\) \\(x\\) is normalized velocity in +x direction \\(y\\) is normalized velocity in +y direction \\(z\\) is normalized velocity in +y direction \\(r_x\\) is normalized angular velocity about the +x axis direction (xrot) \\(r_y\\) is normalized angular velocity about the +y axis (yrot) \\(r_z\\) is normalized angular velocity about the +z axis (zrot) By multiplying this target motion by the DoF matrix, \\(D\\) , a speed vector \\(s\\) is obtained where each element of \\(s\\) corresponds to a specific thruster (by index). \\(s = D t_l\\) Consider the example where \\(t_l = \\begin{pmatrix}0 & 1 & 0 & 0 & 0 & 0\\end{pmatrix}^T\\) . This should cause the vehicle to move at full possible speed forward (relative to the vehicle's orientation). \\(s = D t_l = \\begin{pmatrix} -1 & -1 & 0 & 0 & 0 & +1 \\\\ +1 & -1 & 0 & 0 & 0 & -1 \\\\ -1 & +1 & 0 & 0 & 0 & -1 \\\\ +1 & +1 & 0 & 0 & 0 & +1 \\\\ 0 & 0 & -1 & -1 & -1 & 0 \\\\ 0 & 0 & -1 & -1 & +1 & 0 \\\\ 0 & 0 & -1 & +1 & -1 & 0 \\\\ 0 & 0 & -1 & +1 & +1 & 0 \\\\ \\end{pmatrix} \\begin{pmatrix}0 \\\\ 1 \\\\ 0 \\\\ 0 \\\\ 0 \\\\ 0\\end{pmatrix} = \\begin{pmatrix}-1 \\\\ -1 \\\\ +1 \\\\ +1 \\\\ 0 \\\\ 0 \\\\ 0 \\\\ 0\\end{pmatrix}\\) In the above example, it is trivial to see that this is the desired motion. However for a more complex example, a problem appears. Consider \\(t_l = \\begin{pmatrix}0 & 1 & 0 & 0 & 0 & 1\\end{pmatrix}^T\\) . This describes the vehicle both moving forward and about the z-axis at full possible speed. \\(s = D t_l = \\begin{pmatrix} -1 & -1 & 0 & 0 & 0 & +1 \\\\ +1 & -1 & 0 & 0 & 0 & -1 \\\\ -1 & +1 & 0 & 0 & 0 & -1 \\\\ +1 & +1 & 0 & 0 & 0 & +1 \\\\ 0 & 0 & -1 & -1 & -1 & 0 \\\\ 0 & 0 & -1 & -1 & +1 & 0 \\\\ 0 & 0 & -1 & +1 & -1 & 0 \\\\ 0 & 0 & -1 & +1 & +1 & 0 \\\\ \\end{pmatrix} \\begin{pmatrix}0 \\\\ 1 \\\\ 0 \\\\ 0 \\\\ 0 \\\\ 1\\end{pmatrix} = \\begin{pmatrix}0 \\\\ -2 \\\\ 0 \\\\ +2 \\\\ 0 \\\\ 0 \\\\ 0 \\\\ 0\\end{pmatrix}\\) Notice that the resultant speed vector has motors moving in excess of 100% speed (elements with magnitude greater than 1.0). This is not possible. The simple solution would seem to be dividing all elements of the vector by the one with the largest magnitude. This results in a scaled speed vector \\(\\hat{s}\\) \\(\\hat{s} = s \\div \\text{absmax}(s)\\) However, this method will not work well in all cases. Consider \\(t_l = \\begin{pmatrix}0 & 1 & 1 & 1 & 1 & 1\\end{pmatrix}^T\\) . \\(s = D t_l = \\begin{pmatrix} -1 & -1 & 0 & 0 & 0 & +1 \\\\ +1 & -1 & 0 & 0 & 0 & -1 \\\\ -1 & +1 & 0 & 0 & 0 & -1 \\\\ +1 & +1 & 0 & 0 & 0 & +1 \\\\ 0 & 0 & -1 & -1 & -1 & 0 \\\\ 0 & 0 & -1 & -1 & +1 & 0 \\\\ 0 & 0 & -1 & +1 & -1 & 0 \\\\ 0 & 0 & -1 & +1 & +1 & 0 \\\\ \\end{pmatrix} \\begin{pmatrix}0 \\\\ 1 \\\\ 1 \\\\ 1 \\\\ 1 \\\\ 1\\end{pmatrix} = \\begin{pmatrix}0 \\\\ -2 \\\\ 0 \\\\ +2 \\\\ -3 \\\\ -1 \\\\ -1 \\\\ +1\\end{pmatrix}\\) and \\(\\hat{s} = s \\div \\text{absmax}(s) = s \\div 3 = \\begin{pmatrix}0 \\\\ -0.67 \\\\ 0 \\\\ +0.67 \\\\ -1 \\\\ -0.33 \\\\ -0.33 \\\\ +0.33\\end{pmatrix}\\) While this has resulted in an possible set of thruster speeds, these are not optimal. Look at the example vehicle diagram. Notice that thrusters 1-4 and 5-8 control different motions. In the previous example, thrusters 1-4 were slowed down more than necessary, because thruster 5 was too large of a value. This is not ideal as the vehicle's maximum speed becomes artificially limited. Instead, the following \\(\\hat{s}\\) is ideal. This is scaling down the thrusters within each group (1-4 and 5-8) separately. \\(\\hat{s} = \\begin{pmatrix}0 \\\\ -1 \\\\ 0 \\\\ +1 \\\\ -1 \\\\ -0.33 \\\\ -0.33 \\\\ +0.33\\end{pmatrix}\\) Groupings of thrusters on the example vehicle are easy to observe, however this is not always true. Thus, achieving optimal scaling for any system (any DoF matrix) requires a more sophisticated method to determine groupings and scale speeds. Thruster groupings are determined by \"overlap\" between thrusters. Two thrusters, \\(i\\) and \\(j\\) are said to overlap if they have a non-zero entry in the same column of the DoF matrix ( \\(D\\) ) for at least one column. This is easier to calculate using a contribution matrix , \\(C\\) , defined as \\(D \\neq 0\\) . This results in a binary form of the DoF matrix. For the above example \\(C = \\left[\\begin{pmatrix} -1 & -1 & 0 & 0 & 0 & +1 \\\\ +1 & -1 & 0 & 0 & 0 & -1 \\\\ -1 & +1 & 0 & 0 & 0 & -1 \\\\ +1 & +1 & 0 & 0 & 0 & +1 \\\\ 0 & 0 & -1 & -1 & -1 & 0 \\\\ 0 & 0 & -1 & -1 & +1 & 0 \\\\ 0 & 0 & -1 & +1 & -1 & 0 \\\\ 0 & 0 & -1 & +1 & +1 & 0 \\\\ \\end{pmatrix} \\neq 0 \\right] = \\begin{pmatrix} 1 & 1 & 0 & 0 & 0 & 1 \\\\ 1 & 1 & 0 & 0 & 0 & 1 \\\\ 1 & 1 & 0 & 0 & 0 & 1 \\\\ 1 & 1 & 0 & 0 & 0 & 1 \\\\ 0 & 0 & 1 & 1 & 1 & 0 \\\\ 0 & 0 & 1 & 1 & 1 & 0 \\\\ 0 & 0 & 1 & 1 & 1 & 0 \\\\ 0 & 0 & 1 & 1 & 1 & 0 \\\\ \\end{pmatrix}\\) Then for each thruster \\(i\\) an overlap vector \\(o_i\\) can be constructed as follows \\(o_i = C (c^i)^T\\) where \\(c^i\\) is the \\(i\\) th row of \\(C\\) . Thus, \\(o_i\\) is an 8 element vector where each element corresponds to a thruster (by index). Element \\(j\\) of \\(o_i\\) can either be \\(1\\) or a \\(0\\) . A \\(1\\) indicates that thrusters \\(i\\) and \\(j\\) overlap. For example, \\(o_0 = C (c^0)^T = \\begin{pmatrix} 1 & 1 & 1 & 1 & 0 & 0 & 0 & 0 \\end{pmatrix}^T\\) This shows that thruster index 0 (T1) overlaps with indices 0, 1, 2, and 3 (T1, T2, T3, T4). By calculating and storing these overlap vectors for each thruster ( \\(\\left\\{o_i\\right\\}_{i=0}^7\\) ), this effectively forms a lookup table to determine thruster overlap. While this is not the most memory efficient option, it reduces computation time, which is important since this will run very frequently on a microcontroller. Using overlap vectors, the following algorithm can be used to scale motor speeds: Find the thruster ( i ) with the largest magnitude speed Iterate over thruster i 's overlap vector For any thruster, j , with which thruster i overlaps, divide thruster j 's speed by the magnitude of thruster i 's speed Repeat until the largest magnitude does not exceed 1.0 while true // m is value, i is index m, i = max(abs(speed_vector)) if m <= 1.0 // Done scaling break endif // Iterate over all thrusters (0-7 inclusive) for j=0...7 if overlap_vector[i][j] == 1 // i and j overlap. Divide j's speed by m. speed_vector[j] /= m endif endfor endwhile This algorithm results in optimal speed scaling by only reducing the speed of thrusters that share DoF contributions. GLOBAL Mode Motion GLOBAL mode is very similar to LOCAL mode, however, motion is described partially relative to the world instead of the robot. Specifically, motion of the vehicle is compensated for vehicle pitch and roll (but not yaw). This results in a coordinate system defined by the axes gx , gy , and gz . Note that the world coordinate system is defined as wx , wy , wz . Notably, if the vehicle is pitched 180 degrees, the gx-gy plane becomes aligned to the back of the vehicle ensuring consistent motion. This is shown in the animation below. In GLOBAL mode, the user provides the control board with a global target motion vector , \\(t_g\\) with 6 elements. This target motion vector is a concatenation of two 3 dimensional vectors. The first, a set of translations along gx , gy , and gz . Second a set of rotations to affect vehicle pitch, roll, and yaw. These are referred to by the following names x : Speed in gx direction (translation) y : Speed in gy direction (translation) z : Speed in gz direction (translation) p : Speed at which the vehicle's pitch should increase (negative for decrease pitch). Aka \"pitch_spd\" r : Speed at which the vehicle's roll should increase (negative for decrease pitch). Aka \"roll_spd\" h : Speed at which the vehicle's yaw should increase (negative for decrease pitch). Aka \"yaw_spd\" \\(t_g = \\begin{pmatrix} x & y & z & p & r & h \\end{pmatrix}\\) It is necessary to transform each DoF's motion into motions in the vehicle's DoFs. These speeds can then be passed to LOCAL mode. WARNING: GLOBAL mode is impacted by gimbal lock issues with euler angles. This occurs when the vehicle's pitch is +/- 90 degrees. In this scenario the meaning of \"increase / decrease pitch\" is ambiguous. The vehicle will take the zero-roll route in this scenario (an arbitrary choice based on how euler angle conversion is implemented in the firmware). Thus, GLOBAL mode may produce undesirable motion if the roll is non-zero and you pitch through +/- 90. A potential solution for this could be some form of motion hysteresis to handle moving through gimbal lock orientations, however this is not implemented as of now. Translation DoFs The translation DoFs are easily transformed using gravity vectors. By applying a quaternion based rotation matrix to the base gravity vector, \\(g_b = \\begin{pmatrix}0 & 0 & -1\\end{pmatrix}\\) , the following solution is determined for the current gravity vector, \\(g_c\\) given the vehicle's orientation quaternion, \\(q\\) . \\(\\begin{pmatrix} 2*(q.x*q.z+q.w*q.y) \\\\ 2*(q.w*q.x-q.y*q.z) \\\\ -(q.w)^2+(q.x)^2+(q.y)^2-(q.z)^2\\end{pmatrix}^T\\) The minimal rotation from \\(g_b\\) to \\(g_c\\) is then calculated. Let this rotation be called \\(q_{rot}\\) . This rotation will generally include no yaw component, unless the vehicle is upside down and facing backwards (eg pitch of 180 degrees) in which case it will contain a yaw component of 180 degrees. This is desirable as it ensures a continuous definition of what gy is even while the vehicle is flipping via pitch. This quaternion can then be applied to speeds in the gx , gy , gz basis ( x , y , and z here) to rotate them onto the vehicle basis. Thus, this \"converts\" translation speeds from GLOBAL to LOCAL mode DoFs. However, it is not ideal to transform the translation vector all at once. It is best to do it in three stages to allow proper upscaling as needed (explained below). Thus for each global mode translation vector \\(\\begin{pmatrix} x & 0 & 0 \\end{pmatrix}\\) , \\(\\begin{pmatrix} 0 & y & 0 \\end{pmatrix}\\) , and \\(\\begin{pmatrix} 0 & 0 & z \\end{pmatrix}\\) rotate it by \\(q_{rot}\\) to obtain \\(t_x\\) , \\(t_y\\) , and \\(t_z\\) respectively (note that \\(\\left\\{s, v\\right\\}\\) is a quaternion with scalar s and vector v). \\(\\left\\{0, t_x\\right\\} = q_{rot} \\left\\{0, \\begin{pmatrix} x & 0 & 0 \\end{pmatrix} \\right\\} q_{rot}^*\\) \\(\\left\\{0, t_y\\right\\} = q_{rot} \\left\\{0, \\begin{pmatrix} 0 & y & 0 \\end{pmatrix} \\right\\} q_{rot}^*\\) \\(\\left\\{0, t_z\\right\\} = q_{rot} \\left\\{0, \\begin{pmatrix} 0 & 0 & z \\end{pmatrix} \\right\\} q_{rot}^*\\) Each of \\(t_x\\) , \\(t_y\\) , and \\(t_z\\) are speeds in LOCAL mode DoFs, however they may be slower than desired. Consider a speed of 1.0 along gy . If the vehicle were rotated 45 degrees (pitch) the resultant \\(t_y\\) would be \\(t_y = \\begin{pmatrix} 0.0 & 0.7071 & 0.7071 \\end{pmatrix}\\) . This is not as fast as possible in the correct direction. Instead \\(t_y\\) should be \\(t_y = \\begin{pmatrix} 0.0 & 1.0 & 1.0 \\end{pmatrix}\\) . In other words, the largest element of \\(t_y\\) should be the speed along gy . Thus, each of \\(t_x\\) , \\(t_y\\) , \\(t_z\\) needs to be upscaled (note that it will never need to be downscaled; it only needs to be upscaled because one DoF may now be spread between multiple). let \\(m\\) be the magnitude of the element of \\(t_x\\) with the largest magnitude Normalize \\(t_x\\) so that largest element is 1.0: \\(t_x = t_x / m\\) Scale normalized \\(t_x\\) by speed \\(x\\) (gx speed): \\(t_x = t_x * x\\) Repeat this for \\(t_y\\) and \\(t_z\\) using \\(y\\) and \\(z\\) speeds respectively. Once all three \\(t\\) vectors are scaled, they can be combined to create the net LOCAL mode translation vector, \\(l\\) \\(l = t_x + t_y + t_z\\) There are two potential issues with \\(l\\) \\(l\\) is a set of proportionally related speeds to result in the desired motion. However, the vehicle may not be capable of the same speeds in each of it's DoFs. Thus, the ratios between \\(l\\) 's elements may be incorrect. \\(l\\) is a sum of three vectors (each with elements no larger than a magnitude of 1), thus it may have elements with a magnitude greater than 1. Issue 1 should be handled first as correcting it may \"fix\" issue 2. Handling issue 2 first could result in downscaling speeds more than necessary. Handling issue 1 requires the user to provide a little more information about the vehicle: relative speeds in each DoF. These can be used to calculate downscaling factors to slow down the faster directions (note: speeding up the slower directions could result in impossible speeds, but would be handled by solving issue 2; regardless it is less ideal). These downscaling factors are calculated from \"RELDOF\" information provided by the user (see messages page of user guide). This information is a set of constants, which will be referred to the as the scale factors as \\(m_x\\) , \\(m_y\\) , \\(m_z\\) , \\(m_{rx}\\) , \\(m_{ry}\\) , and \\(m_{rz}\\) for the x, y, z, xrot, yrot, and zrot DoFs respectively (note that these are vehicle DoFs). These scale factors makeup two groups: translational ( \\(m_x\\) , \\(m_y\\) , and \\(m_z\\) ) and rotational ( \\(m_{rx}\\) , \\(m_{ry}\\) , and \\(m_{rz}\\) ). Within each group, the fastest DoF's scale factor is set to 1. The other scale factors are a percentage of the fastest DoF in the group. For example, if the vehicle can move at 2m/s along z, 1m/s along y, and 0.5m/s along x then \\(m_x = 0.25\\) , \\(m_y = 0.5\\) , and \\(m_z = 1.0\\) . Given these scale factors, the simplest option would be to let \\(l = \\begin{pmatrix}l.x * m_x & l.y * m_y & l.z * m_z\\end{pmatrix}\\) . However, this may downscale more than necessary. Consider a scenario where the speed vector \\(l\\) has a \\(0\\) in the position of the slowest DoF of the vehicle (eg if the vehicle is slowest in the x direction, the \\(l\\) vector would have a zero in the x position). In this case, since the slowest direction is unused, we are downscaling too much. Thus, the following algorithm is used to select the ideal downscaling factors by \"ignoring\" the downscaling required for unused DoFs (DoFs with a speed of 0). // Zero downscale factors for unused DoFs if abs(l.x) == 0 m_x = 0 endif if abs(l.y) == 0 m_y = 0 endif if abs(l.z) == 0 m_z = 0 endif // Rebalance scale factors so largest remaining is 1.0 m_max = max(m_x, max(m_y, m_z)); m_x = m_x / m_max; m_y = m_y / m_max; m_z = m_z / m_max; \\(l\\) is then downscaled as \\(l = \\begin{pmatrix}l.x * m_x & l.y * m_y & l.z * m_z\\end{pmatrix}\\) using the scale factors calculated using the above algorithm. Finally, issue 2 must be handled if any element of \\(l\\) still has a magnitude greater than 1.0. Thus, Let \\(m\\) be the magnitude of the element of \\(l\\) with the largest magnitude If \\(m\\) is less than or equal to 1, do not change $l If \\(m\\) is greater than 1 \\(l = l / m\\) This resultant \\(l\\) is a set of speeds that can be passed to LOCAL mode as it's x , y , and z speeds. Rotation DoFs: Converting the GLOBAL mode rotations (increase/decrease pitch, roll, yaw) to motions about DoFs is a little harder. It requires decomposing the quaternion into euler angles, then calculating three quaternions describing one euler rotation each. In other words, given the vehicle's current rotation \\(q\\) we need to find \\(q_{pitch}\\) , \\(q_{roll}\\) and \\(q_{yaw}\\) such that (based on the euler angle convention used by the control board) \\(q = q_{yaw} q_{pitch} q_{roll}\\) Note: recall that when composing quaternions to be applied to a body, left-multiplied quaternions are applied in the extrinsic coordinate system (world-basis) whereas right-multiplied quaternions are applied in the intrinsic coordinate system (rotating body's basis). Thus, yaw is about the world-z axis (z), then pitch is about the vehicle's x-axis after yawing (x') and roll is about the vehicle's y-axis after both yawing then pitching (y''). This is consistent with the definitions of the coordinate system and pitch, roll, yaw for the control board. Decomposing the quaternion can be done by converting \\(q\\) to a set of euler angles \\(e = \\begin{pmatrix}pitch & roll & yaw\\end{pmatrix}\\) then constructing the following and converting each to a quaternion \\(e_{pitch} = \\begin{pmatrix}pitch & 0 & 0\\end{pmatrix} \\rightarrow q_{pitch}\\) \\(e_{roll} = \\begin{pmatrix}0 & roll & 0\\end{pmatrix} \\rightarrow q_{roll}\\) \\(e_{yaw} = \\begin{pmatrix}0 & 0 & yaw\\end{pmatrix} \\rightarrow q_{yaw}\\) However, the euler angles obtained from \\(q\\) may not be correct for this use case. An equivalent angle go \\(e\\) (although improper) is \\(e_{alt} = \\begin{pmatrix} \\pi - pitch & roll - \\pi & yaw - \\pi \\end{pmatrix}\\) . We need to compensate for first roll then pitch. Thus, we need the euler angle with minimal roll component. This will be referred to here as \\(e_b\\) , equal to either \\(e\\) or \\(_{alt}\\) , whichever has the smaller magnitude roll component. Then, given \\(s\\) vectors describing motion to change the vehicle's pitch, roll, or yaw \\(s_{pitch} = \\begin{pmatrix}p & 0 & 0\\end{pmatrix}\\) \\(s_{roll} = \\begin{pmatrix}0 & r & 0\\end{pmatrix}\\) \\(s_{yaw} = \\begin{pmatrix}0 & 0 & h\\end{pmatrix}\\) We need to transform these onto the robot's axes as \\(w\\) vectors. For roll this is trivial as roll is about the vehicle's y axis. For pitch, this requires undoing roll first (rotate by \\(q_{roll}^*\\) ) and for yaw this requires undoing roll then pitch. Thus \\(w_{roll} = s_{roll}\\) \\(\\left\\{0, w_{pitch}\\right\\} = q_{roll}^* \\left\\{0, s_{pitch}\\right\\} q_{roll}\\) \\(\\left\\{0, w_{yaw}\\right\\} = q_{pitch}^* q_{roll}^* \\left\\{0, s_{yaw}\\right\\} q_{roll} q_{pitch}\\) These vectors are angular speeds about the vehicle's x, y, and z axes. Thus, just as for translations Upscale each \\(w\\) vector using p , r , and h speeds (can skip for roll as this vector is never rotated) Sum the three \\(w\\) vectors into a net \\(w\\) vector Adjust \\(w\\) for relative DoF speeds (using \\(m_{rx}\\) , \\(m_{ry}\\) , \\(m_{rz}\\) ) Downscale \\(w\\) if needed so all elements are less than 1 Then \\(w\\) is the xrot, yrot, and zrot parts of the LOCAL mode target. Orientation Hold (OHOLD) Mode Motion Orientation hold mode uses closed-loop control for vehicle orientation in 3D space. This is achieved using three PID controllers xrot PID: Controls rotation about vehicle x-axis yrot PID: Controls rotation about vehicle y-axis zrot PID: Controls rotation about vehicle z-axis The inputs to OHOLD mode are as follows x : Translation along gx-axis (same as in GLOBAL mode) y : Translation along gy-axis (same as in GLOBAL mode) z : Translation along gz-axis (same as in GLOBAL mode) e_t : Target orientation as euler angles Optionally, a yaw speed ( h ) can be provided. In this case, PIDs will not adjust the vehicle's yaw (heading). Instead the h value works similar to GLOBAL mode (it is a rate of change of vehicle yaw). This effectively abstracts a 2D plane in which the vehicle operates. This is the same gx-gy plane described in the GLOBAL mode section. There are two variants of OHOLD mode Variant 1 (OHOLD1): Speed for yaw ( h ) is used instead of PID control Variant 2 (OHOLD2): PID is used for yaw (yaw speed h is ignored) Variant 2 is mathematically then simpler variant. Variant 1 adds some additional complexity for orientation control. Translation DoFs The user provided x , y , and z translation speeds are handled the same way by OHOLD mode as they are in GLOBAL mode to obtain the final LOCAL mode translation vector \\(l\\) . OHOLD2 Orientation Control While translation for OHOLD is nearly identical to GLOBAL mode, rotation DoFs are very different. Orientation is controlled with a set of 3 PID controllers that work in LOCAL DoFs. Thus it is necessary to determine the rotations necessary about the vehicle's axes to achieve the desired orientation. We are given a target orientation as euler angles, \\(e_t\\) . This can be converted to a target orientation quaternion, \\(q_t\\) using the formulas derived in later sections. Note: For OHOLD1 obtaining \\(q_t\\) is more complex. See the OHOLD1 section for details. However, what is done with \\(q_t\\) from here on, is the same in OHOLD1 as it is in OHOLD2. The vehicle's current orientation (as a quaternion) is also available from the IMU as \\(q_c\\) . We need to calculate a quaternion \\(q_d\\) that represents the minimal rotation from \\(q_c\\) to \\(q_t\\) . However, importantly we want \\(q_d\\) to be a rotation in the vehicle's basis. Recall that right multiplication of quaternions are applied in the vehicle's basis. Thus, to describe the target orientation as the current orientation plus a rotation in the vehicle's basis \\(q_t = q_c q_d\\) Therefore \\(q_d = q_c^* q_t\\) However, this angle may not be minimal. Recall that \\(q\\) and \\(-q\\) represent the same orientation. Thus another solution to this problem would be \\(q_d = (-q_c)^* q_t\\) The minimal rotation is the one where \\(q_c\\) and \\(q_t\\) are on the same half of the unit quaternion hypersphere (meaning their dot product is not negative). Thus If \\(q_c \\cdot q_t < 0\\) then \\(q_d = (-q_c)^* q_t\\) Otherwise \\(q_d = q_c^* q_t\\) Then convert \\(q_d\\) to axis-angle representation. The following algorithm is used to do so for numeric stability reasons (the common formulas using asin are not numerically stable) let \\(q_d = \\left\\{s, v\\right\\}\\) \\(\\theta = 2 atan2(|v|, s)\\) \\(n = v / |v|\\) if \\(|v| > 0\\) else \\(n = v = (0, 0, 0)\\) This axis ( \\(n\\) ) will be a unit vector. Thus it represents proportions of the rotation about each of the vehicle's axes (this is about vehicle's axes because \\(q_d\\) is in the vehicle basis). The angle ( \\(\\theta\\) ) is the magnitude of the rotation that must be taken. Thus, the product of \\(n\\) and \\(\\theta\\) is proportional to the error in angle about each of the vehicle's axes. \\(e = \\theta n\\) This error vector, \\(e\\) , contains the errors to be provided to each orientation PID (xrot, yrot, zrot). The output of these PIDs are angular velocity percentages (-1.0 to 1.0) about each of the vehicle's axes ( \\(w_i\\) denotes the output of the \\(i\\) rot PID) \\(w = \\begin{pmatrix} w_x & w_y & w_z \\end{pmatrix}\\) Note: for OHOLD 1 there is an extra step here to calculate the correct w (see section below). Finally, it is necessary to downscale the \\(w\\) vectors just as in GLOBAL mode First downscale using \\(m_{rx}\\) , \\(m_{ry}\\) and \\(m_{rz}\\) using the algorithm described in the GLOBAL mode section Then downscale the vector so that all elements are less than 1. While this is never needed for OHOLD2, it is needed for OHOLD1 and it is simpler branching logic (code implementation) to just always check if downscaling is needed. This \\(w\\) can then be passed to LOCAL mode along with the LOCAL translation vector \\(l\\) obtained earlier. OHOLD1 Orientation Control OHOLD1 uses much of the same process to control the vehicle's orientation as OHOLD2, however it is necessary to decouple yaw from pitch and roll. In other words, we want to construct a target quaternion using the user provided pitch and roll, but matching the vehicle's current yaw. The most intuitive option would be to decompose \\(q_c\\) into euler angles and obtain the yaw from those. However, this does not account for the fact that the yaw can be altered by pitch or roll. For example, (p=115, r=0, h=90) would be decomposed as (p=65, r=180, h=-90). Here the heading is 180 degrees off. This would be a significant issue. Thus instead, the target quaternion can be decomposed using the swing-twist decomposition of quaternion rotations. We twist about the world z axis (since this is the axis the vehicle initially yawed about). The vehicle's yaw can be calculated from this twist quaternion (using euler conversion formula). The target quaternion is constructed from the target pitch and roll provided by the user and the yaw provided by the twist quaternion as described above. This target quaternion is \\(q_t\\) and is used the same way described for OHOLD2. After calculating \\(w\\) as described for OHOLD2, there is one extra step before handling DoF scaling. The yaw speed ( h ) provided by the user must be transformed to the vehicle's axes and added to the \\(w\\) from the PIDs. This can be done similar to GLOBAL mode \\(\\left\\{0, w_{yaw}\\right\\} = q_{rot} \\left\\{0, \\begin{pmatrix}0 & 0 & h\\end{pmatrix}\\right\\} q_{rot}^*\\) \\(w_{yaw}\\) will then be upscaled just as in GLOBAL mode. Then \\(w = w + w_{yaw}\\) . This is then downscaled as described for OHOLD2. Stability Assist (SASSIST) Mode Stability assist mode (SASSIST) is simply OHOLD mode, with the addition of closed-loop control for vehicle depth. Thus, instead of providing a z speed (for motion along the gz-axis), a PID controller is used to achieve the target depth. Inputs to this mode are the same as OHOLD mode, however instead of z , d_t is provided. d_t : Target depth (meters; negative for below the surface) The PID used to maintain vehicle depth is referred to as the Depth PID. This PID uses the current vehicle depth (provided by a depth sensor) to calculate a z speed in the gz-axis, then provides it as an input to OHOLD mode. All other inputs from SASSIST are passed through to OHOLD mode as provided. Thus, there are two variants of SASSIST mode (variant 1 and variant 2) built ontop of the corresponding variants of OHOLD mode. Accumulated Euler Angles WARNING: Make sure you understand what these are and are not before using them. These are not normal euler angles. They are intended to allow high level software using the control board to a measurement of orientation about an individual axis that accumulates similar to a gyroscope. Generally, use of these is discouraged. They are provided as a \"compatibility bridge\" for code developed for a gyroscope system. WARNING: Accumulated euler angles are not the current orientation of the vehicle as an euler angle! The euler and quaternion values provided by the IMU are not directly useful for tracking multiple rotations of the vehicle. Unlike simply integrating gyroscope data, euler angles (pitch, roll, yaw) and quaternions do not track the number of times the vehicle has rotated about a particular axis. They only track the vehicle's orientation in space. While integrating raw gyro data would provide an accumulating measurement, such a solution would be rotations about the robot's axes. Generally, it is more useful to track the number of times the vehicle has \"pitched\", \"rolled\" or \"yawed\". Note that an accumulated gyro z angle of 500 does not necessarily mean the robot has yawed 500 degrees; the robot could have been oriented at a pitch of 90. Instead, we want to measure how many degrees the vehicle has rotated through. This can be done by tracking changes between subsequent quaternions from the IMU. The idea is to compare each quaternion read from the IMU with the previous quaternion received from the IMU (note that quaternions of all zeros are ignored to avoid issues with invalid IMU data samples after first configuring the sensor). For each quaternion read from the IMU: Calculate the shortest set of rotations from the previous to the current quaternion Convert the shortest angle to euler angles Add the pitch, roll, and yaw from the shortest euler angles to accumulated pitch, roll, and yaw variables Note that if the IMU axis config changes, the accumulated data should be zeroed and the previously read quaternion discarded. This makes the assumption that the smallest rotation between two quaternions is the most probable path the robot took to change its orientation. This is an approximation, however it is a fairly good one as long as sample rate of data is sufficiently high. The specifics of the path are lost, however, if the sample rate is high enough, the length of the path is sufficiently small that and this is a good approximation. The second issue with this approximation has to do with rotations exceeding 180 degrees. The method for determining shortest path between two quaternions will be incorrect if the vehicle rotates more than 180 degrees in any axis (because the shortest path would have involved rotating the other direction). To guarantee rotations between two samples never exceed 180 degrees, the max measured rotation rate of the IMU is considered. For the BNO055 this is 2000 degrees per second. Thus, with a sample period of \\(l\\) milliseconds, the largest angle change between samples is \\(\\frac{2000 \\textrm{ deg}}{1 \\textrm{ sec}} \\cdot \\frac{1 \\textrm{ sec}}{1000 \\textrm{ ms}} \\cdot \\frac{l \\textrm{ ms}}{1 \\textrm{ sample}} = 2l \\textrm{ deg / sample}\\) To ensure that changes of more than 180 degrees do not occur, the following must be satisfied \\(2l < 180 \\rightarrow l < 90 \\textrm{ milliseconds}\\) However, it is possible for some samples from the IMU to be delayed (ie I2C bus busy with another sensor) or lost (I2C failure). Thus, it is necessary to choose a value for \\(l\\) that allows for at least one sample to be lost. When a sample is lost, this doubles the effective time between samples. Thus, it is necessary to half \\(l\\) \\(l < 45 \\textrm{ milliseconds}\\) By further reducing \\(l\\) it is possible to allow for larger delays or more lost samples. The current firmware samples IMU data every 15ms (the max rate supported by the BNO055 in fusion mode is 100Hz = 10ms period). Using \\(l=15 \\textrm{ ms}\\) it is possible for 5 consecutive samples to be lost while still guaranteeing that no more than 90ms passes between valid samples (thus still ensuring no more than 180 degree change between samples). Other Derivations Euler to Quaternion Conversion The euler angle convention used for the control board is an intrinsic set z-x'-y'' (rotate about z, then about new x, then about new y to compose an angle). Using the definitions of front/right/top for this coordinate system, this means that roll is about y, pitch is about x, and yaw is about z. A rotation quaternion, \\(Q\\) , can be composed using three rotations, each being one of the rotations used to construct the euler angle representation (in order). \\(Q = Q_z Q_x Q_y\\) Quaternion multiplication is associative. Recall that right-multiplied quaternions are applied in the vehicle frame during composition. Thus, when viewed left to right: First, apply \\(Q_z\\) in vehicle frame (also equal to world frame since this is the first rotation) Then, apply \\(Q_x\\) in the vehicle frame Finally, apply \\(Q_y\\) in the vehicle frame However, recall that left-multiplied quaternions are applied in the world frame during composition. Thus, when viewed right to left First, apply \\(Q_y\\) in the world frame Then, apply \\(Q_x\\) in the world frame Finally, apply \\(Q_z\\) in the world frame In other words, the following are equivalent Yaw about z , then pitch about x' , then roll about y'' Roll about y , then pitch about x , the yaw about z These use the same pitch, roll, and yaw angles , but the latter applies them about world axes , which have known and trivial direction vectors. Thus, each of pitch, roll, and yaw are a rotation about a known axis (x, y, or z respectively). Converting these from axis-angle from, the quaternions are represented as follows \\(Q_y = \\left\\{ cos(\\frac{roll}{2}), sin(\\frac{roll}{2}) \\begin{pmatrix} 0 \\\\ 1 \\\\ 0 \\end{pmatrix} \\right\\}\\) \\(Q_x = \\left\\{ cos(\\frac{pitch}{2}), sin(\\frac{pitch}{2}) \\begin{pmatrix} 1 \\\\ 0 \\\\ 0 \\end{pmatrix} \\right\\}\\) \\(Q_z = \\left\\{ cos(\\frac{yaw}{2}), sin(\\frac{yaw}{2}) \\begin{pmatrix} 0 \\\\ 0 \\\\ 1 \\end{pmatrix} \\right\\}\\) By multiplying these, Q can be obtained. This is relatively simple to do because each of the vectors defining the quaternion is a trivial vector (this is because of using world axes!) \\(Q = \\left\\{w, \\begin{pmatrix}x \\\\ y \\\\ z\\end{pmatrix}\\right\\} = Q_z Q_x Q_y\\) let \\(cp = cos(\\frac{pitch}{2})\\) , \\(sp = sin(\\frac{pitch}{2})\\) let \\(cr = cos(\\frac{roll}{2})\\) , \\(sr = sin(\\frac{roll}{2})\\) let \\(cy = cos(\\frac{yaw}{2})\\) , \\(sr = sin(\\frac{yaw}{2})\\) \\(w = cy \\cdot cp \\cdot cr - sy \\cdot sp \\cdot sr\\) \\(x = cy \\cdot sp \\cdot cr - sy \\cdot cp \\cdot sr\\) \\(y = sy \\cdot sp \\cdot cr + cy \\cdot cp \\cdot sr\\) \\(z = sy \\cdot cp \\cdot cr + cy \\cdot sp \\cdot sr\\) This provides a set of equations which can be used to convert from an euler angle representation to a quaternion. Quaternion to Euler Conversion Converting from quaternion to euler uses the rotation matrix representation as a go-between. For the intrinsic set of euler angles z-x'-y'' , a rotation matrix can be composed as follows (recall that right multiply applies about vehicle axis). \\(R = R_z(yaw) R_x(pitch) R_y(roll)\\) Similar to the quaternion case described above, note that matrix multiplication is associative. Thus, this can instead be interpreted as rotations about world axes in the opposite order. Thus, each of \\(R_x\\) , \\(R_y\\) , and \\(R_z\\) are rotations about world x, y, and z axes. Such matrices have known forms. When multiplied out, the following representation of R is obtained. let \\(cp = cos(pitch)\\) , \\(sp = sin(pitch)\\) let \\(cr = cos(roll)\\) , \\(sr = sin(roll)\\) let \\(cy = cos(yaw)\\) , \\(sy = sin(yaw)\\) \\(R = \\begin{pmatrix} cy \\cdot cr - sr \\cdot sy \\cdot sp & -sy \\cdot cp & cy \\cdot sr + sy \\cdot sp \\cdot cr \\\\ sy \\cdot cr + sr \\cdot sp \\cdot cy & cy \\cdot cp & sy \\cdot sr - cr \\cdot sp \\cdot cy \\\\ -cp \\cdot sr & sp & cp \\cdot cr \\end{pmatrix}\\) Using entries of this matrix, the following relations can be constructed \\(R_{32} = sin(pitch) \\rightarrow pitch = sin^{-1}(R_{32})\\) \\(\\frac{R_{31}}{R_{33}} = \\frac{-sin(roll)cos(pitch)}{cos(roll)cos(pitch)} = tan(roll) \\rightarrow roll = tan^{-1}(\\frac{-R_{31}}{R_{33}})\\) \\(\\frac{R_{12}}{R_{22}} = \\frac{sin(yaw)cos(pitch)}{cos(yaw)cos(pitch)} = tan(yaw) \\rightarrow yaw = tan^{-1}(\\frac{R_{12}}{R_{22}})\\) A quaternion can also be converted to a rotation matrix with a known form. Using cells from this quaternion-backed rotation matrix yields the following relations \\(pitch = sin^{-1}(2(yz+wx))\\) \\(roll = tan^{-1}(\\frac{2(wy-xz)}{1-2(x^2+y^2)})\\) \\(yaw = tan^{-1}(\\frac{2(xy-wz)}{1-2(x^2 + z^2)})\\) Note that arctangent should be implemented in code using the quadrant aware atan2 to account for quadrants properly and avoid divide by zero issues.","title":"Math"},{"location":"devs/math/#math","text":"","title":"Math"},{"location":"devs/math/#coordinate-system-definition","text":"The control board uses a coordinate system that is somewhat non-standard. The coordinate system is right handed +y is forward, +z is up, +x is right Pitch is about x, roll is about y, yaw is about z While this coordinate system may seem strange to some (especially those who have worked with aircraft), the name of axes doesn't really matter. The definition of pitch, roll, and yaw relative to the front / top of the vehicle remain standard.","title":"Coordinate System Definition"},{"location":"devs/math/#6-degree-of-freedom-motion-control","text":"","title":"6 Degree of Freedom Motion Control"},{"location":"devs/math/#nomenclature-notation-and-convention-notes","text":"Matrices are assumed to be zero indexed (not 1 indexed). This means the first element of a matrix \\(M\\) is \\(m_{00}\\) not \\(m_{11}\\) . This is because the math will be implemented in C (which uses zero indexed arrays). Thruster numbers (1-8) are used by the control board's user facing components. However, this math will use thruster indices (0-7) where index = number - 1 . This is again because arrays in C are zero indexed. Rotations about axes (angular velocities / DoFs) are referred to as \"xrot\" (about x), \"yrot\" (about y), and \"zrot\" (about z). The terms \"pitch\", \"roll\", and \"yaw\" are used to describe the vehicle's orientation in space. These are a set of intrinsic Euler angles (Tait-Bryan angles to be precise) composed in the order yaw then pitch then roll (z-x'-y'' in the control board's coordinate system). Note that while these do follow the standard meanings of pitch, roll, and yaw relative to the vehicle, the axes have non-standard names. Thus, you cannot simply use standard formulas for converting between quaternions and pitch, roll, yaw. Velocities in DoFs are normalized (meaning -1.0 to 1.0). Euler angles are represented as a set of three values \\(\\begin{pmatrix} pitch & roll & yaw\\end{pmatrix}\\) Quaternions are represented either as a combination of a scalar component, \\(s\\) , and a vector component, \\(v\\) as \\(\\{s,v\\}\\) or they may be represented using the names \\(w\\) , \\(x\\) , \\(y\\) , and \\(z\\) . In such a case this is equivelent to \\(\\{w, (x, y, z)\\}\\) . In other words, \\(x\\) , \\(y\\) , and \\(z\\) are the components of the vector \\(v\\) and \\(w=s\\) . The conjugate of a quaternion, \\(q\\) is denoted \\(q^*\\)","title":"Nomenclature, Notation, and Convention Notes"},{"location":"devs/math/#system-assumptions","text":"Vehicle is capable of motion exclusively in each of 6 degrees of freedom (DoFs). These are three translational DoFs, and three rotational DoFs. The vehicle's speed in positive and negative directions are roughly equal for each DoF. Thruster orientations are fixed. Gimbaled thruster vehicles are not supported. At most 8 thrusters (less is fine) System has 3D orientation information System has depth information System does not have translational position information","title":"System Assumptions"},{"location":"devs/math/#example-vehicle","text":"The examples on this page will use AquaPack robotics's SeaWolf VIII robot . This robot's thruster configuration is as shown below. The arrows indicate the direction the thruster moves water when powered in the positive direction. These arrows are opposite the direction force is excerpted on the vehicle. Note that the diagram above uses thruster numbers, not indices.","title":"Example Vehicle"},{"location":"devs/math/#dof-matrix","text":"The DoF Matrix , \\(D\\) , is constructed based on the vehicle's thruster configuration. Rows of the matrix correspond to thrusters (by index). And columns of the matrix correspond to vehicle-relative DoFs. Thus, this is an 8x6 matrix (8 thrusters, 6 DoFs). Columns correspond to DoFs in the following order (0-5): x, y, z, xrot, yrot, zrot. \\(D = \\left(\\begin{array}{c|c|c|c|c|c} d_0 & d_1 & d_2 & d_3 & d_4 & d_5 \\end{array}\\right) = \\left(\\begin{array}{c|c|c|c|c|c} d_x & d_y & d_z & d_{xr} & d_{yr} & d_{zr} \\end{array}\\right)\\) Each column of the DoF matrix, \\(d_i\\) is a set of thruster speeds that result in motion exclusively in the column's DoF. Additionally, the resultant motion should be the maximum possible speed, and in the positive direction. Each \\(d_i\\) is an 8 element column vector, with elements corresponding to thrusters (by index). All speeds should be normalized (between -1.0 and 1.0) For the example vehicle shown above, the following is the DoF matrix \\(D = \\begin{pmatrix} -1 & -1 & 0 & 0 & 0 & +1 \\\\ +1 & -1 & 0 & 0 & 0 & -1 \\\\ -1 & +1 & 0 & 0 & 0 & -1 \\\\ +1 & +1 & 0 & 0 & 0 & +1 \\\\ 0 & 0 & -1 & -1 & -1 & 0 \\\\ 0 & 0 & -1 & -1 & +1 & 0 \\\\ 0 & 0 & -1 & +1 & -1 & 0 \\\\ 0 & 0 & -1 & +1 & +1 & 0 \\\\ \\end{pmatrix}\\) Consider the first column: \\(d_0 = d_x\\) . This column's thruster speeds should result in the vehicle moving as fast as possible in the +x direction (only). This is achieved by setting T2, T4 (index 1, 3) to the positive direction and T1, T3 (index 0, 2) to the negative direction at full speed (recall that the arrows are opposite the direction the thruster excerpts force on the vehicle). Thus \\(d_x = \\begin{pmatrix}-1 & +1 & -1 & +1 & 0 & 0 & 0 & 0\\end{pmatrix}^T\\) Note that when constructing the DoF matrix for your vehicle, you should assume an ideal system and environment (ignore variation between thrusters, environmental factors that create motion, etc).","title":"DoF Matrix"},{"location":"devs/math/#local-mode-motion","text":"In LOCAL mode, motion is specified as a set of speeds in vehicle-relative DoFs. The user provides the control board with a local target motion vector ( \\(t_l\\) ) where each element corresponds to a DoF. \\(t_l = \\begin{pmatrix} x & y & z & r_x & r_y & r_z \\end{pmatrix}^T\\) \\(x\\) is normalized velocity in +x direction \\(y\\) is normalized velocity in +y direction \\(z\\) is normalized velocity in +y direction \\(r_x\\) is normalized angular velocity about the +x axis direction (xrot) \\(r_y\\) is normalized angular velocity about the +y axis (yrot) \\(r_z\\) is normalized angular velocity about the +z axis (zrot) By multiplying this target motion by the DoF matrix, \\(D\\) , a speed vector \\(s\\) is obtained where each element of \\(s\\) corresponds to a specific thruster (by index). \\(s = D t_l\\) Consider the example where \\(t_l = \\begin{pmatrix}0 & 1 & 0 & 0 & 0 & 0\\end{pmatrix}^T\\) . This should cause the vehicle to move at full possible speed forward (relative to the vehicle's orientation). \\(s = D t_l = \\begin{pmatrix} -1 & -1 & 0 & 0 & 0 & +1 \\\\ +1 & -1 & 0 & 0 & 0 & -1 \\\\ -1 & +1 & 0 & 0 & 0 & -1 \\\\ +1 & +1 & 0 & 0 & 0 & +1 \\\\ 0 & 0 & -1 & -1 & -1 & 0 \\\\ 0 & 0 & -1 & -1 & +1 & 0 \\\\ 0 & 0 & -1 & +1 & -1 & 0 \\\\ 0 & 0 & -1 & +1 & +1 & 0 \\\\ \\end{pmatrix} \\begin{pmatrix}0 \\\\ 1 \\\\ 0 \\\\ 0 \\\\ 0 \\\\ 0\\end{pmatrix} = \\begin{pmatrix}-1 \\\\ -1 \\\\ +1 \\\\ +1 \\\\ 0 \\\\ 0 \\\\ 0 \\\\ 0\\end{pmatrix}\\) In the above example, it is trivial to see that this is the desired motion. However for a more complex example, a problem appears. Consider \\(t_l = \\begin{pmatrix}0 & 1 & 0 & 0 & 0 & 1\\end{pmatrix}^T\\) . This describes the vehicle both moving forward and about the z-axis at full possible speed. \\(s = D t_l = \\begin{pmatrix} -1 & -1 & 0 & 0 & 0 & +1 \\\\ +1 & -1 & 0 & 0 & 0 & -1 \\\\ -1 & +1 & 0 & 0 & 0 & -1 \\\\ +1 & +1 & 0 & 0 & 0 & +1 \\\\ 0 & 0 & -1 & -1 & -1 & 0 \\\\ 0 & 0 & -1 & -1 & +1 & 0 \\\\ 0 & 0 & -1 & +1 & -1 & 0 \\\\ 0 & 0 & -1 & +1 & +1 & 0 \\\\ \\end{pmatrix} \\begin{pmatrix}0 \\\\ 1 \\\\ 0 \\\\ 0 \\\\ 0 \\\\ 1\\end{pmatrix} = \\begin{pmatrix}0 \\\\ -2 \\\\ 0 \\\\ +2 \\\\ 0 \\\\ 0 \\\\ 0 \\\\ 0\\end{pmatrix}\\) Notice that the resultant speed vector has motors moving in excess of 100% speed (elements with magnitude greater than 1.0). This is not possible. The simple solution would seem to be dividing all elements of the vector by the one with the largest magnitude. This results in a scaled speed vector \\(\\hat{s}\\) \\(\\hat{s} = s \\div \\text{absmax}(s)\\) However, this method will not work well in all cases. Consider \\(t_l = \\begin{pmatrix}0 & 1 & 1 & 1 & 1 & 1\\end{pmatrix}^T\\) . \\(s = D t_l = \\begin{pmatrix} -1 & -1 & 0 & 0 & 0 & +1 \\\\ +1 & -1 & 0 & 0 & 0 & -1 \\\\ -1 & +1 & 0 & 0 & 0 & -1 \\\\ +1 & +1 & 0 & 0 & 0 & +1 \\\\ 0 & 0 & -1 & -1 & -1 & 0 \\\\ 0 & 0 & -1 & -1 & +1 & 0 \\\\ 0 & 0 & -1 & +1 & -1 & 0 \\\\ 0 & 0 & -1 & +1 & +1 & 0 \\\\ \\end{pmatrix} \\begin{pmatrix}0 \\\\ 1 \\\\ 1 \\\\ 1 \\\\ 1 \\\\ 1\\end{pmatrix} = \\begin{pmatrix}0 \\\\ -2 \\\\ 0 \\\\ +2 \\\\ -3 \\\\ -1 \\\\ -1 \\\\ +1\\end{pmatrix}\\) and \\(\\hat{s} = s \\div \\text{absmax}(s) = s \\div 3 = \\begin{pmatrix}0 \\\\ -0.67 \\\\ 0 \\\\ +0.67 \\\\ -1 \\\\ -0.33 \\\\ -0.33 \\\\ +0.33\\end{pmatrix}\\) While this has resulted in an possible set of thruster speeds, these are not optimal. Look at the example vehicle diagram. Notice that thrusters 1-4 and 5-8 control different motions. In the previous example, thrusters 1-4 were slowed down more than necessary, because thruster 5 was too large of a value. This is not ideal as the vehicle's maximum speed becomes artificially limited. Instead, the following \\(\\hat{s}\\) is ideal. This is scaling down the thrusters within each group (1-4 and 5-8) separately. \\(\\hat{s} = \\begin{pmatrix}0 \\\\ -1 \\\\ 0 \\\\ +1 \\\\ -1 \\\\ -0.33 \\\\ -0.33 \\\\ +0.33\\end{pmatrix}\\) Groupings of thrusters on the example vehicle are easy to observe, however this is not always true. Thus, achieving optimal scaling for any system (any DoF matrix) requires a more sophisticated method to determine groupings and scale speeds. Thruster groupings are determined by \"overlap\" between thrusters. Two thrusters, \\(i\\) and \\(j\\) are said to overlap if they have a non-zero entry in the same column of the DoF matrix ( \\(D\\) ) for at least one column. This is easier to calculate using a contribution matrix , \\(C\\) , defined as \\(D \\neq 0\\) . This results in a binary form of the DoF matrix. For the above example \\(C = \\left[\\begin{pmatrix} -1 & -1 & 0 & 0 & 0 & +1 \\\\ +1 & -1 & 0 & 0 & 0 & -1 \\\\ -1 & +1 & 0 & 0 & 0 & -1 \\\\ +1 & +1 & 0 & 0 & 0 & +1 \\\\ 0 & 0 & -1 & -1 & -1 & 0 \\\\ 0 & 0 & -1 & -1 & +1 & 0 \\\\ 0 & 0 & -1 & +1 & -1 & 0 \\\\ 0 & 0 & -1 & +1 & +1 & 0 \\\\ \\end{pmatrix} \\neq 0 \\right] = \\begin{pmatrix} 1 & 1 & 0 & 0 & 0 & 1 \\\\ 1 & 1 & 0 & 0 & 0 & 1 \\\\ 1 & 1 & 0 & 0 & 0 & 1 \\\\ 1 & 1 & 0 & 0 & 0 & 1 \\\\ 0 & 0 & 1 & 1 & 1 & 0 \\\\ 0 & 0 & 1 & 1 & 1 & 0 \\\\ 0 & 0 & 1 & 1 & 1 & 0 \\\\ 0 & 0 & 1 & 1 & 1 & 0 \\\\ \\end{pmatrix}\\) Then for each thruster \\(i\\) an overlap vector \\(o_i\\) can be constructed as follows \\(o_i = C (c^i)^T\\) where \\(c^i\\) is the \\(i\\) th row of \\(C\\) . Thus, \\(o_i\\) is an 8 element vector where each element corresponds to a thruster (by index). Element \\(j\\) of \\(o_i\\) can either be \\(1\\) or a \\(0\\) . A \\(1\\) indicates that thrusters \\(i\\) and \\(j\\) overlap. For example, \\(o_0 = C (c^0)^T = \\begin{pmatrix} 1 & 1 & 1 & 1 & 0 & 0 & 0 & 0 \\end{pmatrix}^T\\) This shows that thruster index 0 (T1) overlaps with indices 0, 1, 2, and 3 (T1, T2, T3, T4). By calculating and storing these overlap vectors for each thruster ( \\(\\left\\{o_i\\right\\}_{i=0}^7\\) ), this effectively forms a lookup table to determine thruster overlap. While this is not the most memory efficient option, it reduces computation time, which is important since this will run very frequently on a microcontroller. Using overlap vectors, the following algorithm can be used to scale motor speeds: Find the thruster ( i ) with the largest magnitude speed Iterate over thruster i 's overlap vector For any thruster, j , with which thruster i overlaps, divide thruster j 's speed by the magnitude of thruster i 's speed Repeat until the largest magnitude does not exceed 1.0 while true // m is value, i is index m, i = max(abs(speed_vector)) if m <= 1.0 // Done scaling break endif // Iterate over all thrusters (0-7 inclusive) for j=0...7 if overlap_vector[i][j] == 1 // i and j overlap. Divide j's speed by m. speed_vector[j] /= m endif endfor endwhile This algorithm results in optimal speed scaling by only reducing the speed of thrusters that share DoF contributions.","title":"LOCAL Mode Motion"},{"location":"devs/math/#global-mode-motion","text":"GLOBAL mode is very similar to LOCAL mode, however, motion is described partially relative to the world instead of the robot. Specifically, motion of the vehicle is compensated for vehicle pitch and roll (but not yaw). This results in a coordinate system defined by the axes gx , gy , and gz . Note that the world coordinate system is defined as wx , wy , wz . Notably, if the vehicle is pitched 180 degrees, the gx-gy plane becomes aligned to the back of the vehicle ensuring consistent motion. This is shown in the animation below. In GLOBAL mode, the user provides the control board with a global target motion vector , \\(t_g\\) with 6 elements. This target motion vector is a concatenation of two 3 dimensional vectors. The first, a set of translations along gx , gy , and gz . Second a set of rotations to affect vehicle pitch, roll, and yaw. These are referred to by the following names x : Speed in gx direction (translation) y : Speed in gy direction (translation) z : Speed in gz direction (translation) p : Speed at which the vehicle's pitch should increase (negative for decrease pitch). Aka \"pitch_spd\" r : Speed at which the vehicle's roll should increase (negative for decrease pitch). Aka \"roll_spd\" h : Speed at which the vehicle's yaw should increase (negative for decrease pitch). Aka \"yaw_spd\" \\(t_g = \\begin{pmatrix} x & y & z & p & r & h \\end{pmatrix}\\) It is necessary to transform each DoF's motion into motions in the vehicle's DoFs. These speeds can then be passed to LOCAL mode. WARNING: GLOBAL mode is impacted by gimbal lock issues with euler angles. This occurs when the vehicle's pitch is +/- 90 degrees. In this scenario the meaning of \"increase / decrease pitch\" is ambiguous. The vehicle will take the zero-roll route in this scenario (an arbitrary choice based on how euler angle conversion is implemented in the firmware). Thus, GLOBAL mode may produce undesirable motion if the roll is non-zero and you pitch through +/- 90. A potential solution for this could be some form of motion hysteresis to handle moving through gimbal lock orientations, however this is not implemented as of now.","title":"GLOBAL Mode Motion"},{"location":"devs/math/#translation-dofs","text":"The translation DoFs are easily transformed using gravity vectors. By applying a quaternion based rotation matrix to the base gravity vector, \\(g_b = \\begin{pmatrix}0 & 0 & -1\\end{pmatrix}\\) , the following solution is determined for the current gravity vector, \\(g_c\\) given the vehicle's orientation quaternion, \\(q\\) . \\(\\begin{pmatrix} 2*(q.x*q.z+q.w*q.y) \\\\ 2*(q.w*q.x-q.y*q.z) \\\\ -(q.w)^2+(q.x)^2+(q.y)^2-(q.z)^2\\end{pmatrix}^T\\) The minimal rotation from \\(g_b\\) to \\(g_c\\) is then calculated. Let this rotation be called \\(q_{rot}\\) . This rotation will generally include no yaw component, unless the vehicle is upside down and facing backwards (eg pitch of 180 degrees) in which case it will contain a yaw component of 180 degrees. This is desirable as it ensures a continuous definition of what gy is even while the vehicle is flipping via pitch. This quaternion can then be applied to speeds in the gx , gy , gz basis ( x , y , and z here) to rotate them onto the vehicle basis. Thus, this \"converts\" translation speeds from GLOBAL to LOCAL mode DoFs. However, it is not ideal to transform the translation vector all at once. It is best to do it in three stages to allow proper upscaling as needed (explained below). Thus for each global mode translation vector \\(\\begin{pmatrix} x & 0 & 0 \\end{pmatrix}\\) , \\(\\begin{pmatrix} 0 & y & 0 \\end{pmatrix}\\) , and \\(\\begin{pmatrix} 0 & 0 & z \\end{pmatrix}\\) rotate it by \\(q_{rot}\\) to obtain \\(t_x\\) , \\(t_y\\) , and \\(t_z\\) respectively (note that \\(\\left\\{s, v\\right\\}\\) is a quaternion with scalar s and vector v). \\(\\left\\{0, t_x\\right\\} = q_{rot} \\left\\{0, \\begin{pmatrix} x & 0 & 0 \\end{pmatrix} \\right\\} q_{rot}^*\\) \\(\\left\\{0, t_y\\right\\} = q_{rot} \\left\\{0, \\begin{pmatrix} 0 & y & 0 \\end{pmatrix} \\right\\} q_{rot}^*\\) \\(\\left\\{0, t_z\\right\\} = q_{rot} \\left\\{0, \\begin{pmatrix} 0 & 0 & z \\end{pmatrix} \\right\\} q_{rot}^*\\) Each of \\(t_x\\) , \\(t_y\\) , and \\(t_z\\) are speeds in LOCAL mode DoFs, however they may be slower than desired. Consider a speed of 1.0 along gy . If the vehicle were rotated 45 degrees (pitch) the resultant \\(t_y\\) would be \\(t_y = \\begin{pmatrix} 0.0 & 0.7071 & 0.7071 \\end{pmatrix}\\) . This is not as fast as possible in the correct direction. Instead \\(t_y\\) should be \\(t_y = \\begin{pmatrix} 0.0 & 1.0 & 1.0 \\end{pmatrix}\\) . In other words, the largest element of \\(t_y\\) should be the speed along gy . Thus, each of \\(t_x\\) , \\(t_y\\) , \\(t_z\\) needs to be upscaled (note that it will never need to be downscaled; it only needs to be upscaled because one DoF may now be spread between multiple). let \\(m\\) be the magnitude of the element of \\(t_x\\) with the largest magnitude Normalize \\(t_x\\) so that largest element is 1.0: \\(t_x = t_x / m\\) Scale normalized \\(t_x\\) by speed \\(x\\) (gx speed): \\(t_x = t_x * x\\) Repeat this for \\(t_y\\) and \\(t_z\\) using \\(y\\) and \\(z\\) speeds respectively. Once all three \\(t\\) vectors are scaled, they can be combined to create the net LOCAL mode translation vector, \\(l\\) \\(l = t_x + t_y + t_z\\) There are two potential issues with \\(l\\) \\(l\\) is a set of proportionally related speeds to result in the desired motion. However, the vehicle may not be capable of the same speeds in each of it's DoFs. Thus, the ratios between \\(l\\) 's elements may be incorrect. \\(l\\) is a sum of three vectors (each with elements no larger than a magnitude of 1), thus it may have elements with a magnitude greater than 1. Issue 1 should be handled first as correcting it may \"fix\" issue 2. Handling issue 2 first could result in downscaling speeds more than necessary. Handling issue 1 requires the user to provide a little more information about the vehicle: relative speeds in each DoF. These can be used to calculate downscaling factors to slow down the faster directions (note: speeding up the slower directions could result in impossible speeds, but would be handled by solving issue 2; regardless it is less ideal). These downscaling factors are calculated from \"RELDOF\" information provided by the user (see messages page of user guide). This information is a set of constants, which will be referred to the as the scale factors as \\(m_x\\) , \\(m_y\\) , \\(m_z\\) , \\(m_{rx}\\) , \\(m_{ry}\\) , and \\(m_{rz}\\) for the x, y, z, xrot, yrot, and zrot DoFs respectively (note that these are vehicle DoFs). These scale factors makeup two groups: translational ( \\(m_x\\) , \\(m_y\\) , and \\(m_z\\) ) and rotational ( \\(m_{rx}\\) , \\(m_{ry}\\) , and \\(m_{rz}\\) ). Within each group, the fastest DoF's scale factor is set to 1. The other scale factors are a percentage of the fastest DoF in the group. For example, if the vehicle can move at 2m/s along z, 1m/s along y, and 0.5m/s along x then \\(m_x = 0.25\\) , \\(m_y = 0.5\\) , and \\(m_z = 1.0\\) . Given these scale factors, the simplest option would be to let \\(l = \\begin{pmatrix}l.x * m_x & l.y * m_y & l.z * m_z\\end{pmatrix}\\) . However, this may downscale more than necessary. Consider a scenario where the speed vector \\(l\\) has a \\(0\\) in the position of the slowest DoF of the vehicle (eg if the vehicle is slowest in the x direction, the \\(l\\) vector would have a zero in the x position). In this case, since the slowest direction is unused, we are downscaling too much. Thus, the following algorithm is used to select the ideal downscaling factors by \"ignoring\" the downscaling required for unused DoFs (DoFs with a speed of 0). // Zero downscale factors for unused DoFs if abs(l.x) == 0 m_x = 0 endif if abs(l.y) == 0 m_y = 0 endif if abs(l.z) == 0 m_z = 0 endif // Rebalance scale factors so largest remaining is 1.0 m_max = max(m_x, max(m_y, m_z)); m_x = m_x / m_max; m_y = m_y / m_max; m_z = m_z / m_max; \\(l\\) is then downscaled as \\(l = \\begin{pmatrix}l.x * m_x & l.y * m_y & l.z * m_z\\end{pmatrix}\\) using the scale factors calculated using the above algorithm. Finally, issue 2 must be handled if any element of \\(l\\) still has a magnitude greater than 1.0. Thus, Let \\(m\\) be the magnitude of the element of \\(l\\) with the largest magnitude If \\(m\\) is less than or equal to 1, do not change $l If \\(m\\) is greater than 1 \\(l = l / m\\) This resultant \\(l\\) is a set of speeds that can be passed to LOCAL mode as it's x , y , and z speeds.","title":"Translation DoFs"},{"location":"devs/math/#rotation-dofs","text":"Converting the GLOBAL mode rotations (increase/decrease pitch, roll, yaw) to motions about DoFs is a little harder. It requires decomposing the quaternion into euler angles, then calculating three quaternions describing one euler rotation each. In other words, given the vehicle's current rotation \\(q\\) we need to find \\(q_{pitch}\\) , \\(q_{roll}\\) and \\(q_{yaw}\\) such that (based on the euler angle convention used by the control board) \\(q = q_{yaw} q_{pitch} q_{roll}\\) Note: recall that when composing quaternions to be applied to a body, left-multiplied quaternions are applied in the extrinsic coordinate system (world-basis) whereas right-multiplied quaternions are applied in the intrinsic coordinate system (rotating body's basis). Thus, yaw is about the world-z axis (z), then pitch is about the vehicle's x-axis after yawing (x') and roll is about the vehicle's y-axis after both yawing then pitching (y''). This is consistent with the definitions of the coordinate system and pitch, roll, yaw for the control board. Decomposing the quaternion can be done by converting \\(q\\) to a set of euler angles \\(e = \\begin{pmatrix}pitch & roll & yaw\\end{pmatrix}\\) then constructing the following and converting each to a quaternion \\(e_{pitch} = \\begin{pmatrix}pitch & 0 & 0\\end{pmatrix} \\rightarrow q_{pitch}\\) \\(e_{roll} = \\begin{pmatrix}0 & roll & 0\\end{pmatrix} \\rightarrow q_{roll}\\) \\(e_{yaw} = \\begin{pmatrix}0 & 0 & yaw\\end{pmatrix} \\rightarrow q_{yaw}\\) However, the euler angles obtained from \\(q\\) may not be correct for this use case. An equivalent angle go \\(e\\) (although improper) is \\(e_{alt} = \\begin{pmatrix} \\pi - pitch & roll - \\pi & yaw - \\pi \\end{pmatrix}\\) . We need to compensate for first roll then pitch. Thus, we need the euler angle with minimal roll component. This will be referred to here as \\(e_b\\) , equal to either \\(e\\) or \\(_{alt}\\) , whichever has the smaller magnitude roll component. Then, given \\(s\\) vectors describing motion to change the vehicle's pitch, roll, or yaw \\(s_{pitch} = \\begin{pmatrix}p & 0 & 0\\end{pmatrix}\\) \\(s_{roll} = \\begin{pmatrix}0 & r & 0\\end{pmatrix}\\) \\(s_{yaw} = \\begin{pmatrix}0 & 0 & h\\end{pmatrix}\\) We need to transform these onto the robot's axes as \\(w\\) vectors. For roll this is trivial as roll is about the vehicle's y axis. For pitch, this requires undoing roll first (rotate by \\(q_{roll}^*\\) ) and for yaw this requires undoing roll then pitch. Thus \\(w_{roll} = s_{roll}\\) \\(\\left\\{0, w_{pitch}\\right\\} = q_{roll}^* \\left\\{0, s_{pitch}\\right\\} q_{roll}\\) \\(\\left\\{0, w_{yaw}\\right\\} = q_{pitch}^* q_{roll}^* \\left\\{0, s_{yaw}\\right\\} q_{roll} q_{pitch}\\) These vectors are angular speeds about the vehicle's x, y, and z axes. Thus, just as for translations Upscale each \\(w\\) vector using p , r , and h speeds (can skip for roll as this vector is never rotated) Sum the three \\(w\\) vectors into a net \\(w\\) vector Adjust \\(w\\) for relative DoF speeds (using \\(m_{rx}\\) , \\(m_{ry}\\) , \\(m_{rz}\\) ) Downscale \\(w\\) if needed so all elements are less than 1 Then \\(w\\) is the xrot, yrot, and zrot parts of the LOCAL mode target.","title":"Rotation DoFs:"},{"location":"devs/math/#orientation-hold-ohold-mode-motion","text":"Orientation hold mode uses closed-loop control for vehicle orientation in 3D space. This is achieved using three PID controllers xrot PID: Controls rotation about vehicle x-axis yrot PID: Controls rotation about vehicle y-axis zrot PID: Controls rotation about vehicle z-axis The inputs to OHOLD mode are as follows x : Translation along gx-axis (same as in GLOBAL mode) y : Translation along gy-axis (same as in GLOBAL mode) z : Translation along gz-axis (same as in GLOBAL mode) e_t : Target orientation as euler angles Optionally, a yaw speed ( h ) can be provided. In this case, PIDs will not adjust the vehicle's yaw (heading). Instead the h value works similar to GLOBAL mode (it is a rate of change of vehicle yaw). This effectively abstracts a 2D plane in which the vehicle operates. This is the same gx-gy plane described in the GLOBAL mode section. There are two variants of OHOLD mode Variant 1 (OHOLD1): Speed for yaw ( h ) is used instead of PID control Variant 2 (OHOLD2): PID is used for yaw (yaw speed h is ignored) Variant 2 is mathematically then simpler variant. Variant 1 adds some additional complexity for orientation control.","title":"Orientation Hold (OHOLD) Mode Motion"},{"location":"devs/math/#translation-dofs_1","text":"The user provided x , y , and z translation speeds are handled the same way by OHOLD mode as they are in GLOBAL mode to obtain the final LOCAL mode translation vector \\(l\\) .","title":"Translation DoFs"},{"location":"devs/math/#ohold2-orientation-control","text":"While translation for OHOLD is nearly identical to GLOBAL mode, rotation DoFs are very different. Orientation is controlled with a set of 3 PID controllers that work in LOCAL DoFs. Thus it is necessary to determine the rotations necessary about the vehicle's axes to achieve the desired orientation. We are given a target orientation as euler angles, \\(e_t\\) . This can be converted to a target orientation quaternion, \\(q_t\\) using the formulas derived in later sections. Note: For OHOLD1 obtaining \\(q_t\\) is more complex. See the OHOLD1 section for details. However, what is done with \\(q_t\\) from here on, is the same in OHOLD1 as it is in OHOLD2. The vehicle's current orientation (as a quaternion) is also available from the IMU as \\(q_c\\) . We need to calculate a quaternion \\(q_d\\) that represents the minimal rotation from \\(q_c\\) to \\(q_t\\) . However, importantly we want \\(q_d\\) to be a rotation in the vehicle's basis. Recall that right multiplication of quaternions are applied in the vehicle's basis. Thus, to describe the target orientation as the current orientation plus a rotation in the vehicle's basis \\(q_t = q_c q_d\\) Therefore \\(q_d = q_c^* q_t\\) However, this angle may not be minimal. Recall that \\(q\\) and \\(-q\\) represent the same orientation. Thus another solution to this problem would be \\(q_d = (-q_c)^* q_t\\) The minimal rotation is the one where \\(q_c\\) and \\(q_t\\) are on the same half of the unit quaternion hypersphere (meaning their dot product is not negative). Thus If \\(q_c \\cdot q_t < 0\\) then \\(q_d = (-q_c)^* q_t\\) Otherwise \\(q_d = q_c^* q_t\\) Then convert \\(q_d\\) to axis-angle representation. The following algorithm is used to do so for numeric stability reasons (the common formulas using asin are not numerically stable) let \\(q_d = \\left\\{s, v\\right\\}\\) \\(\\theta = 2 atan2(|v|, s)\\) \\(n = v / |v|\\) if \\(|v| > 0\\) else \\(n = v = (0, 0, 0)\\) This axis ( \\(n\\) ) will be a unit vector. Thus it represents proportions of the rotation about each of the vehicle's axes (this is about vehicle's axes because \\(q_d\\) is in the vehicle basis). The angle ( \\(\\theta\\) ) is the magnitude of the rotation that must be taken. Thus, the product of \\(n\\) and \\(\\theta\\) is proportional to the error in angle about each of the vehicle's axes. \\(e = \\theta n\\) This error vector, \\(e\\) , contains the errors to be provided to each orientation PID (xrot, yrot, zrot). The output of these PIDs are angular velocity percentages (-1.0 to 1.0) about each of the vehicle's axes ( \\(w_i\\) denotes the output of the \\(i\\) rot PID) \\(w = \\begin{pmatrix} w_x & w_y & w_z \\end{pmatrix}\\) Note: for OHOLD 1 there is an extra step here to calculate the correct w (see section below). Finally, it is necessary to downscale the \\(w\\) vectors just as in GLOBAL mode First downscale using \\(m_{rx}\\) , \\(m_{ry}\\) and \\(m_{rz}\\) using the algorithm described in the GLOBAL mode section Then downscale the vector so that all elements are less than 1. While this is never needed for OHOLD2, it is needed for OHOLD1 and it is simpler branching logic (code implementation) to just always check if downscaling is needed. This \\(w\\) can then be passed to LOCAL mode along with the LOCAL translation vector \\(l\\) obtained earlier.","title":"OHOLD2 Orientation Control"},{"location":"devs/math/#ohold1-orientation-control","text":"OHOLD1 uses much of the same process to control the vehicle's orientation as OHOLD2, however it is necessary to decouple yaw from pitch and roll. In other words, we want to construct a target quaternion using the user provided pitch and roll, but matching the vehicle's current yaw. The most intuitive option would be to decompose \\(q_c\\) into euler angles and obtain the yaw from those. However, this does not account for the fact that the yaw can be altered by pitch or roll. For example, (p=115, r=0, h=90) would be decomposed as (p=65, r=180, h=-90). Here the heading is 180 degrees off. This would be a significant issue. Thus instead, the target quaternion can be decomposed using the swing-twist decomposition of quaternion rotations. We twist about the world z axis (since this is the axis the vehicle initially yawed about). The vehicle's yaw can be calculated from this twist quaternion (using euler conversion formula). The target quaternion is constructed from the target pitch and roll provided by the user and the yaw provided by the twist quaternion as described above. This target quaternion is \\(q_t\\) and is used the same way described for OHOLD2. After calculating \\(w\\) as described for OHOLD2, there is one extra step before handling DoF scaling. The yaw speed ( h ) provided by the user must be transformed to the vehicle's axes and added to the \\(w\\) from the PIDs. This can be done similar to GLOBAL mode \\(\\left\\{0, w_{yaw}\\right\\} = q_{rot} \\left\\{0, \\begin{pmatrix}0 & 0 & h\\end{pmatrix}\\right\\} q_{rot}^*\\) \\(w_{yaw}\\) will then be upscaled just as in GLOBAL mode. Then \\(w = w + w_{yaw}\\) . This is then downscaled as described for OHOLD2.","title":"OHOLD1 Orientation Control"},{"location":"devs/math/#stability-assist-sassist-mode","text":"Stability assist mode (SASSIST) is simply OHOLD mode, with the addition of closed-loop control for vehicle depth. Thus, instead of providing a z speed (for motion along the gz-axis), a PID controller is used to achieve the target depth. Inputs to this mode are the same as OHOLD mode, however instead of z , d_t is provided. d_t : Target depth (meters; negative for below the surface) The PID used to maintain vehicle depth is referred to as the Depth PID. This PID uses the current vehicle depth (provided by a depth sensor) to calculate a z speed in the gz-axis, then provides it as an input to OHOLD mode. All other inputs from SASSIST are passed through to OHOLD mode as provided. Thus, there are two variants of SASSIST mode (variant 1 and variant 2) built ontop of the corresponding variants of OHOLD mode.","title":"Stability Assist (SASSIST) Mode"},{"location":"devs/math/#accumulated-euler-angles","text":"WARNING: Make sure you understand what these are and are not before using them. These are not normal euler angles. They are intended to allow high level software using the control board to a measurement of orientation about an individual axis that accumulates similar to a gyroscope. Generally, use of these is discouraged. They are provided as a \"compatibility bridge\" for code developed for a gyroscope system. WARNING: Accumulated euler angles are not the current orientation of the vehicle as an euler angle! The euler and quaternion values provided by the IMU are not directly useful for tracking multiple rotations of the vehicle. Unlike simply integrating gyroscope data, euler angles (pitch, roll, yaw) and quaternions do not track the number of times the vehicle has rotated about a particular axis. They only track the vehicle's orientation in space. While integrating raw gyro data would provide an accumulating measurement, such a solution would be rotations about the robot's axes. Generally, it is more useful to track the number of times the vehicle has \"pitched\", \"rolled\" or \"yawed\". Note that an accumulated gyro z angle of 500 does not necessarily mean the robot has yawed 500 degrees; the robot could have been oriented at a pitch of 90. Instead, we want to measure how many degrees the vehicle has rotated through. This can be done by tracking changes between subsequent quaternions from the IMU. The idea is to compare each quaternion read from the IMU with the previous quaternion received from the IMU (note that quaternions of all zeros are ignored to avoid issues with invalid IMU data samples after first configuring the sensor). For each quaternion read from the IMU: Calculate the shortest set of rotations from the previous to the current quaternion Convert the shortest angle to euler angles Add the pitch, roll, and yaw from the shortest euler angles to accumulated pitch, roll, and yaw variables Note that if the IMU axis config changes, the accumulated data should be zeroed and the previously read quaternion discarded. This makes the assumption that the smallest rotation between two quaternions is the most probable path the robot took to change its orientation. This is an approximation, however it is a fairly good one as long as sample rate of data is sufficiently high. The specifics of the path are lost, however, if the sample rate is high enough, the length of the path is sufficiently small that and this is a good approximation. The second issue with this approximation has to do with rotations exceeding 180 degrees. The method for determining shortest path between two quaternions will be incorrect if the vehicle rotates more than 180 degrees in any axis (because the shortest path would have involved rotating the other direction). To guarantee rotations between two samples never exceed 180 degrees, the max measured rotation rate of the IMU is considered. For the BNO055 this is 2000 degrees per second. Thus, with a sample period of \\(l\\) milliseconds, the largest angle change between samples is \\(\\frac{2000 \\textrm{ deg}}{1 \\textrm{ sec}} \\cdot \\frac{1 \\textrm{ sec}}{1000 \\textrm{ ms}} \\cdot \\frac{l \\textrm{ ms}}{1 \\textrm{ sample}} = 2l \\textrm{ deg / sample}\\) To ensure that changes of more than 180 degrees do not occur, the following must be satisfied \\(2l < 180 \\rightarrow l < 90 \\textrm{ milliseconds}\\) However, it is possible for some samples from the IMU to be delayed (ie I2C bus busy with another sensor) or lost (I2C failure). Thus, it is necessary to choose a value for \\(l\\) that allows for at least one sample to be lost. When a sample is lost, this doubles the effective time between samples. Thus, it is necessary to half \\(l\\) \\(l < 45 \\textrm{ milliseconds}\\) By further reducing \\(l\\) it is possible to allow for larger delays or more lost samples. The current firmware samples IMU data every 15ms (the max rate supported by the BNO055 in fusion mode is 100Hz = 10ms period). Using \\(l=15 \\textrm{ ms}\\) it is possible for 5 consecutive samples to be lost while still guaranteeing that no more than 90ms passes between valid samples (thus still ensuring no more than 180 degree change between samples).","title":"Accumulated Euler Angles"},{"location":"devs/math/#other-derivations","text":"","title":"Other Derivations"},{"location":"devs/math/#euler-to-quaternion-conversion","text":"The euler angle convention used for the control board is an intrinsic set z-x'-y'' (rotate about z, then about new x, then about new y to compose an angle). Using the definitions of front/right/top for this coordinate system, this means that roll is about y, pitch is about x, and yaw is about z. A rotation quaternion, \\(Q\\) , can be composed using three rotations, each being one of the rotations used to construct the euler angle representation (in order). \\(Q = Q_z Q_x Q_y\\) Quaternion multiplication is associative. Recall that right-multiplied quaternions are applied in the vehicle frame during composition. Thus, when viewed left to right: First, apply \\(Q_z\\) in vehicle frame (also equal to world frame since this is the first rotation) Then, apply \\(Q_x\\) in the vehicle frame Finally, apply \\(Q_y\\) in the vehicle frame However, recall that left-multiplied quaternions are applied in the world frame during composition. Thus, when viewed right to left First, apply \\(Q_y\\) in the world frame Then, apply \\(Q_x\\) in the world frame Finally, apply \\(Q_z\\) in the world frame In other words, the following are equivalent Yaw about z , then pitch about x' , then roll about y'' Roll about y , then pitch about x , the yaw about z These use the same pitch, roll, and yaw angles , but the latter applies them about world axes , which have known and trivial direction vectors. Thus, each of pitch, roll, and yaw are a rotation about a known axis (x, y, or z respectively). Converting these from axis-angle from, the quaternions are represented as follows \\(Q_y = \\left\\{ cos(\\frac{roll}{2}), sin(\\frac{roll}{2}) \\begin{pmatrix} 0 \\\\ 1 \\\\ 0 \\end{pmatrix} \\right\\}\\) \\(Q_x = \\left\\{ cos(\\frac{pitch}{2}), sin(\\frac{pitch}{2}) \\begin{pmatrix} 1 \\\\ 0 \\\\ 0 \\end{pmatrix} \\right\\}\\) \\(Q_z = \\left\\{ cos(\\frac{yaw}{2}), sin(\\frac{yaw}{2}) \\begin{pmatrix} 0 \\\\ 0 \\\\ 1 \\end{pmatrix} \\right\\}\\) By multiplying these, Q can be obtained. This is relatively simple to do because each of the vectors defining the quaternion is a trivial vector (this is because of using world axes!) \\(Q = \\left\\{w, \\begin{pmatrix}x \\\\ y \\\\ z\\end{pmatrix}\\right\\} = Q_z Q_x Q_y\\) let \\(cp = cos(\\frac{pitch}{2})\\) , \\(sp = sin(\\frac{pitch}{2})\\) let \\(cr = cos(\\frac{roll}{2})\\) , \\(sr = sin(\\frac{roll}{2})\\) let \\(cy = cos(\\frac{yaw}{2})\\) , \\(sr = sin(\\frac{yaw}{2})\\) \\(w = cy \\cdot cp \\cdot cr - sy \\cdot sp \\cdot sr\\) \\(x = cy \\cdot sp \\cdot cr - sy \\cdot cp \\cdot sr\\) \\(y = sy \\cdot sp \\cdot cr + cy \\cdot cp \\cdot sr\\) \\(z = sy \\cdot cp \\cdot cr + cy \\cdot sp \\cdot sr\\) This provides a set of equations which can be used to convert from an euler angle representation to a quaternion.","title":"Euler to Quaternion Conversion"},{"location":"devs/math/#quaternion-to-euler-conversion","text":"Converting from quaternion to euler uses the rotation matrix representation as a go-between. For the intrinsic set of euler angles z-x'-y'' , a rotation matrix can be composed as follows (recall that right multiply applies about vehicle axis). \\(R = R_z(yaw) R_x(pitch) R_y(roll)\\) Similar to the quaternion case described above, note that matrix multiplication is associative. Thus, this can instead be interpreted as rotations about world axes in the opposite order. Thus, each of \\(R_x\\) , \\(R_y\\) , and \\(R_z\\) are rotations about world x, y, and z axes. Such matrices have known forms. When multiplied out, the following representation of R is obtained. let \\(cp = cos(pitch)\\) , \\(sp = sin(pitch)\\) let \\(cr = cos(roll)\\) , \\(sr = sin(roll)\\) let \\(cy = cos(yaw)\\) , \\(sy = sin(yaw)\\) \\(R = \\begin{pmatrix} cy \\cdot cr - sr \\cdot sy \\cdot sp & -sy \\cdot cp & cy \\cdot sr + sy \\cdot sp \\cdot cr \\\\ sy \\cdot cr + sr \\cdot sp \\cdot cy & cy \\cdot cp & sy \\cdot sr - cr \\cdot sp \\cdot cy \\\\ -cp \\cdot sr & sp & cp \\cdot cr \\end{pmatrix}\\) Using entries of this matrix, the following relations can be constructed \\(R_{32} = sin(pitch) \\rightarrow pitch = sin^{-1}(R_{32})\\) \\(\\frac{R_{31}}{R_{33}} = \\frac{-sin(roll)cos(pitch)}{cos(roll)cos(pitch)} = tan(roll) \\rightarrow roll = tan^{-1}(\\frac{-R_{31}}{R_{33}})\\) \\(\\frac{R_{12}}{R_{22}} = \\frac{sin(yaw)cos(pitch)}{cos(yaw)cos(pitch)} = tan(yaw) \\rightarrow yaw = tan^{-1}(\\frac{R_{12}}{R_{22}})\\) A quaternion can also be converted to a rotation matrix with a known form. Using cells from this quaternion-backed rotation matrix yields the following relations \\(pitch = sin^{-1}(2(yz+wx))\\) \\(roll = tan^{-1}(\\frac{2(wy-xz)}{1-2(x^2+y^2)})\\) \\(yaw = tan^{-1}(\\frac{2(xy-wz)}{1-2(x^2 + z^2)})\\) Note that arctangent should be implemented in code using the quadrant aware atan2 to account for quadrants properly and avoid divide by zero issues.","title":"Quaternion to Euler Conversion"},{"location":"devs/overview/","text":"Overview TODO: Project Structure and Build System TODO: Hardware abstraction (not really proper abstraction, just multiple implementatiuons of the same external API defined in include/hardware headers; each target has implementation in src/hardware files using include guards to choose which implementation) TODO: Generator projects TODO: System architecture","title":"Firmware Overview"},{"location":"devs/overview/#overview","text":"TODO: Project Structure and Build System TODO: Hardware abstraction (not really proper abstraction, just multiple implementatiuons of the same external API defined in include/hardware headers; each target has implementation in src/hardware files using include guards to choose which implementation) TODO: Generator projects TODO: System architecture","title":"Overview"},{"location":"devs/pythoniface/","text":"Interface Scripts TODO: Implementation details / architecture","title":"Interface Scripts"},{"location":"devs/pythoniface/#interface-scripts","text":"TODO: Implementation details / architecture","title":"Interface Scripts"},{"location":"devs/simulation/","text":"Simulation SimCB SimCB is the name used for the control board firmware built as a binary to run on a PC operating system (Windows, macOS, Linux). This is achieved using the FreeRTOS windows or posix ports. Instead of using UART over USB (as real hardware does), SimCB opens TCP sockets (server) for communication. The code using the control board would then connect to this socket (as a client) instead of opening a UART port to talk with a physical control board. The communication protocol (message structure and format) is exactly the same as described for UART. The SimCB allows a control board to run without hardware. The same firmware that would run on the board instead runs on your PC. There are a few limitations with this. SimCB will only operate in simhijack mode (it cannot be released from simhijack) and only the sim sensors will be available. TODO: Details on where this code lives, how TCP is handled and why. Simulation Hijack TODO: Simhijack and support for this in firmware (including multiple sensor stuff) TODO: Why? Allow a simulated environment to use a control board to actually control a simulated vehicle. Allows motion testing / validation without in-water time (with a real control board). Also allows debugging / testing actual firmware without in-water time with a vehicle. TODO: By combining with SimCB (which can also be simhijacked), motion can be tested without in-water time and without a real control board. Simulator Implementation & Development The simulator is implemented using the Godot game engine (3.5). This provides a 3D rendering and physics engine. GodotAUVSim on GitHub This simulator was initially designed to allow control board firmware development without in-water testing time with a physical vehicle. It has expanded into a reference simulator for end user use. It does not model any environment, just the vehicle(s). TODO: Implementation details / tech docs TODO: Docs on adding vehicles, etc Control Board Setups Thus, there are four ways a \"control board\" can be used Real control board over UART SimCB over TCP Simulator models environment and provides inputs to control board and retrieves outputs from control board Can also do this with SimCB. Simulator is a \"man in the middle\"","title":"Simulation Support"},{"location":"devs/simulation/#simulation","text":"","title":"Simulation"},{"location":"devs/simulation/#simcb","text":"SimCB is the name used for the control board firmware built as a binary to run on a PC operating system (Windows, macOS, Linux). This is achieved using the FreeRTOS windows or posix ports. Instead of using UART over USB (as real hardware does), SimCB opens TCP sockets (server) for communication. The code using the control board would then connect to this socket (as a client) instead of opening a UART port to talk with a physical control board. The communication protocol (message structure and format) is exactly the same as described for UART. The SimCB allows a control board to run without hardware. The same firmware that would run on the board instead runs on your PC. There are a few limitations with this. SimCB will only operate in simhijack mode (it cannot be released from simhijack) and only the sim sensors will be available. TODO: Details on where this code lives, how TCP is handled and why.","title":"SimCB"},{"location":"devs/simulation/#simulation-hijack","text":"TODO: Simhijack and support for this in firmware (including multiple sensor stuff) TODO: Why? Allow a simulated environment to use a control board to actually control a simulated vehicle. Allows motion testing / validation without in-water time (with a real control board). Also allows debugging / testing actual firmware without in-water time with a vehicle. TODO: By combining with SimCB (which can also be simhijacked), motion can be tested without in-water time and without a real control board.","title":"Simulation Hijack"},{"location":"devs/simulation/#simulator-implementation-development","text":"The simulator is implemented using the Godot game engine (3.5). This provides a 3D rendering and physics engine. GodotAUVSim on GitHub This simulator was initially designed to allow control board firmware development without in-water testing time with a physical vehicle. It has expanded into a reference simulator for end user use. It does not model any environment, just the vehicle(s). TODO: Implementation details / tech docs TODO: Docs on adding vehicles, etc","title":"Simulator Implementation &amp; Development"},{"location":"devs/simulation/#control-board-setups","text":"Thus, there are four ways a \"control board\" can be used Real control board over UART SimCB over TCP Simulator models environment and provides inputs to control board and retrieves outputs from control board Can also do this with SimCB. Simulator is a \"man in the middle\"","title":"Control Board Setups"},{"location":"hardware/sensors/","text":"Off-Board Sensors The control board has an integrated IMU (gyro + accel) and is not designed to support off-board IMUs. However, for full functionality, vehicle depth data is also required. This data is provided by an off-board depth sensor. Currently, only one such sensor is supported: MS5837-30BA pressure sensor based depth sensors. The sensor used during development and tested with the control board is BlueRobotics' Bar30 Sensor . The depth sensor is to be connected to the control board via the \"Depth I2C\" header. See the pinout images on the v1 or v2 hardware pages for more details. If using the BlueRobotics sensor, you will need to cut off the connector it comes with and install \"DuPont\" connectors.","title":"Off-Board Sensors"},{"location":"hardware/sensors/#off-board-sensors","text":"The control board has an integrated IMU (gyro + accel) and is not designed to support off-board IMUs. However, for full functionality, vehicle depth data is also required. This data is provided by an off-board depth sensor. Currently, only one such sensor is supported: MS5837-30BA pressure sensor based depth sensors. The sensor used during development and tested with the control board is BlueRobotics' Bar30 Sensor . The depth sensor is to be connected to the control board via the \"Depth I2C\" header. See the pinout images on the v1 or v2 hardware pages for more details. If using the BlueRobotics sensor, you will need to cut off the connector it comes with and install \"DuPont\" connectors.","title":"Off-Board Sensors"},{"location":"hardware/v1/","text":"AUV Control Board v1 Note: Control Board v1 Units must update Adafruit's bootloader before first use. This only needs to be done once, but it must be done. Follow Adafruit's instructions here . DO NOT SKIP THIS!!! Note that some pictures show a version with a pressure / temperature sensor. This is no longer used and should not be included when building the board. The default coordinate system as defined by the IMU is shown below. Note that this is a right hand coordinate system. The red arrows define axes. Rotation about these axes is in the right hand direction (indicated by green arrows). Notice that the green arrows are on top of the red axis arrows, thus a \"left to right\" arrow is left to right across the top of the axis. The axis configuration can be changed to match any plane-aligned mounting position of the control board on a robot. See the BNO055 datasheet for more information. Components 1x Adafruit ItsyBitsy M4 1x Adafruit BNO055 Breakout STEMMA QT version can be substituted, however be aware that the pin order is different. Protoboard (2.54mm spacing; 24 by 18 holes; 5cm by 7cm) These can be found from many vendors Solid Core Wire (22AWG) Female Pin Headers (2.54mm pitch) Two 1x14 headers One 1x6 header One 1x4 header Note: These can be cut between pins carefully Male pin headers (2.54mm pitch) Two 1x8 headers One 1x4 header Two 1x2 headers (optional; for debug interface) Note: These can easily be cut / broken between pins. Two 10K resistors (through hole, 1/4 W) Wiring Diagram Assembly Instructions Solder header strips in the positions shown below. The female headers avoid soldering breakouts / dev boards directly to protoboard which allows easily replacing components if needed (or reusing them for other purposes later). After soldering, breakouts can be populated to make identifying pins easier. The crossed out header can be omitted as it was formerly used for the pressure / temp sensor (not used anymore). Wire the protoboard according to the wiring diagram. Note that the first image shows the pressure / temperature sensor (this should be omitted). The first photo also does not show the pullup resistors or debug headers. The second picture is closer to what a fully assembled Control Board v1 should look like. Hot glue can be used to ensure the resistor leads do not short anything. This photo is an older assembly that includes the temp / pressure sensor (should be omitted) and excludes the pullup resistors and debug headers (should be included). This photo shows the pullup resistors and debug headers Back side wiring","title":"Version 1"},{"location":"hardware/v1/#auv-control-board-v1","text":"Note: Control Board v1 Units must update Adafruit's bootloader before first use. This only needs to be done once, but it must be done. Follow Adafruit's instructions here . DO NOT SKIP THIS!!! Note that some pictures show a version with a pressure / temperature sensor. This is no longer used and should not be included when building the board. The default coordinate system as defined by the IMU is shown below. Note that this is a right hand coordinate system. The red arrows define axes. Rotation about these axes is in the right hand direction (indicated by green arrows). Notice that the green arrows are on top of the red axis arrows, thus a \"left to right\" arrow is left to right across the top of the axis. The axis configuration can be changed to match any plane-aligned mounting position of the control board on a robot. See the BNO055 datasheet for more information.","title":"AUV Control Board v1"},{"location":"hardware/v1/#components","text":"1x Adafruit ItsyBitsy M4 1x Adafruit BNO055 Breakout STEMMA QT version can be substituted, however be aware that the pin order is different. Protoboard (2.54mm spacing; 24 by 18 holes; 5cm by 7cm) These can be found from many vendors Solid Core Wire (22AWG) Female Pin Headers (2.54mm pitch) Two 1x14 headers One 1x6 header One 1x4 header Note: These can be cut between pins carefully Male pin headers (2.54mm pitch) Two 1x8 headers One 1x4 header Two 1x2 headers (optional; for debug interface) Note: These can easily be cut / broken between pins. Two 10K resistors (through hole, 1/4 W)","title":"Components"},{"location":"hardware/v1/#wiring-diagram","text":"","title":"Wiring Diagram"},{"location":"hardware/v1/#assembly-instructions","text":"Solder header strips in the positions shown below. The female headers avoid soldering breakouts / dev boards directly to protoboard which allows easily replacing components if needed (or reusing them for other purposes later). After soldering, breakouts can be populated to make identifying pins easier. The crossed out header can be omitted as it was formerly used for the pressure / temp sensor (not used anymore). Wire the protoboard according to the wiring diagram. Note that the first image shows the pressure / temperature sensor (this should be omitted). The first photo also does not show the pullup resistors or debug headers. The second picture is closer to what a fully assembled Control Board v1 should look like. Hot glue can be used to ensure the resistor leads do not short anything. This photo is an older assembly that includes the temp / pressure sensor (should be omitted) and excludes the pullup resistors and debug headers (should be included). This photo shows the pullup resistors and debug headers Back side wiring","title":"Assembly Instructions"},{"location":"hardware/v2/","text":"AUV Control Board v2 The default coordinate system as defined by the IMU is shown below. Note that this is a right hand coordinate system. The red arrows define axes. Rotation about these axes is in the right hand direction (indicated by green arrows). Notice that the green arrows are on top of the red axis arrows, thus a \"left to right\" arrow is left to right across the top of the axis. The axis configuration can be changed to match any plane-aligned mounting position of the control board on a robot. See the BNO055 datasheet for more information. Components 1x WeAct Studio Black Pill (w / STM32F411 notSTM32F401 ) Note: There are many counterfeit boards sold. These should be avoided. Adafruit Store Aliexpress (Offical WeAct Studio Store) 1x Adafruit BNO055 Breakout STEMMA QT version can be substituted, however be aware that the pin order is different. Protoboard (2.54mm spacing; 24 by 18 holes; 5cm by 7cm) These can be found from many vendors Solid Core Wire (22AWG) Female Pin Headers (2.54mm pitch) Two 1x20 headers One 1x6 header One 1x4 header Note: These can be cut between pins carefully Male pin headers (2.54mm pitch) Two 1x8 headers One 1x4 header Note: These can easily be cut / broken between pins. Resistors (through hole, 1/4 W) Two 10K resistors Two 10 Ohm resistors One 100 Ohm resistor One QBL8RGB60D0-2897 RGB LED Wiring Diagram Assembly Instructions Solder header strips in the positions shown below. The female headers avoid soldering breakouts / dev boards directly to protoboard which allows easily replacing components if needed (or reusing them for other purposes later). After soldering, breakouts can be populated to make identifying pins easier. The location of the LED is also indicated here. Wire the protoboard according to the wiring diagram.","title":"Version 2"},{"location":"hardware/v2/#auv-control-board-v2","text":"The default coordinate system as defined by the IMU is shown below. Note that this is a right hand coordinate system. The red arrows define axes. Rotation about these axes is in the right hand direction (indicated by green arrows). Notice that the green arrows are on top of the red axis arrows, thus a \"left to right\" arrow is left to right across the top of the axis. The axis configuration can be changed to match any plane-aligned mounting position of the control board on a robot. See the BNO055 datasheet for more information.","title":"AUV Control Board v2"},{"location":"hardware/v2/#components","text":"1x WeAct Studio Black Pill (w / STM32F411 notSTM32F401 ) Note: There are many counterfeit boards sold. These should be avoided. Adafruit Store Aliexpress (Offical WeAct Studio Store) 1x Adafruit BNO055 Breakout STEMMA QT version can be substituted, however be aware that the pin order is different. Protoboard (2.54mm spacing; 24 by 18 holes; 5cm by 7cm) These can be found from many vendors Solid Core Wire (22AWG) Female Pin Headers (2.54mm pitch) Two 1x20 headers One 1x6 header One 1x4 header Note: These can be cut between pins carefully Male pin headers (2.54mm pitch) Two 1x8 headers One 1x4 header Note: These can easily be cut / broken between pins. Resistors (through hole, 1/4 W) Two 10K resistors Two 10 Ohm resistors One 100 Ohm resistor One QBL8RGB60D0-2897 RGB LED","title":"Components"},{"location":"hardware/v2/#wiring-diagram","text":"","title":"Wiring Diagram"},{"location":"hardware/v2/#assembly-instructions","text":"Solder header strips in the positions shown below. The female headers avoid soldering breakouts / dev boards directly to protoboard which allows easily replacing components if needed (or reusing them for other purposes later). After soldering, breakouts can be populated to make identifying pins easier. The location of the LED is also indicated here. Wire the protoboard according to the wiring diagram.","title":"Assembly Instructions"},{"location":"user_guide/calibration/","text":"Sensor Calibration BNO055 (IMU) Calibration Calibration Script It is highly recommended to use the calibration script to calibrate the BNO055. Even if you are not using the python interface to the control board, the calibration script can be used to manage the calibration state. Launch the script by using the following command (note that python3 along with the pyserial library must be installed). Run this command in the iface folder. Replace [PORT] with the serial port of the control board. python3 launch.py example/bno055_calibrate.py -p [PORT] If a calibration is currently saved to the control board, the script will show that configuration and prompt you to erase it. You must erase any stored configuration before you can recalibrate the BNO055. Refusing to erase the calibration will result in the script exiting with no further action taken (this can be used as a way to view the currently saved calibration). If the above prompt is not shown, there is no calibration currently saved on the control board. Next, the script will prompt you to run either \"guided\" or \"manual\" calibration. Guided calibration provides instructions to use the BNO055's automatic calibration routine. This is recommended. Manual calibration allows a user to manually enter values for each calibration constant. Select guided mode. Next, instructions on the calibration process will be provided. Read and follow the instructions. Then press enter to begin calibration. The script will then periodically show you the calibration status of both sensor. Perform the described motions until the calibration status of both sensors shows as \"3\". When both values show \"3\", the script will automatically retrieve the calibration generated by the BNO055. It will be shown and you will be prompted to save the calibration to the control board. If you choose to save the calibration, it will be applied each time the control board resets or powers on until the calibration is erased or changed. This is generally what you will want to do . Choosing not to save the calibration will not alter the calibration state of the device until reset. The BNO055 will retain it's calibration and re-running the calibration script (guided) will result in the calibration immediately being \"good\" (all sensors show \"3\"). However, resetting the control board (or power cycling it) will cause the calibration to be lost. Details This section provides details on how BNO055 calibration works. If attempting to implement a calibration routine yourself instead of using the calibration script, this information will be useful. Otherwise, probably not. The BNO055 IMU is calibrated using a set of \"calibration constants\". These constants can be stored to the control board so that they are applied to the sensor when the control board powers up. If not calibration constants are stored on the control board, the IMU will instead run an automatic calibration routine in the background. This routine can be used to generate calibration constants for its sensors. When a set of calibration constants is saved to the control board, they will be applied to the BNO055 each time the control board is powered on or is reset. When the control board applies a saved calibration to the BNO055, this disables the BNO055's automatic calibration routine. Thus, it is necessary to erase any calibration stored on the control board before recalibrating the BNO055. Note that the act of saving a calibration to or erasing a calibration from the control board will reconfigure the BNO055. Thus, saving a calibration to the control board will disable the BNO055's calibration routine whereas erasing a calibration from the control board will enable the BNO055's calibration routine. This means that a power cycle of the control board is not required after saving / erasing a calibration. There are two places calibration constants could be located Saved on the control board (referred to as the stored calibration constants) On the BNO055 (referred to as the live calibration constants) The stored calibration constants are written to the BNO055 when the control board starts. Thus, if any constants are saved, the live calibration constants will be the same as the stored calibration constants. However, if there are no stored calibration constants (they are erased or have never been stored), the live calibration constants will be generated by the BNO055's automatic calibration routine. The live calibration constants are only valid when the BNO055's calibration status register indicates a status code of 3 for each sensor in use (accelerometer and gyroscope). The control board provides commands to manage both the stored calibration constants as well as read the live calibration constants and calibration status directly from the BNO055. The python interface scripts provide functions to do so as well. The read_stored_bno055_calibration , erase_stored_bno055_calibration , and store_bno055_calibration functions manage the stored calibration constants. The bno055_read_calibration and bno055_read_calibration_status functions will read the live calibration constants and the calibration status form the BNO055. Erase any stored calibration. This will reset the IMU without applying any calibration. Thus, the live calibration constants will be generated by the BNO055's calibration routine. Reset the BNO055 (this is done via command to the control board). This will ensure that any calibration already generated is erased. Read the BNO055's calibration status register. Bitwise operations can be used to determine the calibration status of individual sensors. Each sensor is 2-bits of data. See the BNO055 datasheet for more information on the CALIB_STAT register. For the control board, only the accelerometer (ACC) and gyroscope (GYR) calibration status is relevant. Each of these will be a value from 0-3. A value of 3 indicates a good calibration. Perform the required operations described in the BNO055 datasheet for gyro and accelerometer calibration. Once the BNO055's calibration status reads 3 for both sensors, the calibration is complete. Read the live calibration constants from the BNO055 Store the calibration constants read in the previous step to the control board. The BNO055 will be reset, but the calibration will be applied. This same calibration that was stored to the control board will be applied to the BNO055 each time the control board is reset (or powered on). When to Re-Calibrate You should always recalibrate if you change the physical sensor in use on the control board (swap a different BNO055) or if you are using a different control board. Calibration constants will vary between sensors, thus constants from one control board cannot be used on another. Likewise, if you change the sensor on your control board the old constants will no longer be valid. Additionally, significant operating environment changes (pressure, temperature, elevation, etc) can cause enough of a change in sensor behavior to require re-calibration. Similarly, a change of the position of the sensor in the vehicle could require re-calibration. It is recommended to recalibrate if any such changes seem to result in degradation of sensor performance. If the BNO055 axis configuration used by your vehicle changes, the BNO055 should be recalibrated. MS5837 (Depth Sensor) Calibration The depth sensor is really just a pressure & temperature sensor. The depth is calculated using two \"constant\" values: the density of the water the vehicle is operating in and the atmospheric pressure at the surface of the water. For the MS5837 atmospheric pressure must be provided in Pascals and the fluid density must be provided in kg / m^3. The default values are Atmospheric Pressure: 101325 Pa Fluid Density: 997 kg / m^3 These default values are applied on control board reset / power on. MS5837 calibration is not persistent (it cannot be stored on the control board like the BNO055 can). These values can be adjusted using a command sent to the control board or by using the python interface script. The fluid density must be provided by the user (there is no good way to experimentally determine this on the vehicle). However, the pressure can be measured while the vehicle (and sensor) are in air at / above the surface. The example interface script ms5837_calibration.py demonstrates calibration of the depth sensor. Again, since the calibration is not persistent it must be applied by command / interface script function each time the device is started. Note that depth sensor calibration is not persistent due to this being of limited use. The atmospheric conditions the vehicle is operating in will change with time. Thus, any persistent configuration would not be trusted and would be frequently overwritten.","title":"Sensor Calibration"},{"location":"user_guide/calibration/#sensor-calibration","text":"","title":"Sensor Calibration"},{"location":"user_guide/calibration/#bno055-imu-calibration","text":"","title":"BNO055 (IMU) Calibration"},{"location":"user_guide/calibration/#calibration-script","text":"It is highly recommended to use the calibration script to calibrate the BNO055. Even if you are not using the python interface to the control board, the calibration script can be used to manage the calibration state. Launch the script by using the following command (note that python3 along with the pyserial library must be installed). Run this command in the iface folder. Replace [PORT] with the serial port of the control board. python3 launch.py example/bno055_calibrate.py -p [PORT] If a calibration is currently saved to the control board, the script will show that configuration and prompt you to erase it. You must erase any stored configuration before you can recalibrate the BNO055. Refusing to erase the calibration will result in the script exiting with no further action taken (this can be used as a way to view the currently saved calibration). If the above prompt is not shown, there is no calibration currently saved on the control board. Next, the script will prompt you to run either \"guided\" or \"manual\" calibration. Guided calibration provides instructions to use the BNO055's automatic calibration routine. This is recommended. Manual calibration allows a user to manually enter values for each calibration constant. Select guided mode. Next, instructions on the calibration process will be provided. Read and follow the instructions. Then press enter to begin calibration. The script will then periodically show you the calibration status of both sensor. Perform the described motions until the calibration status of both sensors shows as \"3\". When both values show \"3\", the script will automatically retrieve the calibration generated by the BNO055. It will be shown and you will be prompted to save the calibration to the control board. If you choose to save the calibration, it will be applied each time the control board resets or powers on until the calibration is erased or changed. This is generally what you will want to do . Choosing not to save the calibration will not alter the calibration state of the device until reset. The BNO055 will retain it's calibration and re-running the calibration script (guided) will result in the calibration immediately being \"good\" (all sensors show \"3\"). However, resetting the control board (or power cycling it) will cause the calibration to be lost.","title":"Calibration Script"},{"location":"user_guide/calibration/#details","text":"This section provides details on how BNO055 calibration works. If attempting to implement a calibration routine yourself instead of using the calibration script, this information will be useful. Otherwise, probably not. The BNO055 IMU is calibrated using a set of \"calibration constants\". These constants can be stored to the control board so that they are applied to the sensor when the control board powers up. If not calibration constants are stored on the control board, the IMU will instead run an automatic calibration routine in the background. This routine can be used to generate calibration constants for its sensors. When a set of calibration constants is saved to the control board, they will be applied to the BNO055 each time the control board is powered on or is reset. When the control board applies a saved calibration to the BNO055, this disables the BNO055's automatic calibration routine. Thus, it is necessary to erase any calibration stored on the control board before recalibrating the BNO055. Note that the act of saving a calibration to or erasing a calibration from the control board will reconfigure the BNO055. Thus, saving a calibration to the control board will disable the BNO055's calibration routine whereas erasing a calibration from the control board will enable the BNO055's calibration routine. This means that a power cycle of the control board is not required after saving / erasing a calibration. There are two places calibration constants could be located Saved on the control board (referred to as the stored calibration constants) On the BNO055 (referred to as the live calibration constants) The stored calibration constants are written to the BNO055 when the control board starts. Thus, if any constants are saved, the live calibration constants will be the same as the stored calibration constants. However, if there are no stored calibration constants (they are erased or have never been stored), the live calibration constants will be generated by the BNO055's automatic calibration routine. The live calibration constants are only valid when the BNO055's calibration status register indicates a status code of 3 for each sensor in use (accelerometer and gyroscope). The control board provides commands to manage both the stored calibration constants as well as read the live calibration constants and calibration status directly from the BNO055. The python interface scripts provide functions to do so as well. The read_stored_bno055_calibration , erase_stored_bno055_calibration , and store_bno055_calibration functions manage the stored calibration constants. The bno055_read_calibration and bno055_read_calibration_status functions will read the live calibration constants and the calibration status form the BNO055. Erase any stored calibration. This will reset the IMU without applying any calibration. Thus, the live calibration constants will be generated by the BNO055's calibration routine. Reset the BNO055 (this is done via command to the control board). This will ensure that any calibration already generated is erased. Read the BNO055's calibration status register. Bitwise operations can be used to determine the calibration status of individual sensors. Each sensor is 2-bits of data. See the BNO055 datasheet for more information on the CALIB_STAT register. For the control board, only the accelerometer (ACC) and gyroscope (GYR) calibration status is relevant. Each of these will be a value from 0-3. A value of 3 indicates a good calibration. Perform the required operations described in the BNO055 datasheet for gyro and accelerometer calibration. Once the BNO055's calibration status reads 3 for both sensors, the calibration is complete. Read the live calibration constants from the BNO055 Store the calibration constants read in the previous step to the control board. The BNO055 will be reset, but the calibration will be applied. This same calibration that was stored to the control board will be applied to the BNO055 each time the control board is reset (or powered on).","title":"Details"},{"location":"user_guide/calibration/#when-to-re-calibrate","text":"You should always recalibrate if you change the physical sensor in use on the control board (swap a different BNO055) or if you are using a different control board. Calibration constants will vary between sensors, thus constants from one control board cannot be used on another. Likewise, if you change the sensor on your control board the old constants will no longer be valid. Additionally, significant operating environment changes (pressure, temperature, elevation, etc) can cause enough of a change in sensor behavior to require re-calibration. Similarly, a change of the position of the sensor in the vehicle could require re-calibration. It is recommended to recalibrate if any such changes seem to result in degradation of sensor performance. If the BNO055 axis configuration used by your vehicle changes, the BNO055 should be recalibrated.","title":"When to Re-Calibrate"},{"location":"user_guide/calibration/#ms5837-depth-sensor-calibration","text":"The depth sensor is really just a pressure & temperature sensor. The depth is calculated using two \"constant\" values: the density of the water the vehicle is operating in and the atmospheric pressure at the surface of the water. For the MS5837 atmospheric pressure must be provided in Pascals and the fluid density must be provided in kg / m^3. The default values are Atmospheric Pressure: 101325 Pa Fluid Density: 997 kg / m^3 These default values are applied on control board reset / power on. MS5837 calibration is not persistent (it cannot be stored on the control board like the BNO055 can). These values can be adjusted using a command sent to the control board or by using the python interface script. The fluid density must be provided by the user (there is no good way to experimentally determine this on the vehicle). However, the pressure can be measured while the vehicle (and sensor) are in air at / above the surface. The example interface script ms5837_calibration.py demonstrates calibration of the depth sensor. Again, since the calibration is not persistent it must be applied by command / interface script function each time the device is started. Note that depth sensor calibration is not persistent due to this being of limited use. The atmospheric conditions the vehicle is operating in will change with time. Thus, any persistent configuration would not be trusted and would be frequently overwritten.","title":"MS5837 (Depth Sensor) Calibration"},{"location":"user_guide/comm_protocol/","text":"Communication Protocol Communication with the control board relies on sending messages between the control board and PC. This section focuses on how messages are sent, not what messages are sent. Hardware Communication Layer Messages are sent to the control board over the MCU's builtin USB port. The control board acts as a USB ACM CDC device. In practice, this means that it shows up as a serial (UART) port on the computer it is connected to. However, baud rate settings are irrelevant (and changing baud rates has no effect). As such, messages are sent to / received from the control board using \"UART\" with an undefined baud rate*. It is still necessary to set a baud rate when opening a UART port (as that information is provided to the device on the other side), but the rate is unused. Additionally, it is expected to operate in 8N1 data mode (8 data bits, no parity, 1 stop bit). A stream of data is sent to the control board over this port. This data is interpreted as described below. * NOTE: The baud rate 1200 is an exception. Openening then closing the port at this baud rate is used to trigger the control board to reboot to its bootloader. Do not use 1200 baud! Message Format and Construction The messages sent to / received from the control board have a specific format. Each message transfers a raw set of bytes (unsigned byte array). This set of bytes is the \"payload data\" of the message. The \"payload data\" is the data that is actually being send via the message. Messages are limited to a maximum payload size of 96 bytes. To be able to identify what data is part of a single message, it is necessary to add some additional information around the payload. The control board uses a special byte to indicate the start of a message ( START_BYTE ) and another one to identify the end of a message ( END_BYTE ). Since the payload could itself contain a start or end byte, there is also an escape byte ( ESCAPE_BYTE ) used to escape a START_BYTE , END_BYTE , or an ESCAPE_BYTE in the payload. START_BYTE becomes ESCAPE_BYTE , START_BYTE END_BYTE becomes ESCAPE_BYTE , END_BYTE ESCAPE_BYTE becomes ESCAPE_BYTE , ESCAPE_BYTE This is similar to escaping a quote in a string using a backslash. For the control board: START_BYTE = 253 (unsigned 8-bit) = -3 (signed 8-bit) END_BYTE = 254 (unsigned 8-bit) = -2 (signed 8-bit) ESCAPE_BYTE = 255 (unsigned 8-bit) = -1 (signed 8-bit) In addition to the control bytes and the payload, each message contains two other pieces of information: First, each message includes a prepended* ID number (16-bit unsigned big-endian integer). These ID numbers are required to be unique only in one direction . This means that two messages sent from the PC to the control board cannot have the same id. Likewise, two messages sent from the control board to the PC cannot have the same id. However, a message sent from PC to control board can have the same id as another message sent from control board to PC. Note that in practice, eventually (after 65535 messages sent one way) ID numbers must eventually repeat. This is acceptable as long as no two messages that are sent \"close together\" have the same id. Effectively, no two \"active\" messages in a single direction may have the same ID (what \"active\" means can vary, but in practice by the time 60,000 messages have been sent, old messages can be assumed inactive). When sending messages from PC to control board, it is required to restrict message ID between 0 and 59999 (inclusive). This is due to how the simulator is implemented. IDs 60000-65535 are reserved for simulator use. Note that IDs generated by the control board will not be restricted to this range. Second, each message has a CRC appended* to it. This is a 16-bit CRC using the CCITT-FALSE algorithm. It is appended* to the message big endian. The CRC is calculated on the concatenation of the message id bytes and the raw (unescaped) payload bytes. Just like the payload data, when prepending or appending message id or crc, it is necessary to escape bytes that are equal to control bytes (start, end, escape). * Note that append and prepend still mean contained between control (start and end) bytes. This results in message construction looking like the following (the \"payload\" is the raw message being sent).","title":"Communication Protocol"},{"location":"user_guide/comm_protocol/#communication-protocol","text":"Communication with the control board relies on sending messages between the control board and PC. This section focuses on how messages are sent, not what messages are sent.","title":"Communication Protocol"},{"location":"user_guide/comm_protocol/#hardware-communication-layer","text":"Messages are sent to the control board over the MCU's builtin USB port. The control board acts as a USB ACM CDC device. In practice, this means that it shows up as a serial (UART) port on the computer it is connected to. However, baud rate settings are irrelevant (and changing baud rates has no effect). As such, messages are sent to / received from the control board using \"UART\" with an undefined baud rate*. It is still necessary to set a baud rate when opening a UART port (as that information is provided to the device on the other side), but the rate is unused. Additionally, it is expected to operate in 8N1 data mode (8 data bits, no parity, 1 stop bit). A stream of data is sent to the control board over this port. This data is interpreted as described below. * NOTE: The baud rate 1200 is an exception. Openening then closing the port at this baud rate is used to trigger the control board to reboot to its bootloader. Do not use 1200 baud!","title":"Hardware Communication Layer"},{"location":"user_guide/comm_protocol/#message-format-and-construction","text":"The messages sent to / received from the control board have a specific format. Each message transfers a raw set of bytes (unsigned byte array). This set of bytes is the \"payload data\" of the message. The \"payload data\" is the data that is actually being send via the message. Messages are limited to a maximum payload size of 96 bytes. To be able to identify what data is part of a single message, it is necessary to add some additional information around the payload. The control board uses a special byte to indicate the start of a message ( START_BYTE ) and another one to identify the end of a message ( END_BYTE ). Since the payload could itself contain a start or end byte, there is also an escape byte ( ESCAPE_BYTE ) used to escape a START_BYTE , END_BYTE , or an ESCAPE_BYTE in the payload. START_BYTE becomes ESCAPE_BYTE , START_BYTE END_BYTE becomes ESCAPE_BYTE , END_BYTE ESCAPE_BYTE becomes ESCAPE_BYTE , ESCAPE_BYTE This is similar to escaping a quote in a string using a backslash. For the control board: START_BYTE = 253 (unsigned 8-bit) = -3 (signed 8-bit) END_BYTE = 254 (unsigned 8-bit) = -2 (signed 8-bit) ESCAPE_BYTE = 255 (unsigned 8-bit) = -1 (signed 8-bit) In addition to the control bytes and the payload, each message contains two other pieces of information: First, each message includes a prepended* ID number (16-bit unsigned big-endian integer). These ID numbers are required to be unique only in one direction . This means that two messages sent from the PC to the control board cannot have the same id. Likewise, two messages sent from the control board to the PC cannot have the same id. However, a message sent from PC to control board can have the same id as another message sent from control board to PC. Note that in practice, eventually (after 65535 messages sent one way) ID numbers must eventually repeat. This is acceptable as long as no two messages that are sent \"close together\" have the same id. Effectively, no two \"active\" messages in a single direction may have the same ID (what \"active\" means can vary, but in practice by the time 60,000 messages have been sent, old messages can be assumed inactive). When sending messages from PC to control board, it is required to restrict message ID between 0 and 59999 (inclusive). This is due to how the simulator is implemented. IDs 60000-65535 are reserved for simulator use. Note that IDs generated by the control board will not be restricted to this range. Second, each message has a CRC appended* to it. This is a 16-bit CRC using the CCITT-FALSE algorithm. It is appended* to the message big endian. The CRC is calculated on the concatenation of the message id bytes and the raw (unescaped) payload bytes. Just like the payload data, when prepending or appending message id or crc, it is necessary to escape bytes that are equal to control bytes (start, end, escape). * Note that append and prepend still mean contained between control (start and end) bytes. This results in message construction looking like the following (the \"payload\" is the raw message being sent).","title":"Message Format and Construction"},{"location":"user_guide/general_use/","text":"Using Control Board TODO: This page is an outline. Update with details / actual contents. General Procedure Connecting to Control Board System configuration (motor matrix, thruster inversions, thruster PWM, reldof parameters) Sensor configuration Validating sensor connectivity Modes of operation & setting speed Motor Watchdog Reading Sensor data Example program using python interface script LED Indicator Info Calibrate Sensors Custom interface code instead of python iface Many users will want to build their own interface. Python iface is a reference / an easy place to start, but not required You just need to implement communication with the control board as described in comm protocol and messages pages Note that users doing so may wish to read the section on SimCB and simulator too as supporting both TCP and UART in implementations can be useful.","title":"Using Control Board"},{"location":"user_guide/general_use/#using-control-board","text":"TODO: This page is an outline. Update with details / actual contents. General Procedure Connecting to Control Board System configuration (motor matrix, thruster inversions, thruster PWM, reldof parameters) Sensor configuration Validating sensor connectivity Modes of operation & setting speed Motor Watchdog Reading Sensor data Example program using python interface script LED Indicator Info Calibrate Sensors Custom interface code instead of python iface Many users will want to build their own interface. Python iface is a reference / an easy place to start, but not required You just need to implement communication with the control board as described in comm protocol and messages pages Note that users doing so may wish to read the section on SimCB and simulator too as supporting both TCP and UART in implementations can be useful.","title":"Using Control Board"},{"location":"user_guide/messages/","text":"Messages This section describes what specific messages are sent to / received from the control board and what they do / mean. This does not address how messages are constructed or sent. For such information, see Communication Protocol . Note: The Communication Protocol page uses the term \"payload\" for the data being transferred and \"message\" for the formatted / fully constructed set of data. Here, what we refer to as \"messages\" are actually the \"payload\" data, not the constructed data. Message Definition Conventions In the following sections, the following standard is used to describe message contents: Each message's contents are shown as a comma separated list of bytes. Each comma separated item is a single byte, with one exception for parameters (as described below) Parameters are shown inside square brackets. Parameters represent a value that will be described in more detail below the message structure information. Parameters can be multiple bytes (even though they take only one entry between commas). ASCII characters are shown in single quotes. These are single byte unsigned ASCII characters. Numbers are not contained within any symbols. Numbers may be in hex (prefix 0x), binary (prefix 0b), or decimal (no prefix). Types of Messages Commands : Messages instructing an action be taken. These messages must be acknowledged upon receipt. The acknowledgement typically contains no data. Sent from PC to control board. Queries : Messages requesting information. These messages must be acknowledged upon receipt. The acknowledgement will contain the requested information. Sent from PC to control board. Acknowledgements : A very specific type of message acknowledging receipt of another message (with an error code and optional data). Sent from control board to PC. Status Messages : Unprompted messages containing information about state / data changes. Sent from control board to PC. Commands and Queries Motor motion commands Raw Speed Set Used to set motor speeds in RAW mode. This command has the following format. 'R', 'A', 'W', [speed_1], [speed_2], [speed_3], [speed_4], [speed_5], [speed_6], [speed_7], [speed_8] [speed_n] : The speed of thruster n from -1.0 to 1.0. A 32-bit float (little endian). This message will be acknowledged. The acknowledge message will contain no result data. Local Speed Set Used to set motor speeds in LOCAL mode. This command has the following format 'L', 'O', 'C', 'A', 'L', [x], [y], [z], [xrot], [yrot], [zrot] [x] , [y] , [z] , [xrot] , [yrot] , [zrot] : Speed for each DoF relative to the robot -1.0 to 1.0. A 32-bit float (little endian). This message will be acknowledged. The acknowledge message will contain no result data. Global Speed Set Used to set motor speeds in GLOBAL mode. This command has the following format 'G', 'L', 'O', 'B', 'A', 'L', [x], [y], [z], [pitch_spd], [roll_spd], [yaw_spd] [x] , [y] , [z] : Speed for each \"world-relative\" (pitch and roll compensated) DoF -1.0 to 1.0. 32-bit float (little endian). [pitch_spd] , [roll_spd] , [yaw_spd] : Rate of change of vehicle pitch, roll, and yaw -1.0 to 1.0. This message will be acknowledged. The acknowledge message will contain no result data. Note that if the IMU is not working properly, this command will be acknowledged with the \"Invalid Command\" error code. This can occur if the axis config of the IMU is changed immediately before issuing this command. Orientation Hold Speed Set (Variant 1) Used to set motor speeds in ORIENTATION_HOLD mode using a speed for yaw. This command has the following format 'O', 'H', 'O', 'L', 'D', '1', [x], [y], [z], [yaw_spd], [target_pitch], [target_roll] Each value is a 32-bit float little endian. Pitch and roll are euler angles (in degrees). These are intrinsic euler angles (z-x'-y'' convention per the control board's coordinate system). x, y, z, and yaw_spd are x, y, z, and yaw_spd just as in global mode. This message will be acknowledged with no data. Note that if the IMU or depth sensor is not working properly, this command will be acknowledged with the \"Invalid Command\" error code. This can occur if the axis config of the IMU is changed immediately before issuing this command. Orientation Hold Speed Set (Variant 2) Used to set motor speeds in ORIENTATION_HOLD mode using a PID to maintain a target yaw. This command has the following format 'O', 'H', 'O', 'L', 'D', '2', [x], [y], [z], [target_pitch], [target_roll], [target_yaw] Each value is a 32-bit float little endian. Target Pitch, roll, and yaw are euler angles (in degrees). These are intrinsic euler angles (z-x'-y'' convention per the control board's coordinate system). x, y, and z are speeds in the x, y, and z DoFs the same as in GLOBAL mode. This message will be acknowledged with no data. Note that if the IMU or depth sensor is not working properly, this command will be acknowledged with the \"Invalid Command\" error code. This can occur if the axis config of the IMU is changed immediately before issuing this command. Stability Assist Speed Set (Variant 1) Used to set motor speeds in STABILITY_ASSIST mode using a speed for yaw. This command has the following format 'S', 'A', 'S', 'S', 'I', 'S', 'T', '1', [x], [y], [yaw_spd], [target_pitch], [target_roll], [target_depth] Each value is a 32-bit float little endian. Pitch and roll are euler angles (in degrees). These are intrinsic euler angles (z-x'-y'' convention per the control board's coordinate system). Depth is in meters where negative numbers are below the surface. x, y, and yaw_spd are x, y, and yaw_spd just as in global mode. This message will be acknowledged with no data. Note that if the IMU or depth sensor is not working properly, this command will be acknowledged with the \"Invalid Command\" error code. This can occur if the axis config of the IMU is changed immediately before issuing this command. Stability Assist Speed Set (Variant 2) Used to set motor speeds in STABILITY_ASSIST mode using a PID to maintain a target yaw. This command has the following format 'S', 'A', 'S', 'S', 'I', 'S', 'T', '2', [x], [y], [target_pitch], [target_roll], [target_yaw], [target_depth] Each value is a 32-bit float little endian. Target Pitch, roll, and yaw are euler angles (in degrees). These are intrinsic euler angles (z-x'-y'' convention per the control board's coordinate system). Depth is in meters where negative numbers are below the surface. x and y are speeds in the x and y DoFs the same as in GLOBAL mode. This message will be acknowledged with no data. Note that if the IMU or depth sensor is not working properly, this command will be acknowledged with the \"Invalid Command\" error code. This can occur if the axis config of the IMU is changed immediately before issuing this command. Feed Motor Watchdog Used to feed the motor watchdog so it does not kill the motors. This command has the following format 'W', 'D', 'G', 'F' This message will be acknowledged. The acknowledge message will contain no result data. Vehicle Configuration Commands Motor Matrix Set Motor matrix set command is used to set a single row of the motor matrix. It has the following format 'M', 'M', 'A', 'T', 'S', [thruster_num], [x], [y], [z], [pitch], [roll], [yaw] [thruster_num] : A single byte who'se unsigned value is the thruster number the row data should be set for (1-8). [x] , [y] , [z] , [pitch] , [roll] , [yaw] : Columns of the motor matrix row being set. Each is a 32-bit float (little endian). This message will be acknowledged. The acknowledge message will contain no result data. Motor Matrix Update Motor matrix update command is used to inform the control board the motor matrix has changed. Causes the control board to perform some calculations with the new motor matrix. This should be sent after writing all rows of the motor matrix that should change using the motor matrix set command. The motor matrix update command has the following format 'M', 'M', 'A', 'T', 'U' This message will be acknowledged. The acknowledge message will contain no result data. Thruster PWM Parameter Config Configure PWM settings for thrusters. 'T', 'P', 'W', 'M', [pwm_period], [pwm_zero], [pwm_range] Each value is an unsigned 16-bit integer (little endian). pwm_period is the PWM signal period in microseconds (determines PWM frequency / update rate for ESCs). pwm_zero is the pulse width for zero speed in microseconds (typically 1500). pwm_range is the deviation from zero to achieve max speed (when added) or min speed (when subtracted) such that the pulse width pwm_zero + pwm_range microseconds is full forward speed and the pulse width pwm_zero - pwm_range microseconds is full reverse speed. This message will be acknowledged. The acknowledge message will contain no result data. Thruster Inversion Set Thruster inversion set command is used to invert the positive and negative direction of thrusters. It has the following format 'T', 'I', 'N', 'V', [inv] [inv] : A single byte where each bit represents the inversion status of a thruster. The MSB (bit 7) corresponds to thruster 8 and the LSB corresponds to thruster 1 (bit + 1 = thruster). A bit value of 1 means the thruster is inverted. A bit value of 0 means the thruster is not inverted. This message will be acknowledged. The acknowledge message will contain no result data. Relative DoF Speed Set Used to set relative speeds of motion in each DoF. There are two groups: linear (x, y, z) and angular (xrot, yrot, zrot). Within each group, use 1.0 for the fastest DoF. Other DoFs in the group are percentages of the fastest speed (from 0.0 to 1.0). This message has the following format 'R', 'E', 'L', 'D', 'O', 'F', [x], [y], [z], [xrot], [yrot], [zrot] [x] , [y] , [z] , [xrot] , [yrot] , [zrot] : 32-bit little endian floats. This message will be acknowledged. The acknowledge message will contain no result data. PID Tune Command Used to tune PID controllers. The command has the following format 'P', 'I', 'D', 'T', 'N', [which], [kp], [ki], [kd], [limit], [invert] [which] indicates which PID to tune ('X' = xrot, 'Y' = yrot, 'Z' = zrot, 'D' = depth hold). [kp] , [ki] , [kd] are proportional, integral, derivative, and feed-forward gains (32-bit float little endian). [limit] Is the PID controller's max output (limits max speed in the controlled DoF). Must be between 0.0 and 1.0. 32-bit float little endian. [invert] Set to one to invert PID output. Zero otherwise. Sensor Commands and Queries Sensor Status Query Check which IMU and depth sensor is currently in use 'S', 'S', 'T', 'A', 'T' This message will be acknowledged. If acknowledged with no error, the response will contain data in the following format [which_imu], [which_depth] [which_imu] : Single byte indicating which IMU is in use - No IMU: 0 - Simulated IMU (under simulator hijack): 1 - BNO055 IMU: 2 [which_depth] : Single byte indicating which depth sensor is in use - No Depth sensor: 0 - Simulated depth sensor (under simulator hijack): 1 - MS5837 Depth sensor: 2 IMU Read Reads IMU data once. 'I', 'M', 'U', 'R' This message will be acknowledged. If acknowledged with no error, the response will contain data in the following format. Note that this is the same format as the data contained within the BNO055 data status message. [quat_w], [quat_x], [quat_y], [quat_z], [accum_pitch], [accum_roll], [accum_yaw] Each value is a 32-bit float, little endian. quat_ values are components of the orientation quaternion. accum_ values are accumulated euler angles. IMU Raw Read Reads raw IMU data once. 'I', 'M', 'U', 'W' This message will be acknowledged. If acknowledged with no error, the response will contain data in the following format. Note that this is the same format as the data contained within the BNO055 data status message. [accel_x], [accel_y], [accel_z], [gyro_x], [gyro_y], [gyro_z] Each value is a 32-bit float, little endian. IMU Periodic Read Used to enable / disable periodic reading of IMU data. This will only impact data being sent from control board to the pc. The control board itself will continue to read and use IMU data. 'I', 'M', 'U', 'P', [enable] [enable] is an 8-bit integer with a value of either 1 or 0. If 1, reading data periodically is enabled. If 0, reading data periodically is disabled. This message will be acknowledged. The acknowledge message will contain no result data. Depth Read Reads depth sensor data once. 'D', 'E', 'P', 'T', 'H', 'R' This message will be acknowledged. If acknowledged with no error, the response will contain data in the following format. Note that this is the same format as the data contained within the MS5837 data status message. [depth_m], [pressure_pa], [temp_c] depth_m is a 32-bit float, little endian (meters below surface). pressure_pa is a 32-bit float, little endian (measured pressure in Pa). temp_c is a 32-bit float, little endian (temperature of air / water). Depth Periodic Read Used to enable / disable periodic reading of MS5837 data. This will only impact data being sent from control board to the pc. The control board itself will continue to read and use depth sensor data. 'D', 'E', 'P', 'T', 'G', 'P', [enable] [enable] is an 8-bit integer with a value of either 1 or 0. If 1, reading data periodically is enabled. If 0, reading data periodically is disabled. This message will be acknowledged. The acknowledge message will contain no result data. BNO055 IMU Configuration BNO055 IMU Axis Configure Command Used to configure the BNO055 IMU's axis orientation. Note: This will also reset the accumulated euler angles to zero . 'B', 'N', 'O', '0', '5', '5', 'A', [config] [config] : A single byte. The value of this byte is between 0 and 7 (inclusive) representing on of the BNO055 axis configs (P0 to P7) as described in the BNO055 datasheet. Note: Changing the axis config changes IMU mode. Thus, there will be a brief time afterwards where the IMU may report zeros for all data. This message will be acknowledged. The acknowledge message will contain no result data. Note that if the BNO055 is not the active IMU (see sensor status query), this will be acknowledged using the INVALID_CMD error code. Save BNO055 Stored Calibration Command This command is used to store a set of calibration constants for the BNO055 to the control board. This will write the \"stored calibration constants\". This command will also cause the IMU to be reconfigured (this can take some time, so acknowledgements for this command may take longer than most). The command has the following format 'S', 'C', 'B', 'N', 'O', '0', '5', '5', 'S', [accel_offset_x], [accel_offset_y], [accel_offset_z], [accel_radius], [gyro_offset_x], [gyro_offset_y], [gyro_offset_z] Each value is a signed 16-bit integer. The meaning of each value is described in the BNO055 datasheet. This message will be acknowledged. The acknowledge message will contain no result data. Note that if the BNO055 is not the active IMU (see sensor status query), this will be acknowledged using the INVALID_CMD error code. Erase BNO055 Stored Calibration Command This command is used to erase calibration constants for the BNO055 from the control board. This will erase the \"stored calibration constants\". This command will also cause the IMU to be reconfigured (this can take some time, so acknowledgements for this command may take longer than most). The command has the following format 'S', 'C', 'B', 'N', 'O', '0', '5', '5', 'E' This message will be acknowledged. The acknowledge message will contain no result data. Note that if the BNO055 is not the active IMU (see sensor status query), this will be acknowledged using the INVALID_CMD error code. Reset BNO055 Command This command is used to reset / reconfigure the BNO055. This is typically used to clear any auto generated calibration constants. The command has the following format 'B', 'N', 'O', '0', '5', '5', 'R', 'S', 'T' This message will be acknowledged. The acknowledge message will contain no result data. Note that if the BNO055 is not the active IMU (see sensor status query), this will be acknowledged using the INVALID_CMD error code. Read BNO055 Stored Calibration Query This command is used to read a set of calibration constants for the BNO055 from the control board. This will read the \"stored calibration constants\". The command has the following format 'S', 'C', 'B', 'N', 'O', '0', '5', '5', 'R' This message will be acknowledged. If acknowledged with no error, the response will contain data in the following format. [valid], [accel_offset_x], [accel_offset_y], [accel_offset_z], [accel_radius], [gyro_offset_x], [gyro_offset_y], [gyro_offset_z] valid is an 8-bit integer. A value of 0 indicates that no calibration is stored on the control board (other values have no meaning). A value of 1 indicates that a calibration is stored (other values are that calibration). All other values in the acknowledge data are signed 16-bit integers. The meaning of these integers is described in the BNO055 datasheet. Read BNO055 Live Calibration Status Query This command is used to read the status of the BNO055's calibration routine. Note that this reads the value directly from the BNO055. This value is meaningless if a calibration was manually applied to the sensor. Thus, this is only useful if any \"stored calibration constants\" are first erased. The command has the following format 'B', 'N', 'O', '0', '5', '5', 'C', 'S' This message will be acknowledged. Note that if the IMU is not working properly, this command will be acknowledged with the \"Invalid Command\" error code. If acknowledged with no error, the response will contain data in the following format. [status] status is an 8-bit integer. The value of status is the value of the BNO055's CALIB_STAT register. The meaning of this number is described in the BNO055 datasheet. Note that if the BNO055 is not the active IMU (see sensor status query), this will be acknowledged using the INVALID_CMD error code. Read BNO055 Live Calibration Values Query This command is used to read a set of calibration constants from the BNO055. This will read the \"live calibration constants\" directly from the BNO055. Note that the calibration constants are only valid if the calibration status from the BNO055 is 3 for the accelerometer and gyroscope. The command has the following format 'B', 'N', 'O', '0', '5', '5', 'C', 'V' This message will be acknowledged. Note that if the IMU is not working properly, this command will be acknowledged with the \"Invalid Command\" error code. If acknowledged with no error, the response will contain data in the following format. [accel_offset_x], [accel_offset_y], [accel_offset_z], [accel_radius], [gyro_offset_x], [gyro_offset_y], [gyro_offset_z] All values in the acknowledge data are signed 16-bit integers. The meaning of these integers is described in the BNO055 datasheet. Note that if the BNO055 is not the active IMU (see sensor status query), this will be acknowledged using the INVALID_CMD error code. MS5837 Depth Sensor Configuration Read MS5837 Calibration Query This command is used to read the values of the MS5837 calibration constants. The command has the following format 'M', 'S', '5', '8', '3', '7', 'C', 'A', 'L', 'G' This message will be acknowledged. If acknowledged with no error, the response will contain data in the following format. [atm_pressure], [fluid_density] Both values are 32-bit little endian floats. Write MS5837 Calibration Command This command is used to write the values of the MS5837 calibration constants. The command has the following format 'M', 'S', '5', '8', '3', '7', 'C', 'A', 'L', 'S', [atm_pressure], [fluid_density] Both values are 32-bit little endian floats. This message will be acknowledged. The acknowledge message will contain no result data. Misc Commands and Queries Reset Command This command is used to rest the control board itself. This will reset the microcontroller on the control board, thus the USB device will disconnect and reconnect (note that if your program still holds the port when this happens, the USB device will likely be assigned a different port number). 'R', 'E', 'S', 'E', 'T', 0x0D, 0x1E This message is not acknowledged. Last Reset Cause Query Get error code for last system reset cause of the control board. Generally not useful for end users, except for reporting errors. Mainly a debug / development tool. See error codes in firmware source debug.h . 'R', 'S', 'T', 'W', 'H', 'Y' This message will be acknowledged. If acknowledged with no error, the response will contain data in the following format. [error_code] error_code is a 32-bit integer (signed), little endian. Simulator Hijack Command This command is used by the simulator to hijack a real control board. This allows the simulator to pass certain information to and receive certain information from the control board. This enables testing of the actual firmware and reproducing bugs under simulation. The command has the following format. 'S', 'I', 'M', 'H', 'I', 'J', 'A', 'C', 'K', [hijack] [hijack] is an 8-bit integer (unsigned) with a value of 1 or 0. If 1, the control board is put into simulator hijack mode. If 0, it is removed from simulator hijack mode. This message will be acknowledged. The acknowledge message will contain no result data. Simulator Data Command This command is used by the simulator to send simulated sensor data to a hijacked control board. 'S', 'I', 'M', 'D', 'A', 'T', [w], [x], [y], [z], [depth] All values are little endian floats (32-bit). x , y , z , w are current quaternion (IMU data) depth is current depth (depth sensor data). Version Info Query Get the version info from the control board. 'C', 'B', 'V', 'E', 'R' This message will be acknowledged. If acknowledged with no error, the response will contain data in the following format [cb_ver],[fw_ver_major],[fw_ver_minor],[fw_ver_revision],[fw_ver_type],[fw_ver_build] Each value is an unsigned 8-bit integer. All are simply interpreted as numbers, except for fw_ver_type , which is an ASCII character. cb_ver : Version of the control board hardware (CBv1 or CBv2 = 1 or 2; 0 = SimCB in simulator) fw_ver_major : Major version of firmware running on the control board fw_ver_minor : Minor version of firmware running on the control board fw_ver_revision : Revision version of firmware running on the control board fw_ver_type : Type of firmware release. 'a' = alpha, 'b' = beta, 'c' = release candidate (rc), ' ' (space) = full release fw_ver_build : Build number for pre-release firmware. Should be ignored for fw_ver_type release (' ') Acknowledgements An acknowledgement message has the following format 'A', 'C', 'K', [ack_id], [error_code], [result] [ack_id] : The ID of the message being acknowledged. Unsigned 16-bit integer (big endian). [error_code] : A single byte error code. 0 = None: No error. 1 = Unknown Message: Control board does not recognize the message. 2 = Invalid arguments: Message is recognized, but arguments are invalid 3 = Invalid Command: Command is known, but is not valid at this time. 255 = Reserved: Control board will not use this code. Typically used as timeout. [result] : Optional data of variable size attached to the acknowledge message. Its size, format, and meaning depends on the message being acknowledged. Status Messages Motor Watchdog Status Motor watch status message is used by the control board to notify the PC about changes to motor (watchdog) state. It has the following format 'W', 'D', 'G', 'S', [status] [status] is a single byte. A value of 1 indicates the motors are enabled. A value of zero indicates the motors are currently killed by the watchdog. IMU Data Status Used by the control board to periodically send IMU data to the PC. Only sent when IMU periodic reads are enabled via the IMU periodic read command. The message has the following format 'I', 'M', 'U', 'D', [quat_w], [quat_x], [quat_y], [quat_z], [accum_pitch], [accum_roll], [accum_yaw] Each value is a 32-bit float, little endian. quat_ values are components of the orientation quaternion. accum_ values are accumulated euler angles. Depth Data Status Used by the control board to periodically send IMU data to the PC. Only sent when BNO055 periodic reads are enabled via the BNO055 periodic read command. The message has the following format 'D', 'E', 'P', 'T', 'H', 'D', [depth_m], [pressure_pa], [temp_c] depth_m is a 32-bit float, little endian (meters below surface). pressure_pa is a 32-bit float, little endian (measured pressure in Pa). temp_c is a 32-bit float, little endian (temperature of air / water). Debug Status Messages Used only during development. These will not occur on release builds of the firmware. These are arbitrary messages sent by the control board to the PC for the firmware developer's use during development. They have the following format 'D', 'E', 'B', 'U', 'G', [msg] msg is an ascii string. Debug Data Status Messages Used only during development. These will not occur on release builds of the firmware. These are arbitrary messages sent by the control board to the PC for the firmware developer's use during development. They have the following format 'D', 'B', 'G', 'D', 'A', 'T', [msg] msg is arbitrary data. Heartbeat Status Messages Sent from control board periodically to indicate that it still exists and is operating as expected. This is generally ignored by end users. It is mostly intended to ensure communication occurs periodically in SimCB so connection drops are detectable. 'H', 'E', 'A', 'R', 'T', 'B', 'E', 'A', 'T' Simulator Status Message Sent from a simulator hijacked control board periodically to provide simulator with state and motor speed information. 'S', 'I', 'M', 'S', 'T', 'A', 'T', [t1], [t2], [t3], [t4], [t5], [t6], [t7], [t8], [mode], [wdog_killed] Each value t1 to t8 is a 32-bit little endian float representing thruster speeds 1 - 8 respectively. mode is an unsigned 8-bit integer indicating the control board's current operating mode from one of the following Raw = 0 Local = 1 Global = 2 Sassist = 3 Ohold = 5 wdog_killed is an unsigned 8-bit integer indicating if the control board's motors are killed due to motor watchdog timeout. 1 indicates that motors are killed. 0 indicates not killed.","title":"Messages"},{"location":"user_guide/messages/#messages","text":"This section describes what specific messages are sent to / received from the control board and what they do / mean. This does not address how messages are constructed or sent. For such information, see Communication Protocol . Note: The Communication Protocol page uses the term \"payload\" for the data being transferred and \"message\" for the formatted / fully constructed set of data. Here, what we refer to as \"messages\" are actually the \"payload\" data, not the constructed data.","title":"Messages"},{"location":"user_guide/messages/#message-definition-conventions","text":"In the following sections, the following standard is used to describe message contents: Each message's contents are shown as a comma separated list of bytes. Each comma separated item is a single byte, with one exception for parameters (as described below) Parameters are shown inside square brackets. Parameters represent a value that will be described in more detail below the message structure information. Parameters can be multiple bytes (even though they take only one entry between commas). ASCII characters are shown in single quotes. These are single byte unsigned ASCII characters. Numbers are not contained within any symbols. Numbers may be in hex (prefix 0x), binary (prefix 0b), or decimal (no prefix).","title":"Message Definition Conventions"},{"location":"user_guide/messages/#types-of-messages","text":"Commands : Messages instructing an action be taken. These messages must be acknowledged upon receipt. The acknowledgement typically contains no data. Sent from PC to control board. Queries : Messages requesting information. These messages must be acknowledged upon receipt. The acknowledgement will contain the requested information. Sent from PC to control board. Acknowledgements : A very specific type of message acknowledging receipt of another message (with an error code and optional data). Sent from control board to PC. Status Messages : Unprompted messages containing information about state / data changes. Sent from control board to PC.","title":"Types of Messages"},{"location":"user_guide/messages/#commands-and-queries","text":"","title":"Commands and Queries"},{"location":"user_guide/messages/#motor-motion-commands","text":"Raw Speed Set Used to set motor speeds in RAW mode. This command has the following format. 'R', 'A', 'W', [speed_1], [speed_2], [speed_3], [speed_4], [speed_5], [speed_6], [speed_7], [speed_8] [speed_n] : The speed of thruster n from -1.0 to 1.0. A 32-bit float (little endian). This message will be acknowledged. The acknowledge message will contain no result data. Local Speed Set Used to set motor speeds in LOCAL mode. This command has the following format 'L', 'O', 'C', 'A', 'L', [x], [y], [z], [xrot], [yrot], [zrot] [x] , [y] , [z] , [xrot] , [yrot] , [zrot] : Speed for each DoF relative to the robot -1.0 to 1.0. A 32-bit float (little endian). This message will be acknowledged. The acknowledge message will contain no result data. Global Speed Set Used to set motor speeds in GLOBAL mode. This command has the following format 'G', 'L', 'O', 'B', 'A', 'L', [x], [y], [z], [pitch_spd], [roll_spd], [yaw_spd] [x] , [y] , [z] : Speed for each \"world-relative\" (pitch and roll compensated) DoF -1.0 to 1.0. 32-bit float (little endian). [pitch_spd] , [roll_spd] , [yaw_spd] : Rate of change of vehicle pitch, roll, and yaw -1.0 to 1.0. This message will be acknowledged. The acknowledge message will contain no result data. Note that if the IMU is not working properly, this command will be acknowledged with the \"Invalid Command\" error code. This can occur if the axis config of the IMU is changed immediately before issuing this command. Orientation Hold Speed Set (Variant 1) Used to set motor speeds in ORIENTATION_HOLD mode using a speed for yaw. This command has the following format 'O', 'H', 'O', 'L', 'D', '1', [x], [y], [z], [yaw_spd], [target_pitch], [target_roll] Each value is a 32-bit float little endian. Pitch and roll are euler angles (in degrees). These are intrinsic euler angles (z-x'-y'' convention per the control board's coordinate system). x, y, z, and yaw_spd are x, y, z, and yaw_spd just as in global mode. This message will be acknowledged with no data. Note that if the IMU or depth sensor is not working properly, this command will be acknowledged with the \"Invalid Command\" error code. This can occur if the axis config of the IMU is changed immediately before issuing this command. Orientation Hold Speed Set (Variant 2) Used to set motor speeds in ORIENTATION_HOLD mode using a PID to maintain a target yaw. This command has the following format 'O', 'H', 'O', 'L', 'D', '2', [x], [y], [z], [target_pitch], [target_roll], [target_yaw] Each value is a 32-bit float little endian. Target Pitch, roll, and yaw are euler angles (in degrees). These are intrinsic euler angles (z-x'-y'' convention per the control board's coordinate system). x, y, and z are speeds in the x, y, and z DoFs the same as in GLOBAL mode. This message will be acknowledged with no data. Note that if the IMU or depth sensor is not working properly, this command will be acknowledged with the \"Invalid Command\" error code. This can occur if the axis config of the IMU is changed immediately before issuing this command. Stability Assist Speed Set (Variant 1) Used to set motor speeds in STABILITY_ASSIST mode using a speed for yaw. This command has the following format 'S', 'A', 'S', 'S', 'I', 'S', 'T', '1', [x], [y], [yaw_spd], [target_pitch], [target_roll], [target_depth] Each value is a 32-bit float little endian. Pitch and roll are euler angles (in degrees). These are intrinsic euler angles (z-x'-y'' convention per the control board's coordinate system). Depth is in meters where negative numbers are below the surface. x, y, and yaw_spd are x, y, and yaw_spd just as in global mode. This message will be acknowledged with no data. Note that if the IMU or depth sensor is not working properly, this command will be acknowledged with the \"Invalid Command\" error code. This can occur if the axis config of the IMU is changed immediately before issuing this command. Stability Assist Speed Set (Variant 2) Used to set motor speeds in STABILITY_ASSIST mode using a PID to maintain a target yaw. This command has the following format 'S', 'A', 'S', 'S', 'I', 'S', 'T', '2', [x], [y], [target_pitch], [target_roll], [target_yaw], [target_depth] Each value is a 32-bit float little endian. Target Pitch, roll, and yaw are euler angles (in degrees). These are intrinsic euler angles (z-x'-y'' convention per the control board's coordinate system). Depth is in meters where negative numbers are below the surface. x and y are speeds in the x and y DoFs the same as in GLOBAL mode. This message will be acknowledged with no data. Note that if the IMU or depth sensor is not working properly, this command will be acknowledged with the \"Invalid Command\" error code. This can occur if the axis config of the IMU is changed immediately before issuing this command. Feed Motor Watchdog Used to feed the motor watchdog so it does not kill the motors. This command has the following format 'W', 'D', 'G', 'F' This message will be acknowledged. The acknowledge message will contain no result data.","title":"Motor motion commands"},{"location":"user_guide/messages/#vehicle-configuration-commands","text":"Motor Matrix Set Motor matrix set command is used to set a single row of the motor matrix. It has the following format 'M', 'M', 'A', 'T', 'S', [thruster_num], [x], [y], [z], [pitch], [roll], [yaw] [thruster_num] : A single byte who'se unsigned value is the thruster number the row data should be set for (1-8). [x] , [y] , [z] , [pitch] , [roll] , [yaw] : Columns of the motor matrix row being set. Each is a 32-bit float (little endian). This message will be acknowledged. The acknowledge message will contain no result data. Motor Matrix Update Motor matrix update command is used to inform the control board the motor matrix has changed. Causes the control board to perform some calculations with the new motor matrix. This should be sent after writing all rows of the motor matrix that should change using the motor matrix set command. The motor matrix update command has the following format 'M', 'M', 'A', 'T', 'U' This message will be acknowledged. The acknowledge message will contain no result data. Thruster PWM Parameter Config Configure PWM settings for thrusters. 'T', 'P', 'W', 'M', [pwm_period], [pwm_zero], [pwm_range] Each value is an unsigned 16-bit integer (little endian). pwm_period is the PWM signal period in microseconds (determines PWM frequency / update rate for ESCs). pwm_zero is the pulse width for zero speed in microseconds (typically 1500). pwm_range is the deviation from zero to achieve max speed (when added) or min speed (when subtracted) such that the pulse width pwm_zero + pwm_range microseconds is full forward speed and the pulse width pwm_zero - pwm_range microseconds is full reverse speed. This message will be acknowledged. The acknowledge message will contain no result data. Thruster Inversion Set Thruster inversion set command is used to invert the positive and negative direction of thrusters. It has the following format 'T', 'I', 'N', 'V', [inv] [inv] : A single byte where each bit represents the inversion status of a thruster. The MSB (bit 7) corresponds to thruster 8 and the LSB corresponds to thruster 1 (bit + 1 = thruster). A bit value of 1 means the thruster is inverted. A bit value of 0 means the thruster is not inverted. This message will be acknowledged. The acknowledge message will contain no result data. Relative DoF Speed Set Used to set relative speeds of motion in each DoF. There are two groups: linear (x, y, z) and angular (xrot, yrot, zrot). Within each group, use 1.0 for the fastest DoF. Other DoFs in the group are percentages of the fastest speed (from 0.0 to 1.0). This message has the following format 'R', 'E', 'L', 'D', 'O', 'F', [x], [y], [z], [xrot], [yrot], [zrot] [x] , [y] , [z] , [xrot] , [yrot] , [zrot] : 32-bit little endian floats. This message will be acknowledged. The acknowledge message will contain no result data. PID Tune Command Used to tune PID controllers. The command has the following format 'P', 'I', 'D', 'T', 'N', [which], [kp], [ki], [kd], [limit], [invert] [which] indicates which PID to tune ('X' = xrot, 'Y' = yrot, 'Z' = zrot, 'D' = depth hold). [kp] , [ki] , [kd] are proportional, integral, derivative, and feed-forward gains (32-bit float little endian). [limit] Is the PID controller's max output (limits max speed in the controlled DoF). Must be between 0.0 and 1.0. 32-bit float little endian. [invert] Set to one to invert PID output. Zero otherwise.","title":"Vehicle Configuration Commands"},{"location":"user_guide/messages/#sensor-commands-and-queries","text":"Sensor Status Query Check which IMU and depth sensor is currently in use 'S', 'S', 'T', 'A', 'T' This message will be acknowledged. If acknowledged with no error, the response will contain data in the following format [which_imu], [which_depth] [which_imu] : Single byte indicating which IMU is in use - No IMU: 0 - Simulated IMU (under simulator hijack): 1 - BNO055 IMU: 2 [which_depth] : Single byte indicating which depth sensor is in use - No Depth sensor: 0 - Simulated depth sensor (under simulator hijack): 1 - MS5837 Depth sensor: 2 IMU Read Reads IMU data once. 'I', 'M', 'U', 'R' This message will be acknowledged. If acknowledged with no error, the response will contain data in the following format. Note that this is the same format as the data contained within the BNO055 data status message. [quat_w], [quat_x], [quat_y], [quat_z], [accum_pitch], [accum_roll], [accum_yaw] Each value is a 32-bit float, little endian. quat_ values are components of the orientation quaternion. accum_ values are accumulated euler angles. IMU Raw Read Reads raw IMU data once. 'I', 'M', 'U', 'W' This message will be acknowledged. If acknowledged with no error, the response will contain data in the following format. Note that this is the same format as the data contained within the BNO055 data status message. [accel_x], [accel_y], [accel_z], [gyro_x], [gyro_y], [gyro_z] Each value is a 32-bit float, little endian. IMU Periodic Read Used to enable / disable periodic reading of IMU data. This will only impact data being sent from control board to the pc. The control board itself will continue to read and use IMU data. 'I', 'M', 'U', 'P', [enable] [enable] is an 8-bit integer with a value of either 1 or 0. If 1, reading data periodically is enabled. If 0, reading data periodically is disabled. This message will be acknowledged. The acknowledge message will contain no result data. Depth Read Reads depth sensor data once. 'D', 'E', 'P', 'T', 'H', 'R' This message will be acknowledged. If acknowledged with no error, the response will contain data in the following format. Note that this is the same format as the data contained within the MS5837 data status message. [depth_m], [pressure_pa], [temp_c] depth_m is a 32-bit float, little endian (meters below surface). pressure_pa is a 32-bit float, little endian (measured pressure in Pa). temp_c is a 32-bit float, little endian (temperature of air / water). Depth Periodic Read Used to enable / disable periodic reading of MS5837 data. This will only impact data being sent from control board to the pc. The control board itself will continue to read and use depth sensor data. 'D', 'E', 'P', 'T', 'G', 'P', [enable] [enable] is an 8-bit integer with a value of either 1 or 0. If 1, reading data periodically is enabled. If 0, reading data periodically is disabled. This message will be acknowledged. The acknowledge message will contain no result data.","title":"Sensor Commands and Queries"},{"location":"user_guide/messages/#bno055-imu-configuration","text":"BNO055 IMU Axis Configure Command Used to configure the BNO055 IMU's axis orientation. Note: This will also reset the accumulated euler angles to zero . 'B', 'N', 'O', '0', '5', '5', 'A', [config] [config] : A single byte. The value of this byte is between 0 and 7 (inclusive) representing on of the BNO055 axis configs (P0 to P7) as described in the BNO055 datasheet. Note: Changing the axis config changes IMU mode. Thus, there will be a brief time afterwards where the IMU may report zeros for all data. This message will be acknowledged. The acknowledge message will contain no result data. Note that if the BNO055 is not the active IMU (see sensor status query), this will be acknowledged using the INVALID_CMD error code. Save BNO055 Stored Calibration Command This command is used to store a set of calibration constants for the BNO055 to the control board. This will write the \"stored calibration constants\". This command will also cause the IMU to be reconfigured (this can take some time, so acknowledgements for this command may take longer than most). The command has the following format 'S', 'C', 'B', 'N', 'O', '0', '5', '5', 'S', [accel_offset_x], [accel_offset_y], [accel_offset_z], [accel_radius], [gyro_offset_x], [gyro_offset_y], [gyro_offset_z] Each value is a signed 16-bit integer. The meaning of each value is described in the BNO055 datasheet. This message will be acknowledged. The acknowledge message will contain no result data. Note that if the BNO055 is not the active IMU (see sensor status query), this will be acknowledged using the INVALID_CMD error code. Erase BNO055 Stored Calibration Command This command is used to erase calibration constants for the BNO055 from the control board. This will erase the \"stored calibration constants\". This command will also cause the IMU to be reconfigured (this can take some time, so acknowledgements for this command may take longer than most). The command has the following format 'S', 'C', 'B', 'N', 'O', '0', '5', '5', 'E' This message will be acknowledged. The acknowledge message will contain no result data. Note that if the BNO055 is not the active IMU (see sensor status query), this will be acknowledged using the INVALID_CMD error code. Reset BNO055 Command This command is used to reset / reconfigure the BNO055. This is typically used to clear any auto generated calibration constants. The command has the following format 'B', 'N', 'O', '0', '5', '5', 'R', 'S', 'T' This message will be acknowledged. The acknowledge message will contain no result data. Note that if the BNO055 is not the active IMU (see sensor status query), this will be acknowledged using the INVALID_CMD error code. Read BNO055 Stored Calibration Query This command is used to read a set of calibration constants for the BNO055 from the control board. This will read the \"stored calibration constants\". The command has the following format 'S', 'C', 'B', 'N', 'O', '0', '5', '5', 'R' This message will be acknowledged. If acknowledged with no error, the response will contain data in the following format. [valid], [accel_offset_x], [accel_offset_y], [accel_offset_z], [accel_radius], [gyro_offset_x], [gyro_offset_y], [gyro_offset_z] valid is an 8-bit integer. A value of 0 indicates that no calibration is stored on the control board (other values have no meaning). A value of 1 indicates that a calibration is stored (other values are that calibration). All other values in the acknowledge data are signed 16-bit integers. The meaning of these integers is described in the BNO055 datasheet. Read BNO055 Live Calibration Status Query This command is used to read the status of the BNO055's calibration routine. Note that this reads the value directly from the BNO055. This value is meaningless if a calibration was manually applied to the sensor. Thus, this is only useful if any \"stored calibration constants\" are first erased. The command has the following format 'B', 'N', 'O', '0', '5', '5', 'C', 'S' This message will be acknowledged. Note that if the IMU is not working properly, this command will be acknowledged with the \"Invalid Command\" error code. If acknowledged with no error, the response will contain data in the following format. [status] status is an 8-bit integer. The value of status is the value of the BNO055's CALIB_STAT register. The meaning of this number is described in the BNO055 datasheet. Note that if the BNO055 is not the active IMU (see sensor status query), this will be acknowledged using the INVALID_CMD error code. Read BNO055 Live Calibration Values Query This command is used to read a set of calibration constants from the BNO055. This will read the \"live calibration constants\" directly from the BNO055. Note that the calibration constants are only valid if the calibration status from the BNO055 is 3 for the accelerometer and gyroscope. The command has the following format 'B', 'N', 'O', '0', '5', '5', 'C', 'V' This message will be acknowledged. Note that if the IMU is not working properly, this command will be acknowledged with the \"Invalid Command\" error code. If acknowledged with no error, the response will contain data in the following format. [accel_offset_x], [accel_offset_y], [accel_offset_z], [accel_radius], [gyro_offset_x], [gyro_offset_y], [gyro_offset_z] All values in the acknowledge data are signed 16-bit integers. The meaning of these integers is described in the BNO055 datasheet. Note that if the BNO055 is not the active IMU (see sensor status query), this will be acknowledged using the INVALID_CMD error code.","title":"BNO055 IMU Configuration"},{"location":"user_guide/messages/#ms5837-depth-sensor-configuration","text":"Read MS5837 Calibration Query This command is used to read the values of the MS5837 calibration constants. The command has the following format 'M', 'S', '5', '8', '3', '7', 'C', 'A', 'L', 'G' This message will be acknowledged. If acknowledged with no error, the response will contain data in the following format. [atm_pressure], [fluid_density] Both values are 32-bit little endian floats. Write MS5837 Calibration Command This command is used to write the values of the MS5837 calibration constants. The command has the following format 'M', 'S', '5', '8', '3', '7', 'C', 'A', 'L', 'S', [atm_pressure], [fluid_density] Both values are 32-bit little endian floats. This message will be acknowledged. The acknowledge message will contain no result data.","title":"MS5837 Depth Sensor Configuration"},{"location":"user_guide/messages/#misc-commands-and-queries","text":"Reset Command This command is used to rest the control board itself. This will reset the microcontroller on the control board, thus the USB device will disconnect and reconnect (note that if your program still holds the port when this happens, the USB device will likely be assigned a different port number). 'R', 'E', 'S', 'E', 'T', 0x0D, 0x1E This message is not acknowledged. Last Reset Cause Query Get error code for last system reset cause of the control board. Generally not useful for end users, except for reporting errors. Mainly a debug / development tool. See error codes in firmware source debug.h . 'R', 'S', 'T', 'W', 'H', 'Y' This message will be acknowledged. If acknowledged with no error, the response will contain data in the following format. [error_code] error_code is a 32-bit integer (signed), little endian. Simulator Hijack Command This command is used by the simulator to hijack a real control board. This allows the simulator to pass certain information to and receive certain information from the control board. This enables testing of the actual firmware and reproducing bugs under simulation. The command has the following format. 'S', 'I', 'M', 'H', 'I', 'J', 'A', 'C', 'K', [hijack] [hijack] is an 8-bit integer (unsigned) with a value of 1 or 0. If 1, the control board is put into simulator hijack mode. If 0, it is removed from simulator hijack mode. This message will be acknowledged. The acknowledge message will contain no result data. Simulator Data Command This command is used by the simulator to send simulated sensor data to a hijacked control board. 'S', 'I', 'M', 'D', 'A', 'T', [w], [x], [y], [z], [depth] All values are little endian floats (32-bit). x , y , z , w are current quaternion (IMU data) depth is current depth (depth sensor data). Version Info Query Get the version info from the control board. 'C', 'B', 'V', 'E', 'R' This message will be acknowledged. If acknowledged with no error, the response will contain data in the following format [cb_ver],[fw_ver_major],[fw_ver_minor],[fw_ver_revision],[fw_ver_type],[fw_ver_build] Each value is an unsigned 8-bit integer. All are simply interpreted as numbers, except for fw_ver_type , which is an ASCII character. cb_ver : Version of the control board hardware (CBv1 or CBv2 = 1 or 2; 0 = SimCB in simulator) fw_ver_major : Major version of firmware running on the control board fw_ver_minor : Minor version of firmware running on the control board fw_ver_revision : Revision version of firmware running on the control board fw_ver_type : Type of firmware release. 'a' = alpha, 'b' = beta, 'c' = release candidate (rc), ' ' (space) = full release fw_ver_build : Build number for pre-release firmware. Should be ignored for fw_ver_type release (' ')","title":"Misc Commands and Queries"},{"location":"user_guide/messages/#acknowledgements","text":"An acknowledgement message has the following format 'A', 'C', 'K', [ack_id], [error_code], [result] [ack_id] : The ID of the message being acknowledged. Unsigned 16-bit integer (big endian). [error_code] : A single byte error code. 0 = None: No error. 1 = Unknown Message: Control board does not recognize the message. 2 = Invalid arguments: Message is recognized, but arguments are invalid 3 = Invalid Command: Command is known, but is not valid at this time. 255 = Reserved: Control board will not use this code. Typically used as timeout. [result] : Optional data of variable size attached to the acknowledge message. Its size, format, and meaning depends on the message being acknowledged.","title":"Acknowledgements"},{"location":"user_guide/messages/#status-messages","text":"Motor Watchdog Status Motor watch status message is used by the control board to notify the PC about changes to motor (watchdog) state. It has the following format 'W', 'D', 'G', 'S', [status] [status] is a single byte. A value of 1 indicates the motors are enabled. A value of zero indicates the motors are currently killed by the watchdog. IMU Data Status Used by the control board to periodically send IMU data to the PC. Only sent when IMU periodic reads are enabled via the IMU periodic read command. The message has the following format 'I', 'M', 'U', 'D', [quat_w], [quat_x], [quat_y], [quat_z], [accum_pitch], [accum_roll], [accum_yaw] Each value is a 32-bit float, little endian. quat_ values are components of the orientation quaternion. accum_ values are accumulated euler angles. Depth Data Status Used by the control board to periodically send IMU data to the PC. Only sent when BNO055 periodic reads are enabled via the BNO055 periodic read command. The message has the following format 'D', 'E', 'P', 'T', 'H', 'D', [depth_m], [pressure_pa], [temp_c] depth_m is a 32-bit float, little endian (meters below surface). pressure_pa is a 32-bit float, little endian (measured pressure in Pa). temp_c is a 32-bit float, little endian (temperature of air / water). Debug Status Messages Used only during development. These will not occur on release builds of the firmware. These are arbitrary messages sent by the control board to the PC for the firmware developer's use during development. They have the following format 'D', 'E', 'B', 'U', 'G', [msg] msg is an ascii string. Debug Data Status Messages Used only during development. These will not occur on release builds of the firmware. These are arbitrary messages sent by the control board to the PC for the firmware developer's use during development. They have the following format 'D', 'B', 'G', 'D', 'A', 'T', [msg] msg is arbitrary data. Heartbeat Status Messages Sent from control board periodically to indicate that it still exists and is operating as expected. This is generally ignored by end users. It is mostly intended to ensure communication occurs periodically in SimCB so connection drops are detectable. 'H', 'E', 'A', 'R', 'T', 'B', 'E', 'A', 'T' Simulator Status Message Sent from a simulator hijacked control board periodically to provide simulator with state and motor speed information. 'S', 'I', 'M', 'S', 'T', 'A', 'T', [t1], [t2], [t3], [t4], [t5], [t6], [t7], [t8], [mode], [wdog_killed] Each value t1 to t8 is a 32-bit little endian float representing thruster speeds 1 - 8 respectively. mode is an unsigned 8-bit integer indicating the control board's current operating mode from one of the following Raw = 0 Local = 1 Global = 2 Sassist = 3 Ohold = 5 wdog_killed is an unsigned 8-bit integer indicating if the control board's motors are killed due to motor watchdog timeout. 1 indicates that motors are killed. 0 indicates not killed.","title":"Status Messages"},{"location":"user_guide/preparing_board/","text":"Preparing a Control Board TODO: Improve this with step by step instructions and screenshots Assemble a control board (see v1 hardware or v2 hardware ) Flash the firmware See Building & Flashing for details Install bossa cli or dfu-util and make sure the binaries (bossac or dfu-util) are in your path Install python Download and extract release package from GitHub Put the board into bootloader mode v1: Double press reset button quickly v2: Hold boot button, press and release reset, release boot button In firmware folder from release package run ./flash.py [v1/v2] Release This will run the flash tool Connect external sensors","title":"Preparing a Control Board"},{"location":"user_guide/preparing_board/#preparing-a-control-board","text":"TODO: Improve this with step by step instructions and screenshots Assemble a control board (see v1 hardware or v2 hardware ) Flash the firmware See Building & Flashing for details Install bossa cli or dfu-util and make sure the binaries (bossac or dfu-util) are in your path Install python Download and extract release package from GitHub Put the board into bootloader mode v1: Double press reset button quickly v2: Hold boot button, press and release reset, release boot button In firmware folder from release package run ./flash.py [v1/v2] Release This will run the flash tool Connect external sensors","title":"Preparing a Control Board"},{"location":"user_guide/pythoniface/","text":"Using the Python Interface TODO: About iface (describe the different files) TODO: Launch script and what it does. Include port selection, but NOT use of SimCB, and NOT use of simulator. TODO: Vehicle configs and what they do TODO: Example scripts descriptions TODO: Guide on adding new vehicle configs TODO: Guide on adding custom scripts","title":"Using the Python Interface"},{"location":"user_guide/pythoniface/#using-the-python-interface","text":"TODO: About iface (describe the different files) TODO: Launch script and what it does. Include port selection, but NOT use of SimCB, and NOT use of simulator. TODO: Vehicle configs and what they do TODO: Example scripts descriptions TODO: Guide on adding new vehicle configs TODO: Guide on adding custom scripts","title":"Using the Python Interface"},{"location":"user_guide/simcb_simulator/","text":"Using SimCB and Simulator TODO: Details and improvements in various sections. TODO: Add port number info. SimCB SimCB is a version of the control board firmware which is built as a binary that runs on Windows, macOS, or Linux. By running this binary, you can run the control board firmware on your computer without having a physical control board. SimCB only supports simulator hijack mode (meaning only the sim IMU and depth sensors will work and thruster speeds will be reported back over comms interface). Instead of communicating with a physical control board via UART, you communicate with SimCB via TCP (the exact same messages are sent, just treat what you send over UART and TCP as byte streams). SimCB is a TCP server so code connecting to SimCB must be a TCP client. TODO: How to use SimCB instead of real control board over uart (including instructions to run SimCB) Using SimCB allows testing various aspects of communication with the control board and system behavior without having a physical control board. Simulator The simulator is a program that runs on your computer and models a vehicle in 3D space. The simulator hijacks a control board and provides the control board \"fake\" sensor data from the simulated environment. The control board then provides the simulator motor speeds so the simulator can move the vehicle appropriately in the simulated environment. When in this mode, user code should communicate with the simulator over TCP instead of communicating with the control board directly. See the simulator's README for a description of how to communicate with the simulator. Note that the python iface scripts have builtin support for using the simulator. The provided simulator (linked above) is fairly simple, and is mostly intended for development testing of the control board firmware. However, it can be useful to end users as well to see how the vehicle is expected to behave. Note thought that the environment provided in this simulator is very limited. For more complex use cases, users may wish to fork and adapt the simulator to their vehicles / use cases. TODO: Instructions to run simulator and connect to real control board. Combining SimCB and Simulator By combining the simulator (providing a simulated vehicle and environment) with SimCB (providing a control board without hardware), it is possible to test vehicle motion without any hardware (no vehicle in water and no real control board). TODO: Instructions to run the simulator and connect to SimCB Ways to access Control Board There are four general ways to use the control board Directly using a real control board over UART (via USB) Directly using SimCB over TCP Using the simulator attached to a real control board (talking to the simulator over TCP) Using the simulator attached to SimCB (talking to the simulator over TCP) TODO: Discussion of these methods and when they are useful Advanced use Cases End users can implement functionality in their own simulators to \"hijack\" a control board for simulation (referred to as \"simhijack\") just as the provided simulator does. When a control board is simhijacked, it does not use real sensors or create PWM signals for real thrusters. Instead, it communicates with a simulator. The control board gives the simulator motor speeds and the simulator is expected to provide the control board with sensor data. The protocol for doing so is fairly simple (see messages documentation) allowing end users to incorporate a control board into their own vehicle simulations. End users may want to design unit tests that require communicating with a control board and validating motion. Unit test code can simhijack either a physical board or SimCB (probably more useful to use SimCB) and provide specific sensor inputs and commands and validate the motor outputs are as expected.","title":"Using SimCB and Simulator"},{"location":"user_guide/simcb_simulator/#using-simcb-and-simulator","text":"TODO: Details and improvements in various sections. TODO: Add port number info.","title":"Using SimCB and Simulator"},{"location":"user_guide/simcb_simulator/#simcb","text":"SimCB is a version of the control board firmware which is built as a binary that runs on Windows, macOS, or Linux. By running this binary, you can run the control board firmware on your computer without having a physical control board. SimCB only supports simulator hijack mode (meaning only the sim IMU and depth sensors will work and thruster speeds will be reported back over comms interface). Instead of communicating with a physical control board via UART, you communicate with SimCB via TCP (the exact same messages are sent, just treat what you send over UART and TCP as byte streams). SimCB is a TCP server so code connecting to SimCB must be a TCP client. TODO: How to use SimCB instead of real control board over uart (including instructions to run SimCB) Using SimCB allows testing various aspects of communication with the control board and system behavior without having a physical control board.","title":"SimCB"},{"location":"user_guide/simcb_simulator/#simulator","text":"The simulator is a program that runs on your computer and models a vehicle in 3D space. The simulator hijacks a control board and provides the control board \"fake\" sensor data from the simulated environment. The control board then provides the simulator motor speeds so the simulator can move the vehicle appropriately in the simulated environment. When in this mode, user code should communicate with the simulator over TCP instead of communicating with the control board directly. See the simulator's README for a description of how to communicate with the simulator. Note that the python iface scripts have builtin support for using the simulator. The provided simulator (linked above) is fairly simple, and is mostly intended for development testing of the control board firmware. However, it can be useful to end users as well to see how the vehicle is expected to behave. Note thought that the environment provided in this simulator is very limited. For more complex use cases, users may wish to fork and adapt the simulator to their vehicles / use cases. TODO: Instructions to run simulator and connect to real control board.","title":"Simulator"},{"location":"user_guide/simcb_simulator/#combining-simcb-and-simulator","text":"By combining the simulator (providing a simulated vehicle and environment) with SimCB (providing a control board without hardware), it is possible to test vehicle motion without any hardware (no vehicle in water and no real control board). TODO: Instructions to run the simulator and connect to SimCB","title":"Combining SimCB and Simulator"},{"location":"user_guide/simcb_simulator/#ways-to-access-control-board","text":"There are four general ways to use the control board Directly using a real control board over UART (via USB) Directly using SimCB over TCP Using the simulator attached to a real control board (talking to the simulator over TCP) Using the simulator attached to SimCB (talking to the simulator over TCP) TODO: Discussion of these methods and when they are useful","title":"Ways to access Control Board"},{"location":"user_guide/simcb_simulator/#advanced-use-cases","text":"End users can implement functionality in their own simulators to \"hijack\" a control board for simulation (referred to as \"simhijack\") just as the provided simulator does. When a control board is simhijacked, it does not use real sensors or create PWM signals for real thrusters. Instead, it communicates with a simulator. The control board gives the simulator motor speeds and the simulator is expected to provide the control board with sensor data. The protocol for doing so is fairly simple (see messages documentation) allowing end users to incorporate a control board into their own vehicle simulations. End users may want to design unit tests that require communicating with a control board and validating motion. Unit test code can simhijack either a physical board or SimCB (probably more useful to use SimCB) and provide specific sensor inputs and commands and validate the motor outputs are as expected.","title":"Advanced use Cases"}]}