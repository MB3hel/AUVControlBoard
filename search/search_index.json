{"config":{"indexing":"full","lang":["en"],"min_search_length":3,"prebuild_index":false,"separator":"[\\s\\-]+"},"docs":[{"location":"","text":"AUV Control Board Documentation AUV Control Board is a low-cost open-source motion controller for (Autonomous) Underwater Vehicles. It is designed for vehicles with fixed position thrusters and supports motion in 6 degrees of freedom. There are currently two versions of control board. Neither version has more features than the other. Version 2 was developed to be able to use a different chip / board that was easier to get. Version 1 uses an Adafruit ItsyBitsy M4 (Microchip ATSAMD51 chip) Version 2 use a WeAct Studio Black Pill (STMicroelectronics STM32F4) The firmware is capable of running on both versions. License Both the firmware and provided demo and interface scripts are licensed under the GNU General Public License version 3 or later (GPL-3.0-or-later). Note that the firmware includes third party components licensed under their own terms.","title":"Home"},{"location":"#auv-control-board-documentation","text":"AUV Control Board is a low-cost open-source motion controller for (Autonomous) Underwater Vehicles. It is designed for vehicles with fixed position thrusters and supports motion in 6 degrees of freedom. There are currently two versions of control board. Neither version has more features than the other. Version 2 was developed to be able to use a different chip / board that was easier to get. Version 1 uses an Adafruit ItsyBitsy M4 (Microchip ATSAMD51 chip) Version 2 use a WeAct Studio Black Pill (STMicroelectronics STM32F4) The firmware is capable of running on both versions.","title":"AUV Control Board Documentation"},{"location":"#license","text":"Both the firmware and provided demo and interface scripts are licensed under the GNU General Public License version 3 or later (GPL-3.0-or-later). Note that the firmware includes third party components licensed under their own terms.","title":"License"},{"location":"none/","text":"Coming Soon.","title":"None"},{"location":"firmware/build/","text":"Build and Flash Note: Run all commands shown in the firmware folder of the repo. Building Install the Required Tools: CMake (version 3.20.0 or newer) Ninja GNU Arm Toolchain Make sure cmake , ninja , and arm-none-eabi-gcc are in your PATH . Build the firmware using the commands below. Replace [preset] with v1 or v2 . Replace [config] with debug , release , minsizerel , or relwithdebinfo . cmake --preset=[preset] cmake --build --preset=[preset]-[config] Flashing Version Flash Method Tool Alias Required software v1 sam-ba (via bootloader) bossa BOSSA (specifically bossac / bossa-cli) v1 uf2conv (via bootloader) uf2conv None v2 dfu-util (via bootloader) dfu-util dfu-util v2 STM32CubeProgrammer DFU (via bootloader) stm32-dfu STM32CubeProgrammer Note: required tool ( bossac , dfu-util , STM32_Programmer_CLI ) must be in your PATH . Before flashing, the chip needs to enter its bootloader (unless using a debug probe such as the stlink2 to flash) If a board is already flashed, it can be rebooted into its bootloader using the reboot_bootloader.py script in the firmware directory. Otherwise, use the hardware method described below. v1: Press the reset button twice quickly (double press). v2: Hold the BOOT button. While holding it, press and release the NRST button. Then release the boot button. Note: Sometimes reboot to bootloader mode \"fails\". On v1, this usually means it fails to attach USB (LED remains red not green.) On v2 this usually means it doesn't show up as a USB device. In either case, just try to enter again using the same button combination above. To flash, run the flash.py script. It is a wrapper that will call one of the above tools python3 flash.py [version] [config] -u [tool] [version] is either v1 or v2 [config] is the configuration you want to flash (same as configuration built: Debug , Release , MinSizeRel , or RelWithDebInfo ) [tool] is one of the above upload tool aliases. Flashing Remotely Sometimes, it is useful to flash firmware without connecting directly to the control board. Typically, this is done in-system where the embedded computer using the control board (Jetson, Raspberry Pi, etc) is used to flash the control board without gaining physical access to the control board. Instead an ssh connection to the remote computer is used. There are a few requirements to be able to flash remotely The control board must already be running some version of the firmware. This is necessary to be able to enter bootloader mode without access to the buttons on the board. The remote computer must have a flash tool installed. For v1 this should be bossac and for v2 this should be dfu-util . These are available as packages for most Linux distributions ( bossa-cli and dfu-util respectively for Debian and Ubuntu based systems). You must have ssh (and by extension scp) access to the remote system (typically via ethernet tether) On the build computer (laptop, etc) build the firmware as described above. Then, login to the remote system via ssh and create a directory to hold control board flash stuff (name can be changed as desired) # Run on remote computer (via ssh) cd ~ mkdir cboard-flash Then on the build computer, use scp to copy the flash.py and reboot_bootloader.py scripts to this folder # Run on build laptop scp firmware/flash.py user@remote_ip:cboard-flash/ scp firmware/reboot_bootloader.py user@remote_ip:cboard-flash/ Next copy the build folder. You can just copy the binaries themselves, but the folder hierarchy must be maintained. # Run on remote computer (via ssh) # Delete old build folder first rm -r ~/cboard-flash/build # Run on build laptop scp -r firmware/build user@remote_ip:cboard-flash/ Finally, reboot the control board to bootloader and flash # Run on remote computer (via ssh) ./reboot_bootloader.py [port] ./flash.py [version] [config] -p [port] Note: Sometimes reboot to bootloader mode \"fails\". On v1, this usually means it fails to attach USB (LED remains red not green.) On v2 this usually means it doesn't show up as a USB device. In either case, you will loose USB communication to the board. In this case, a power cycle is required to \"fix\" the board before trying to enter the bootloader again. While inconvenient, it is still usually easier to power cycle the vehicle than to unseal it.","title":"Build and Flash"},{"location":"firmware/build/#build-and-flash","text":"Note: Run all commands shown in the firmware folder of the repo.","title":"Build and Flash"},{"location":"firmware/build/#building","text":"Install the Required Tools: CMake (version 3.20.0 or newer) Ninja GNU Arm Toolchain Make sure cmake , ninja , and arm-none-eabi-gcc are in your PATH . Build the firmware using the commands below. Replace [preset] with v1 or v2 . Replace [config] with debug , release , minsizerel , or relwithdebinfo . cmake --preset=[preset] cmake --build --preset=[preset]-[config]","title":"Building"},{"location":"firmware/build/#flashing","text":"Version Flash Method Tool Alias Required software v1 sam-ba (via bootloader) bossa BOSSA (specifically bossac / bossa-cli) v1 uf2conv (via bootloader) uf2conv None v2 dfu-util (via bootloader) dfu-util dfu-util v2 STM32CubeProgrammer DFU (via bootloader) stm32-dfu STM32CubeProgrammer Note: required tool ( bossac , dfu-util , STM32_Programmer_CLI ) must be in your PATH . Before flashing, the chip needs to enter its bootloader (unless using a debug probe such as the stlink2 to flash) If a board is already flashed, it can be rebooted into its bootloader using the reboot_bootloader.py script in the firmware directory. Otherwise, use the hardware method described below. v1: Press the reset button twice quickly (double press). v2: Hold the BOOT button. While holding it, press and release the NRST button. Then release the boot button. Note: Sometimes reboot to bootloader mode \"fails\". On v1, this usually means it fails to attach USB (LED remains red not green.) On v2 this usually means it doesn't show up as a USB device. In either case, just try to enter again using the same button combination above. To flash, run the flash.py script. It is a wrapper that will call one of the above tools python3 flash.py [version] [config] -u [tool] [version] is either v1 or v2 [config] is the configuration you want to flash (same as configuration built: Debug , Release , MinSizeRel , or RelWithDebInfo ) [tool] is one of the above upload tool aliases.","title":"Flashing"},{"location":"firmware/build/#flashing-remotely","text":"Sometimes, it is useful to flash firmware without connecting directly to the control board. Typically, this is done in-system where the embedded computer using the control board (Jetson, Raspberry Pi, etc) is used to flash the control board without gaining physical access to the control board. Instead an ssh connection to the remote computer is used. There are a few requirements to be able to flash remotely The control board must already be running some version of the firmware. This is necessary to be able to enter bootloader mode without access to the buttons on the board. The remote computer must have a flash tool installed. For v1 this should be bossac and for v2 this should be dfu-util . These are available as packages for most Linux distributions ( bossa-cli and dfu-util respectively for Debian and Ubuntu based systems). You must have ssh (and by extension scp) access to the remote system (typically via ethernet tether) On the build computer (laptop, etc) build the firmware as described above. Then, login to the remote system via ssh and create a directory to hold control board flash stuff (name can be changed as desired) # Run on remote computer (via ssh) cd ~ mkdir cboard-flash Then on the build computer, use scp to copy the flash.py and reboot_bootloader.py scripts to this folder # Run on build laptop scp firmware/flash.py user@remote_ip:cboard-flash/ scp firmware/reboot_bootloader.py user@remote_ip:cboard-flash/ Next copy the build folder. You can just copy the binaries themselves, but the folder hierarchy must be maintained. # Run on remote computer (via ssh) # Delete old build folder first rm -r ~/cboard-flash/build # Run on build laptop scp -r firmware/build user@remote_ip:cboard-flash/ Finally, reboot the control board to bootloader and flash # Run on remote computer (via ssh) ./reboot_bootloader.py [port] ./flash.py [version] [config] -p [port] Note: Sometimes reboot to bootloader mode \"fails\". On v1, this usually means it fails to attach USB (LED remains red not green.) On v2 this usually means it doesn't show up as a USB device. In either case, you will loose USB communication to the board. In this case, a power cycle is required to \"fix\" the board before trying to enter the bootloader again. While inconvenient, it is still usually easier to power cycle the vehicle than to unseal it.","title":"Flashing Remotely"},{"location":"firmware/details/","text":"Implementation Details TODO: EEPROM Emulation SAMD51 (CBv1) Using NVMCTRL SmartEEPROM Must configure size using NVMCTRL user page (requires write of fuses / config bits then device reset; XC32 compiler uses pragma config to configur this. I see no other way with GCC) Note that as such, configuring fuse settings with MCC Standalone generator will do no good (it assumes XC32) Linker script modified to shorten rom to avoid the data for eeprom STM32 (CBv2) Using code from https://github.com/STMicroelectronics/STM32CubeF4/tree/master/Projects/STM32F411RE-Nucleo/Applications/EEPROM/EEPROM_Emulation as st_eeprom.h/c Using sectors 1 and 2 isr_vectors must be in sector 0, most of this sector is wasted Flash used by program starts at sector 3. Leaves 464k flash for use. Note that since flash is split, flashing must occur in two stages (boot and main) using dfu-util TODO: Threading model mutexes, dataflow details TODO: Generator use and import process details TODO: Calibration of BNO055 - EEPROM calibration status signature for valid check - Erase only invalidates signature (potentially fewer writes) - If calibration constants are valid, they are applied during bno055 configuration. Applying constants will prevent BNO055 from running calibration routine in bg. Applied calibration is assumed to be good by the sensor (CALIB_STAT has no relevance). - Stored calibration commands - Erase triggers reset of sensor causing constants to be lost and auto calibration routine to run - Store triggers reset of sensor using the newly stored constants (thus no auto calibration runs) - Load will send the stuff from eeprom - There are separate BNO055 commands to read its calibration status register and the values from its calibration registers (these are only valid if CALIB_STAT is 3 for sensors used and BNO055 is in config mode) - What are each of the calibration constants (offsets, radius)","title":"Implementation Details"},{"location":"firmware/details/#implementation-details","text":"TODO: EEPROM Emulation SAMD51 (CBv1) Using NVMCTRL SmartEEPROM Must configure size using NVMCTRL user page (requires write of fuses / config bits then device reset; XC32 compiler uses pragma config to configur this. I see no other way with GCC) Note that as such, configuring fuse settings with MCC Standalone generator will do no good (it assumes XC32) Linker script modified to shorten rom to avoid the data for eeprom STM32 (CBv2) Using code from https://github.com/STMicroelectronics/STM32CubeF4/tree/master/Projects/STM32F411RE-Nucleo/Applications/EEPROM/EEPROM_Emulation as st_eeprom.h/c Using sectors 1 and 2 isr_vectors must be in sector 0, most of this sector is wasted Flash used by program starts at sector 3. Leaves 464k flash for use. Note that since flash is split, flashing must occur in two stages (boot and main) using dfu-util TODO: Threading model mutexes, dataflow details TODO: Generator use and import process details TODO: Calibration of BNO055 - EEPROM calibration status signature for valid check - Erase only invalidates signature (potentially fewer writes) - If calibration constants are valid, they are applied during bno055 configuration. Applying constants will prevent BNO055 from running calibration routine in bg. Applied calibration is assumed to be good by the sensor (CALIB_STAT has no relevance). - Stored calibration commands - Erase triggers reset of sensor causing constants to be lost and auto calibration routine to run - Store triggers reset of sensor using the newly stored constants (thus no auto calibration runs) - Load will send the stuff from eeprom - There are separate BNO055 commands to read its calibration status register and the values from its calibration registers (these are only valid if CALIB_STAT is 3 for sensors used and BNO055 is in config mode) - What are each of the calibration constants (offsets, radius)","title":"Implementation Details"},{"location":"firmware/developing/","text":"Firmware Development Build and Flash Building and flashing the firmware should follow the same process described here . Debugging OpenOCD config files exist in tools/debug . The following configurations exist ControlBoard Version Debugger / Debug Probe Config Name v1 CMSIS-DAP* cb_v1_via_cmsisdap.cfg v2 ST-LINK v2 cb_v2_via_stlink2.cfg *The PicoProbe firmware can be used to turn a low cost Raspberry Pi Pico board into a CMSIS-DAP debugger. Note that OpenOCD must be installed and in the PATH . Note: NEVER power the system from both the debug probe and USB at the same time. Generally, power the system over USB and do not connect the power (3.3V) from the debug probe. Signals and GND must be connected from the debug probe. Generator Projects Each version of ControlBoard has an associated \"Generator\" project. These are projects used with the chip manufacturer's tools to generate startup / configuration / library code for the chip. Note: If you are just building the firmware you do not need to understand the generator projects. The necessary portions of each project are copied to the thirdparty folder. These are used for building. The generator projects are only used if something that was generated needs to be changed (or something new needs to be generated). Why Generators The decision to use generator projects comes down to the following There are multiple versions of Control Board with multiple chips. Using generators to create chip-specific initialization code reduces the chip-specific parts of the firmware that must be written / maintained. The generators are often required to use the manufacturer's HAL (or make using the HAL much easier). Use of the manufacturer's HAL / libraries reduces development time and makes maintenance easier (especially for those less familiar with the codebase). Having a GUI tool (which these generators usually are) to configure the system is an easy way to quickly understand the architecture of the system (clocks, peripheral use, pinout, etc). Running the Generator(s) Control Board v1 Control Board v1 uses an Adafruit ItsyBitsy M4 board (Microchip ATSAMD51G19A chip). The generator used for this project is MCC Standalone . This tool is available for download on Windows, macOS, and Linux. Tested with v5.2.1 of MCC Standalone. Once installed Launch the application Make sure the Harmony Content Path is set in Tools > Options . This should only need to be done once per computer. Recommended path is ~/.mcc/harmony/v3 . File > Load Configuration Choose generator_projects/ControlBoard_v1/firmware/ControlBoard_v1/ControlBoard_v1.mc3 You will likely be prompted to install MPLAB Harmony content. Install it. Click \"Generate\" in the top left. Control Board v2 Control Board v2 uses a WeAct Studio Black Pill board (STMicro STM32F411CEU chip). The generator used for this project is STM32CubeMX . This tool is available for download on Windows, macOS, and Linux. Tested with v6.6.1 of STM32CubeMX. Once installed Launch the application File > Load Project Choose generator_projects/ControlBoard_v2/ControlBoard_v2.ioc Install any required packs (as prompted) Click \"Generate Code\" in the top right. Importing from Generators After running the generator (as described above) the generated code must be imported to the project. The import process is mostly just copying generated files, however some files are modified slightly. The import process is handled by the import_from_generator.py script. If additional components are added in the generator projects, this script may need to be modified to import additional components. When this script is run, it will prompt a version of control board to import generated code for. This script must be run after each time the generator project is modified and code is re-generated. Development using VSCode Install the C/C++ and CMake Tools extensions, then open this folder in VSCode. Choose one of the configure presets on the bottom bar. Then, choose a build preset. Finally, click build. To debug, install the Cortex-Debug extension in VSCode. Copy tools/debug/launch.json to .vscode . MAKE SURE TO BUILD DEBUG CONFIG BEFORE LAUNCHING DEBUG SESSION. IT WILL NOT BUILD AUTOMATICALLY. Development using the Simulator The simulator can be very helpful for developing or debugging firmware. The simulator is capable of connecting to a real control board, thus the firmware can be tested in simulation. Note that the simulator also offers a simulated control board (simcb), but this is not what we want in this case. The simulated control board does not use a real control board / firmware. Testing with the simulator can also be done while the control board firmware is running with a debugger attached. To test with the simulator (your development system will need the simulator running and two USB ports are required) Connect the control board to your PC via USB Connect a debug probe to the control board (do NOT connect power) Build and run the firmware under debugger In the simulator, choose the UART port for the control board Interface scripts can be run as usual using launch.py , but add the -s flag so it will connect to the simulator instead of the physical control board. In the setup described above, the simulator connects to and uses the control board. The interface scripts connect to the simulator. The simulator forwards messages from interface scripts to control board and vice versa. The simulator provides simulated sensor data to the control board and the control board provides the simulator with thruster motions. There are a few things to not about the simulation It does increase traffic over control board UART / USB significantly (shouldn't cause issues, but something to be aware of for debugging purposes) Sensor data is provided by the simulator, thus sensors will report ready even if not connected. If real sensors are connected, they will be read as normal, however the data will be ignored and simulated data used instead. This allows connecting sensors to create more realistic test scenarios (timing and scheduling wise). When controlled by the simulator, the control board will not generate PWM signals on thruster pins. The thruster pins will maintain a pulse corresponding to no motion. IMU axis configuration has no effect in the simulator (though the command will still be acknowledged)","title":"Firmware Development"},{"location":"firmware/developing/#firmware-development","text":"","title":"Firmware Development"},{"location":"firmware/developing/#build-and-flash","text":"Building and flashing the firmware should follow the same process described here .","title":"Build and Flash"},{"location":"firmware/developing/#debugging","text":"OpenOCD config files exist in tools/debug . The following configurations exist ControlBoard Version Debugger / Debug Probe Config Name v1 CMSIS-DAP* cb_v1_via_cmsisdap.cfg v2 ST-LINK v2 cb_v2_via_stlink2.cfg *The PicoProbe firmware can be used to turn a low cost Raspberry Pi Pico board into a CMSIS-DAP debugger. Note that OpenOCD must be installed and in the PATH . Note: NEVER power the system from both the debug probe and USB at the same time. Generally, power the system over USB and do not connect the power (3.3V) from the debug probe. Signals and GND must be connected from the debug probe.","title":"Debugging"},{"location":"firmware/developing/#generator-projects","text":"Each version of ControlBoard has an associated \"Generator\" project. These are projects used with the chip manufacturer's tools to generate startup / configuration / library code for the chip. Note: If you are just building the firmware you do not need to understand the generator projects. The necessary portions of each project are copied to the thirdparty folder. These are used for building. The generator projects are only used if something that was generated needs to be changed (or something new needs to be generated).","title":"Generator Projects"},{"location":"firmware/developing/#why-generators","text":"The decision to use generator projects comes down to the following There are multiple versions of Control Board with multiple chips. Using generators to create chip-specific initialization code reduces the chip-specific parts of the firmware that must be written / maintained. The generators are often required to use the manufacturer's HAL (or make using the HAL much easier). Use of the manufacturer's HAL / libraries reduces development time and makes maintenance easier (especially for those less familiar with the codebase). Having a GUI tool (which these generators usually are) to configure the system is an easy way to quickly understand the architecture of the system (clocks, peripheral use, pinout, etc).","title":"Why Generators"},{"location":"firmware/developing/#running-the-generators","text":"","title":"Running the Generator(s)"},{"location":"firmware/developing/#control-board-v1","text":"Control Board v1 uses an Adafruit ItsyBitsy M4 board (Microchip ATSAMD51G19A chip). The generator used for this project is MCC Standalone . This tool is available for download on Windows, macOS, and Linux. Tested with v5.2.1 of MCC Standalone. Once installed Launch the application Make sure the Harmony Content Path is set in Tools > Options . This should only need to be done once per computer. Recommended path is ~/.mcc/harmony/v3 . File > Load Configuration Choose generator_projects/ControlBoard_v1/firmware/ControlBoard_v1/ControlBoard_v1.mc3 You will likely be prompted to install MPLAB Harmony content. Install it. Click \"Generate\" in the top left.","title":"Control Board v1"},{"location":"firmware/developing/#control-board-v2","text":"Control Board v2 uses a WeAct Studio Black Pill board (STMicro STM32F411CEU chip). The generator used for this project is STM32CubeMX . This tool is available for download on Windows, macOS, and Linux. Tested with v6.6.1 of STM32CubeMX. Once installed Launch the application File > Load Project Choose generator_projects/ControlBoard_v2/ControlBoard_v2.ioc Install any required packs (as prompted) Click \"Generate Code\" in the top right.","title":"Control Board v2"},{"location":"firmware/developing/#importing-from-generators","text":"After running the generator (as described above) the generated code must be imported to the project. The import process is mostly just copying generated files, however some files are modified slightly. The import process is handled by the import_from_generator.py script. If additional components are added in the generator projects, this script may need to be modified to import additional components. When this script is run, it will prompt a version of control board to import generated code for. This script must be run after each time the generator project is modified and code is re-generated.","title":"Importing from Generators"},{"location":"firmware/developing/#development-using-vscode","text":"Install the C/C++ and CMake Tools extensions, then open this folder in VSCode. Choose one of the configure presets on the bottom bar. Then, choose a build preset. Finally, click build. To debug, install the Cortex-Debug extension in VSCode. Copy tools/debug/launch.json to .vscode . MAKE SURE TO BUILD DEBUG CONFIG BEFORE LAUNCHING DEBUG SESSION. IT WILL NOT BUILD AUTOMATICALLY.","title":"Development using VSCode"},{"location":"firmware/developing/#development-using-the-simulator","text":"The simulator can be very helpful for developing or debugging firmware. The simulator is capable of connecting to a real control board, thus the firmware can be tested in simulation. Note that the simulator also offers a simulated control board (simcb), but this is not what we want in this case. The simulated control board does not use a real control board / firmware. Testing with the simulator can also be done while the control board firmware is running with a debugger attached. To test with the simulator (your development system will need the simulator running and two USB ports are required) Connect the control board to your PC via USB Connect a debug probe to the control board (do NOT connect power) Build and run the firmware under debugger In the simulator, choose the UART port for the control board Interface scripts can be run as usual using launch.py , but add the -s flag so it will connect to the simulator instead of the physical control board. In the setup described above, the simulator connects to and uses the control board. The interface scripts connect to the simulator. The simulator forwards messages from interface scripts to control board and vice versa. The simulator provides simulated sensor data to the control board and the control board provides the simulator with thruster motions. There are a few things to not about the simulation It does increase traffic over control board UART / USB significantly (shouldn't cause issues, but something to be aware of for debugging purposes) Sensor data is provided by the simulator, thus sensors will report ready even if not connected. If real sensors are connected, they will be read as normal, however the data will be ignored and simulated data used instead. This allows connecting sensors to create more realistic test scenarios (timing and scheduling wise). When controlled by the simulator, the control board will not generate PWM signals on thruster pins. The thruster pins will maintain a pulse corresponding to no motion. IMU axis configuration has no effect in the simulator (though the command will still be acknowledged)","title":"Development using the Simulator"},{"location":"firmware/math/","text":"Math Coordinate System Definition The control board uses a coordinate system that is somewhat non-standard. The coordinate system is right handed +y is forward, +z is up, +x is right Pitch is about x, roll is about y, yaw is about z While this coordinate system may seem strange to some (especially anyone who has worked with planes), the name of axes doesn't really matter. 6 Degree of Freedom Motion Control Nomenclature & Convention Notes Matrices are assumed to be zero indexed (not 1 indexed). This means the first element of a matrix \\(M\\) is \\(m_{00}\\) not \\(m_{11}\\) . This is because the math will be implemented in C (which uses zero indexed arrays). Thruster numbers (1-8) are used by the control board's user facing components. However, this math will use thruster indices (0-7) where index = number - 1 . This is b Rotations about axis (angular velocities / DoFs) are referred to as \"xrot\" (about x), \"yrot\" (about y), and \"zrot\" (about z). The terms \"pitch\", \"roll\", and \"yaw\" are used to describe the vehicle's orientation in space. \"Pitch\" is angular velocity about the x-axis, \"roll\" is angular rotation about the y-axis, and \"yaw\" is angular velocity about the z-axis. Velocities in DoFs are normalized (meaning -1.0 to 1.0). System Assumptions Vehicle is capable of motion exclusively in each of 6 degrees of freedom (DoFs). These are three translational DoFs, and three rotational DoFs. The vehicle's speed in positive and negative directions are roughly equal for each DoF. Thruster orientations are fixed. Gimbaled thruster vehicles are not supported. At most 8 thrusters (less is fine) System has 3D orientation information System has depth information System does not have translational position information Example Vehicle The examples on this page will use AquaPack robotics's SeaWolf VIII robot. This robot's thruster configuration is as shown below. The arrows indicate the direction a thruster moves water (meaning the arrows are opposite the direction the thruster excerpts force on the vehicle). The arrows indicate the direction the thruster moves water when powered in the positive direction. These arrows are opposite the direction force is excerpted on the vehicle. Note that the diagram above uses thruster numbers, not indices. DoF Matrix The DoF Matrix , \\(D\\) , is constructed based on the vehicle's thruster configuration. Rows of the matrix correspond to thrusters (by index). And columns of the matrix correspond to vehicle relative DoFs. Thus, this is an 8x6 matrix. Columns correspond to DoFs in the following order (0-5): x, y, z, pitch, roll, yaw. Note that pitch, roll, and yaw are written using the single variable notation p, r, h (h = heading = yaw). \\(D = \\left(\\begin{array}{c|c|c|c|c|c} d_0 & d_1 & d_2 & d_3 & d_4 & d_5 \\end{array}\\right) = \\left(\\begin{array}{c|c|c|c|c|c} d_x & d_y & d_z & d_p & d_r & d_h \\end{array}\\right)\\) Each column of the DoF matrix, \\(d_i\\) is a set of thruster speeds that result in motion exclusively in the column's DoF. Additionally, the resultant motion should be the maximum possible speed, and in the positive direction. Each \\(d_i\\) is an 8 element column vector, with elements corresponding to thrusters (by index). All speeds should be normalized (between -1.0 and 1.0) For the example vehicle shown above, the following is the DoF matrix \\(D = \\begin{pmatrix} -1 & -1 & 0 & 0 & 0 & +1 \\\\ +1 & -1 & 0 & 0 & 0 & -1 \\\\ -1 & +1 & 0 & 0 & 0 & -1 \\\\ +1 & +1 & 0 & 0 & 0 & +1 \\\\ 0 & 0 & -1 & -1 & -1 & 0 \\\\ 0 & 0 & -1 & -1 & +1 & 0 \\\\ 0 & 0 & -1 & +1 & -1 & 0 \\\\ 0 & 0 & -1 & +1 & +1 & 0 \\\\ \\end{pmatrix}\\) Consider the first column: \\(d_0 = d_x\\) . This column's thruster speeds should result in the vehicle moving as fast as possible in the +x direction (only). This is achieved by setting T2, T4 (index 1, 3) to the positive direction and T1, T3 (index 0, 2) to the negative direction at full speed (recall that the arrows are opposite the direction the thruster excerpts force on the vehicle). Thus \\(d_x = \\begin{pmatrix}-1 & +1 & -1 & +1 & 0 & 0 & 0 & 0\\end{pmatrix}^T\\) Note that when constructing the DoF matrix for your vehicle, you should assume an ideal system and environment. LOCAL Mode Motion In LOCAL mode, motion is specified as a set of speeds in vehicle relative DoFs. The user provides the control board with a local target motion vector ( \\(t_l\\) ) where each element corresponds to a DoF. \\(t_l = \\begin{pmatrix} x & y & z & r_x & r_y & r_z \\end{pmatrix}^T\\) \\(x\\) is normalized velocity in +x direction \\(y\\) is normalized velocity in +y direction \\(z\\) is normalized velocity in +y direction \\(r_x\\) is normalized velocity in +pitch direction (xrot) \\(r_y\\) is normalized velocity in +roll direction (yrot) \\(r_z\\) is normalized velocity in +yaw direction (zrot) By multiplying this target motion by the DoF matrix, \\(D\\) , a speed vector \\(s\\) is obtained where each element of \\(s\\) corresponds to a specific thruster (by index). \\(s = D t_l\\) Consider the example where \\(t_l = \\begin{pmatrix}0 & 1 & 0 & 0 & 0 & 0\\end{pmatrix}^T\\) . This should cause the vehicle to move at full possible speed forward (relative to the vehicle's orientation). \\(s = D t_l = \\begin{pmatrix} -1 & -1 & 0 & 0 & 0 & +1 \\\\ +1 & -1 & 0 & 0 & 0 & -1 \\\\ -1 & +1 & 0 & 0 & 0 & -1 \\\\ +1 & +1 & 0 & 0 & 0 & +1 \\\\ 0 & 0 & -1 & -1 & -1 & 0 \\\\ 0 & 0 & -1 & -1 & +1 & 0 \\\\ 0 & 0 & -1 & +1 & -1 & 0 \\\\ 0 & 0 & -1 & +1 & +1 & 0 \\\\ \\end{pmatrix} \\begin{pmatrix}0 \\\\ 1 \\\\ 0 \\\\ 0 \\\\ 0 \\\\ 0\\end{pmatrix} = \\begin{pmatrix}-1 \\\\ -1 \\\\ +1 \\\\ +1 \\\\ 0 \\\\ 0 \\\\ 0 \\\\ 0\\end{pmatrix}\\) In the above example, it is trivial to see that this is the desired motion. However for a more complex example, a problem appears. Consider \\(t_l = \\begin{pmatrix}0 & 1 & 0 & 0 & 0 & 1\\end{pmatrix}^T\\) . This describes the vehicle both moving forward and yawing at full possible speed. \\(s = D t_l = \\begin{pmatrix} -1 & -1 & 0 & 0 & 0 & +1 \\\\ +1 & -1 & 0 & 0 & 0 & -1 \\\\ -1 & +1 & 0 & 0 & 0 & -1 \\\\ +1 & +1 & 0 & 0 & 0 & +1 \\\\ 0 & 0 & -1 & -1 & -1 & 0 \\\\ 0 & 0 & -1 & -1 & +1 & 0 \\\\ 0 & 0 & -1 & +1 & -1 & 0 \\\\ 0 & 0 & -1 & +1 & +1 & 0 \\\\ \\end{pmatrix} \\begin{pmatrix}0 \\\\ 1 \\\\ 0 \\\\ 0 \\\\ 0 \\\\ 1\\end{pmatrix} = \\begin{pmatrix}0 \\\\ -2 \\\\ 0 \\\\ +2 \\\\ 0 \\\\ 0 \\\\ 0 \\\\ 0\\end{pmatrix}\\) Notice that the resultant speed vector has motors moving in excess of 100% speed (elements with magnitude greater than 1.0). This is not possible. While a simple solution may seem to be dividing all elements of the vector by the one with the largest magnitude. This results in a scaled speed vector \\(\\hat{s}\\) \\(\\hat{s} = s \\div \\text{absmax}(s)\\) this will not work well in all cases. Consider \\(t_l = \\begin{pmatrix}0 & 1 & 1 & 1 & 1 & 1\\end{pmatrix}^T\\) . \\(s = D t_l = \\begin{pmatrix} -1 & -1 & 0 & 0 & 0 & +1 \\\\ +1 & -1 & 0 & 0 & 0 & -1 \\\\ -1 & +1 & 0 & 0 & 0 & -1 \\\\ +1 & +1 & 0 & 0 & 0 & +1 \\\\ 0 & 0 & -1 & -1 & -1 & 0 \\\\ 0 & 0 & -1 & -1 & +1 & 0 \\\\ 0 & 0 & -1 & +1 & -1 & 0 \\\\ 0 & 0 & -1 & +1 & +1 & 0 \\\\ \\end{pmatrix} \\begin{pmatrix}0 \\\\ 1 \\\\ 1 \\\\ 1 \\\\ 1 \\\\ 1\\end{pmatrix} = \\begin{pmatrix}0 \\\\ -2 \\\\ 0 \\\\ +2 \\\\ -3 \\\\ -1 \\\\ -1 \\\\ +1\\end{pmatrix}\\) and \\(\\hat{s} = s \\div \\text{absmax}(s) = s \\div 3 = \\begin{pmatrix}0 \\\\ -0.67 \\\\ 0 \\\\ +0.67 \\\\ -1 \\\\ -0.33 \\\\ -0.33 \\\\ +0.33\\end{pmatrix}\\) While this has resulted in an possible set of thruster speeds, these are not optimal. Look at the example vehicle diagram. Notice that thrusters 1-4 and 5-8 control different motions. In the previous example, thrusters 1-4 were slowed down more than necessary, because thruster 5 was too large of a value. This is not ideal as the vehicle's maximum speed becomes artificially limited. Instead, the following \\(\\hat{s}\\) is ideal. This is scaling down the thrusters within each group (1-4 and 5-8) separately. \\(\\hat{s} = \\begin{pmatrix}0 \\\\ -1 \\\\ 0 \\\\ +1 \\\\ -1 \\\\ -0.33 \\\\ -0.33 \\\\ +0.33\\end{pmatrix}\\) Groupings of thrusters on the example vehicle are easy to observe, however this is not always true. Thus, achieving optimal scaling for any system (any DoF matrix) requires a more sophisticated method to determine groupings and scale speeds. Thruster groupings are determined by \"overlap\" between thrusters. Two thrusters, \\(i\\) and \\(j\\) are said to overlap if they have a non-zero entry in the same column of the DoF matrix ( \\(D\\) ) for at least one column. This is easier to calculate using a contribution matrix , \\(C\\) , defined as \\(D \\neq 0\\) . This results in a binary form of the DoF matrix. For the above example \\(C = \\left[\\begin{pmatrix} -1 & -1 & 0 & 0 & 0 & +1 \\\\ +1 & -1 & 0 & 0 & 0 & -1 \\\\ -1 & +1 & 0 & 0 & 0 & -1 \\\\ +1 & +1 & 0 & 0 & 0 & +1 \\\\ 0 & 0 & -1 & -1 & -1 & 0 \\\\ 0 & 0 & -1 & -1 & +1 & 0 \\\\ 0 & 0 & -1 & +1 & -1 & 0 \\\\ 0 & 0 & -1 & +1 & +1 & 0 \\\\ \\end{pmatrix} \\neq 0 \\right] = \\begin{pmatrix} 1 & 1 & 0 & 0 & 0 & 1 \\\\ 1 & 1 & 0 & 0 & 0 & 1 \\\\ 1 & 1 & 0 & 0 & 0 & 1 \\\\ 1 & 1 & 0 & 0 & 0 & 1 \\\\ 0 & 0 & 1 & 1 & 1 & 0 \\\\ 0 & 0 & 1 & 1 & 1 & 0 \\\\ 0 & 0 & 1 & 1 & 1 & 0 \\\\ 0 & 0 & 1 & 1 & 1 & 0 \\\\ \\end{pmatrix}\\) Then for each thruster \\(i\\) an overlap vector \\(o_i\\) can be constructed as follows \\(o_i = C (c^i)^T\\) where \\(c^i\\) is the \\(i\\) th row of \\(C\\) . Thus, \\(o_i\\) is an 8 element vector where each element corresponds to a thruster (by index). Element \\(j\\) of \\(o_i\\) can either be \\(1\\) or a \\(0\\) . \\(1\\) indicates that thrusters \\(i\\) and \\(j\\) overlap. For example, \\(o_0 = C (c^0)^T = \\begin{pmatrix} 1 & 1 & 1 & 1 & 0 & 0 & 0 & 0 \\end{pmatrix}^T\\) This shows that thruster index 0 (T1) overlaps with indices 0, 1, 2, and 3 (T1, T2, T3, T4). By calculating and storing these overlap vectors for each thruster ( \\(\\left\\{o_i\\right\\}_{i=0}^7\\) ), this effectively forms a lookup table to determine thruster overlap. While this is not the most memory efficient option, it reduces computation time, which is important since this will run very frequently on a microcontroller. Using overlap vectors, the following algorithm can be used to scale motor speeds: Find the thruster ( i ) with the largest magnitude speed Iterate over thruster i 's overlap vector For any thruster i overlaps with ( j ), divide thruster j 's speed by the magnitude of thruster i 's speed Repeat until the largest magnitude does not exceed 1.0 while true // m is value, i is index m, i = max(abs(speed_vector)) if m <= 1.0 // Done scaling break endif // Iterate over all thrusters (0-7 inclusive) for j=0...7 if overlap_vector[i][j] == 1 // i and j overlap. Divide j's speed by m. speed_vector[j] /= m endif endfor endwhile This algorithm results in optimal speed scaling by only reducing the speed of thrusters that share DoF contributions. GLOBAL Mode Motion GLOBAL mode is very similar to LOCAL mode, however, motion is described partially relative to the world instead of the robot. Specifically, motion of the vehicle is compensated for vehicle pitch and roll (but not yaw). This results in a coordinate system defined by the axes gx , gy , and gz . Note that the world coordinate system is defined as wx , wy , wz . Notably, if the vehicle is pitched 180 degrees, the gx-gy plane becomes aligned to the back of the vehicle ensuring consistent motion. This is shown in the animation below. In GLOBAL mode, the user provides the control board with a global target motion vector , \\(t_g\\) with 6 elements. This target motion vector is a concatenation of two 3 dimensional vectors. The first, a set of translations along gx , gy , and gz . Second a set of rotations to affect vehicle pitch, roll, and yaw. These are referred to by the following names x : Speed in gx direction (translation) y : Speed in gy direction (translation) z : Speed in gz direction (translation) p : Speed at which the vehicle's pitch should increase (negative for decrease pitch). Aka \"pitch_spd\" r : Speed at which the vehicle's roll should increase (negative for decrease pitch). Aka \"roll_spd\" h : Speed at which the vehicle's yaw should increase (negative for decrease pitch). Aka \"yaw_spd\" \\(t_g = \\begin{pmatrix} x & y & z & p & r & h \\end{pmatrix}\\) It is necessary to transform each DoF's motion into motions in the vehicle's DoFs. These speeds can then be passed to LOCAL mode. WARNING: GLOBAL mode is impacted by gimbal lock issues with euler angles. This occurs when the vehicle's pitch is +/- 90 degrees. In this scenario the meaning of \"increase / decrease pitch\" is ambiguous. The vehicle will take the zero-roll route in this scenario. Thus, GLOBAL mode may produce undesirable motion if the roll is non-zero and you pitch through +/- 90. A potential solution for this could be some form of motion hysteresis to handle moving through gimbal lock orientations, however this is not implemented as of now. Translation DoFs The translation DoFs are easily transformed using gravity vectors. By applying a quaternion based rotation matrix to the base gravity vector, \\(g_b = \\begin{pmatrix}0 & 0 & -1\\end{pmatrix}\\) , the following solution is determined for the current gravity vector, \\(g_c\\) given the vehicle's orientation quaternion, \\(q\\) . \\(\\begin{pmatrix} 2*(q.x*q.z+q.w*q.y) \\\\ 2*(q.w*q.x-q.y*q.z) \\\\ -(q.w)^2+(q.x)^2+(q.y)^2-(q.z)^2\\end{pmatrix}^T\\) The minimal rotation from \\(g_b\\) to \\(g_c\\) is then calculated. Let this rotation be called \\(q_{rot}\\) . This rotation will generally include no yaw component, unless the vehicle is upside down and facing backwards (eg pitch of 180 degrees) in which case it will contain a yaw component of 180 degrees. This is desirable as it ensures a continuous definition of what gy is even while the vehicle is flipping via pitch. This quaternion can then be applied to speeds in the gx , gy , gz basis ( x , y , and z here) to rotate them onto the vehicle basis. Thus, this \"converts\" translation speeds from GLOBAL to LOCAL mode DoFs. However, it is not ideal to transform the translation vector all at once. It is best to do it in three stages to allow proper upscaling as needed (explained below). Thus for each global mode translation vector \\(\\begin{pmatrix} 0 & y & 0 \\end{pmatrix}\\) , \\(\\begin{pmatrix} 0 & 0 & z \\end{pmatrix}\\) , and \\(\\begin{pmatrix} x & 0 & 0 \\end{pmatrix}\\) rotate it by \\(q_{rot}\\) to obtain \\(t_x\\) , \\(t_y\\) , and \\(t_z\\) respectively (note that \\(\\left\\{s, v\\right\\}\\) is a quaternion with scalar s and vector v). \\(\\left\\{0, t_x\\right\\} = q_{rot} \\left\\{0, \\begin{pmatrix} x & 0 & 0 \\end{pmatrix} \\right\\} q_{rot}^*\\) \\(\\left\\{0, t_y\\right\\} = q_{rot} \\left\\{0, \\begin{pmatrix} 0 & y & 0 \\end{pmatrix} \\right\\} q_{rot}^*\\) \\(\\left\\{0, t_z\\right\\} = q_{rot} \\left\\{0, \\begin{pmatrix} 0 & 0 & z \\end{pmatrix} \\right\\} q_{rot}^*\\) Each of \\(t_x\\) , \\(t_y\\) , and \\(t_z\\) are speeds in LOCAL mode DoFs, however they may be slower than desired. Consider a speed of 1.0 along gy . If the vehicle were rotated 45 degrees (pitch) the resultant \\(t_y\\) would be \\(t_y = \\begin{pmatrix} 0.0 & 0.7071 & 0.7071 \\end{pmatrix}\\) . This is not as fast as possible in the correct direction. Instead \\(t_y\\) should be \\(t_y = \\begin{pmatrix} 0.0 & 1.0 & 1.0 \\end{pmatrix}\\) . In other words, the largest element of \\(t_y\\) should be the speed along gy . Thus, each of \\(t_x\\) , \\(t_y\\) , \\(t_z\\) needs to be upscaled (note that it will never need to be downscaled; it only needs to be upscaled because one DoF may now be spread between multiple). let \\(m\\) be the magnitude of the element of \\(t_x\\) with the largest magnitude Normalize \\(t_x\\) so that largest element is 1.0: \\(t_x = t_x / m\\) Scale normalized \\(t_x\\) by speed \\(x\\) (gx speed): \\(t_x = t_x * x\\) Repeat this for \\(t_y\\) and \\(t_z\\) using \\(y\\) and \\(z\\) speeds respectively. Once all three \\(t\\) vectors are scaled, they can be combined to create the net LOCAL mode translation vector, \\(l\\) \\(l = t_x + t_y + t_z\\) There are two potential issues with \\(l\\) \\(l\\) is a set of proportionally related speeds to result in the desired motion. However, the vehicle may not be capable of the same speeds in each of it's DoFs. Thus, the ratios between \\(l\\) 's elements may be incorrect. \\(l\\) is a sum of three vectors (each with elements no larger than a magnitude of 1), thus it may have elements with a magnitude greater than 1. Issue 1 should be handled first as correcting it may \"fix\" issue 2. Handling issue 2 first could result in downscaling speeds more than necessary. Handling issue 1 requires the user to provide a little more information about the vehicle: relative speeds in each DoF. These can be used to calculate downscaling factors to slow down the faster directions (note: speeding up the slower directions would result in impossible speeds, but would be handled by solving issue 2; regardless it is less ideal). These downscaling factors are calculated from \"RELDOF\" information provided by the user (see messages page of user guide). Here we will referr to the scale factors as \\(m_x\\) , \\(m_y\\) , \\(m_z\\) , \\(m_{rx}\\) , \\(m_{ry}\\) , and \\(m_{rz}\\) for the x, y, z, xrot, yrot, and zrot DoFs respectively (note that these are vehicle DoFs). Thus, the simplest option would be to let \\(l = \\begin{pmatrix}l.x * m_x & l.y * m_y & l.z * m_z\\end{pmatrix}\\) . However, this may downscale more than necessary. Consider the slowest direction to have a speed of 0 in l. In this case, since the slowest direction is unused, we are downscaling too much. Thus, the following algorithm is used to select the ideal downscaling factors by \"ignoring\" the downscaling required for unused DoFs (DoFs with a speed of 0). // Zero downscale factors for unused DoFs if abs(l.x) == 0 m_x = 0 endif if abs(l.y) == 0 m_y = 0 endif if abs(l.z) == 0 m_z = 0 endif // Rebalance scale factors so largest remaining is 1.0 m_max = max(m_x, max(m_y, m_z)); m_x = m_x / m_max; m_y = m_y / m_max; m_z = m_z / m_max; \\(l\\) is then downscaled as \\(l = \\begin{pmatrix}l.x * m_x & l.y * m_y & l.z * m_z\\end{pmatrix}\\) using the scale factors calculated using the above algorithm. Finally, issue 2 must be handled if any element of \\(l\\) still has a magnitude greater than 1.0. Thus, Let \\(m\\) be the magnitude of the element of \\(l\\) with the largest magnitude If \\(m\\) is less than or equal to 1, do not change $l If \\(m\\) is greater than 1 \\(l = l / m\\) This resultant \\(l\\) is a set of speeds that can be passed to LOCAL mode as it's x , y , and z speeds. Rotation DoFs: Converting the GLOBAL mode rotations (increase/decrease pitch, roll, yaw) to motions about DoFs is a little harder. It requires decomposing the quaternion into euler angles, then calculating three quaternions describing one euler rotation each. In other words, given the vehicle's current rotation \\(q\\) we need to find \\(q_{pitch}\\) , \\(q_{roll}\\) and \\(q_{yaw}\\) such that (based on the euler angle convention used by the control board) \\(q = q_{yaw} q_{pitch} q_{roll}\\) This can be done by converting \\(q\\) to a set of euler angles \\(e = \\begin{pmatrix}pitch & roll & yaw\\end{pmatrix}\\) then constructing the following and converting each to a quaternion \\(e_{pitch} = \\begin{pmatrix}pitch & 0 & 0\\end{pmatrix} \\rightarrow q_{pitch}\\) \\(e_{roll} = \\begin{pmatrix}0 & roll & 0\\end{pmatrix} \\rightarrow q_{roll}\\) \\(e_{yaw} = \\begin{pmatrix}0 & 0 & yaw\\end{pmatrix} \\rightarrow q_{yaw}\\) However, the euler angles obtained from \\(q\\) may not be correct for this use case. An equivalent angle go \\(e\\) (although improper) is \\(e_{alt} = \\begin{pmatrix} \\pi - pitch & roll - \\pi & yaw - \\pi \\end{pmatrix}\\) . We need to compensate for first roll then pitch. Thus, we need the euler angle with minimal roll component. This will be referred to here as \\(e_b\\) (which is either \\(e\\) or \\(_{alt}\\) ). Then, given \\(s\\) vectors describing motion to change the vehicle's pitch, roll, or yaw \\(s_{pitch} = \\begin{pmatrix}p & 0 & 0\\end{pmatrix}\\) \\(s_{roll} = \\begin{pmatrix}0 & r & 0\\end{pmatrix}\\) \\(s_{yaw} = \\begin{pmatrix}0 & 0 & h\\end{pmatrix}\\) We need to transform these onto the robot's axes as \\(w\\) vectors. For roll this is trivial as roll is about the vehicle's y axis. For pitch, this requires undoing roll first (rotate by \\(q_{roll}*\\) ) and for yaw this requires undoing roll then pitch. Thus \\(w_{roll} = s_{roll}\\) \\(\\left\\{0, w_{pitch}\\right\\} = q_{roll}^* \\left\\{0, s_{pitch}\\right\\} q_{roll}\\) \\(\\left\\{0, w_{yaw}\\right\\} = q_{pitch}^* q_{roll}^* \\left\\{0, s_{yaw}\\right\\} q_{roll} q_{pitch}\\) These vectors are angular speeds about the vehicle's x, y, and z axes. Thus, just as for translations Upscale each \\(w\\) vector using p , r , and h speeds (can skip for roll as this vector is never rotated) Sum the three \\(w\\) vectors into a net \\(w\\) vector Adjust \\(w\\) for relative DoF speeds (using \\(m_{rx}\\) , \\(m_{ry}\\) , \\(m_{rz}\\) ) Downscale \\(w\\) if needed so all elements are less than 1 Then \\(w\\) is the xrot, yrot, and zrot parts of the LOCAL mode target. Stability Assist (SASSIST) Mode Motion Stability assist mode (SASSIST) uses closed-loop control for vehicle depth and orientation in 3D space. This is achieved using four PID controllers Depth PID: Controls translation along world z-axis xrot PID: Controls rotation about vehicle x-axis yrot PID: Controls rotation about vehicle y-axis zrot PID: Controls rotation about vehicle z-axis The inputs to SASSIST mode are as follows x : Translation along gx-axis (same as in GLOBAL mode) y : Translation along gy-axis (same as in GLOBAL mode) d_t : Target depth (meters; negative for below the surface) e_t : Target orientation as euler angles Optionally, a yaw speed ( h ) can be provided. In this case, PIDs will not adjust the vehicle's yaw (heading). Instead the h value works similar to GLOBAL mode (it is a rate of change of vehicle yaw). This effectively abstracts a 2D plane in which the vehicle operates. This is the same gx-gy plane described in the GLOBAL mode section. There are two variants of SASSIST mode Variant 1 (SASSIST1): Speed for yaw ( h ) is used instead of PID control Variant 2 (SASSIST2): PID is used for yaw (yaw speed / h is ignored) These two variants are the same in how depth control works. However, variant 1 adds some additional complexity for orientation control. Depth Control A PID controller (sassist depth PID) is used to control the vehicle's speed in the world z (or GLOBAL z) DoF. The output of this PID controller is the same z that could be an input to GLOBAL mode. This PID controller's error is the difference between the user provided target depth and the measured current depth of the vehicle. Translation DoFs The user provided x and y along with the z from the depth PID are handled the same way by SASSIST mode as they are in GLOBAL mode to obtain the final LOCAL mode translation vector \\(l\\) . SASSIST2 Orientation Control While translation for SASSIST is nearly identical to GLOBAL mode, rotation DoFs are very different. Orientation is controlled with a set of 3 PID controllers that work in LOCAL DoFs. Thus it is necessary to determine the rotations necessary about the vehicle's axes to achieve the desired orientation. We are given a target orientation as euler angles, \\(e_t\\) . This can be converted to a target orientation quaternion, \\(q_t\\) . Note: For SASSIST1 things after this point are the same (see section below for details on how to get \\(q_t\\) for SASSIST1). The vehicle's current orientation (as a quaternion) is also available from the IMU as \\(q_c\\) . We need to calculate a quaternion \\(q_d\\) that represents the minimal rotation from \\(q_c\\) to \\(q_t\\) . However, importantly we want \\(q_d\\) to be a rotation in the vehicle's basis. Recall that right multiplication of quaternions are applied in the vehicle's basis. Thus, to describe the target orientation as the current orientation plus a rotation in the vehicle's basis \\(q_t = q_c q_d\\) Therefore \\(q_d = q_c^* q_t\\) However, this angle may not be minimal. Recall that \\(q\\) and \\(-q\\) represent the same orientation. Thus another solution to this problem would be \\(q_d = (-q_c)^* q_t\\) The minimal rotation is the one where \\(q_c\\) and \\(q_t\\) are on the same half of the unit quaternion hypersphere (meaning their dot product is not negative). Thus If \\(q_c \\cdot q_t < 0\\) then \\(q_d = (-q_c)^* q_t\\) Otherwise \\(q_d = q_c^* q_t\\) Then convert \\(q_d\\) to axis-angle representation. The following algorithm is used to do so for numeric stability reasons (the common formulas using asin are not numerically stable) let \\(q_d = \\left\\{s, v\\right\\}\\) \\(\\theta = 2 atan2(|v|, s)\\) \\(n = v / |v|\\) if \\(|v| > 0\\) else \\(n = v = 0\\) This axis ( \\(n\\) ) will be a unit vector. Thus it represents proportions of the rotation about each of the vehicle's axes. The angle ( \\(\\theta\\) ) is the magnitude of the rotation that must be taken. Thus, the product of \\(n\\) and \\(\\theta\\) is proportional to the error in angle about each of the vehicle's axes. \\(e = \\theta n\\) This error vector, \\(e\\) , contains the errors to be provided to each orientation PID (xrot, yrot, zrot). The output of these PIDs are angular velocity percentages (-1.0 to 1.0) about each of the vehicle's axes: \\(w = \\begin{pmatrix} w_x & w_y & w_z \\end{pmatrix}\\) Note: for SASSIST 1 there is an extra step here to calculate the correct w (see section below). Finally, it is necessary to downscale the \\(w\\) vectors just as in GLOBAL mode First downscale using \\(m_{rx}\\) , \\(m_{ry}\\) and \\(m_{rz}\\) using the algorithm described in the GLOBAL mode section Then downscale the vector so that all elements are less than 1. While this is never needed for SASSIST2, it is needed for SASSIST1 and it is simpler branching logic (code implementation) to just always check if downscaling is needed. This \\(w\\) can then be passed to LOCAL mode along with the LOCAL translation vector \\(l\\) obtained earlier. SASSIST1 Orientation Control SASSIST1 uses much of the same process to control the vehicle's orientation as SASSIST2, however it is necessary to decouple yaw from pitch and roll. In other words, we want to construct a target quaternion using the user provided pitch and roll, but matching the vehicle's current yaw. The most intuitive option would be to decompose \\(q_c\\) into euler angles and obtain the yaw from those. However, this does not account for the fact that the yaw can be altered by pitch or roll. For example, (p=115, r=0, h=90) would be decomposed as (p=65, r=180, h=-90). Here the heading is 180 degrees off. This would be a significant issue. Thus instead, the target quaternion can be decomposed using the swing-twist decomposition of quaternion rotations. We twist about the world z axis (since this is the axis the vehicle initially yawed about). The vehicle's yaw can be calculated from this twist quaternion (using euler conversion formula). The target quaternion is constructed from the target pitch and roll provided by the user and the yaw provided by the twist quaternion as described above. This target quaternion is \\(q_t\\) and is used the same way described for SASSIST2. After calculating \\(w\\) as described for SASSIST2, there is one extra step before handling DoF scaling. The yaw speed ( h ) provided by the user must be transformed to the vehicle's axes and added to the \\(w\\) from the PIDs. This can be done similar to GLOBAL mode \\(\\left\\{0, w_{yaw}\\right\\} = q_{rot} \\left\\{0, \\begin{pmatrix}0 & 0 & h\\end{pmatrix}\\right\\} q_{rot}^*\\) \\(w_{yaw}\\) will then be upscaled just as in GLOBAL mode. Then \\(w = w + w_{yaw}\\) . This is then downscaled as described for SASSIST2. Depth Hold (DHOLD) Mode Motion Depth hold (DHOLD) mode is GLOBAL mode but using a PID to control the vehicle's depth. The same depth PID used for SASSIST mode is used for DHOLD mode. This mode uses the vehicle's current depth and a user provided target depth to calcualte the depth PIDs error. The depth PID provides the gz-axis speed. Other speeds ( x , y , p , r , and h ) are provided by the user and mean the same thing as in GLOBAL mode. The calculated z along with user-provided speeds are passed directly to GLOBAL mode after calculating z using the depth PID. Sensor Processing TODO: Euler angle accumulation Other Derivations TODO: Euler / Quaternion conversion TODO: Gravity vector calculation TODO: Angle between vectors TODO: Min diff quat between two quats","title":"Math"},{"location":"firmware/math/#math","text":"","title":"Math"},{"location":"firmware/math/#coordinate-system-definition","text":"The control board uses a coordinate system that is somewhat non-standard. The coordinate system is right handed +y is forward, +z is up, +x is right Pitch is about x, roll is about y, yaw is about z While this coordinate system may seem strange to some (especially anyone who has worked with planes), the name of axes doesn't really matter.","title":"Coordinate System Definition"},{"location":"firmware/math/#6-degree-of-freedom-motion-control","text":"","title":"6 Degree of Freedom Motion Control"},{"location":"firmware/math/#nomenclature-convention-notes","text":"Matrices are assumed to be zero indexed (not 1 indexed). This means the first element of a matrix \\(M\\) is \\(m_{00}\\) not \\(m_{11}\\) . This is because the math will be implemented in C (which uses zero indexed arrays). Thruster numbers (1-8) are used by the control board's user facing components. However, this math will use thruster indices (0-7) where index = number - 1 . This is b Rotations about axis (angular velocities / DoFs) are referred to as \"xrot\" (about x), \"yrot\" (about y), and \"zrot\" (about z). The terms \"pitch\", \"roll\", and \"yaw\" are used to describe the vehicle's orientation in space. \"Pitch\" is angular velocity about the x-axis, \"roll\" is angular rotation about the y-axis, and \"yaw\" is angular velocity about the z-axis. Velocities in DoFs are normalized (meaning -1.0 to 1.0).","title":"Nomenclature &amp; Convention Notes"},{"location":"firmware/math/#system-assumptions","text":"Vehicle is capable of motion exclusively in each of 6 degrees of freedom (DoFs). These are three translational DoFs, and three rotational DoFs. The vehicle's speed in positive and negative directions are roughly equal for each DoF. Thruster orientations are fixed. Gimbaled thruster vehicles are not supported. At most 8 thrusters (less is fine) System has 3D orientation information System has depth information System does not have translational position information","title":"System Assumptions"},{"location":"firmware/math/#example-vehicle","text":"The examples on this page will use AquaPack robotics's SeaWolf VIII robot. This robot's thruster configuration is as shown below. The arrows indicate the direction a thruster moves water (meaning the arrows are opposite the direction the thruster excerpts force on the vehicle). The arrows indicate the direction the thruster moves water when powered in the positive direction. These arrows are opposite the direction force is excerpted on the vehicle. Note that the diagram above uses thruster numbers, not indices.","title":"Example Vehicle"},{"location":"firmware/math/#dof-matrix","text":"The DoF Matrix , \\(D\\) , is constructed based on the vehicle's thruster configuration. Rows of the matrix correspond to thrusters (by index). And columns of the matrix correspond to vehicle relative DoFs. Thus, this is an 8x6 matrix. Columns correspond to DoFs in the following order (0-5): x, y, z, pitch, roll, yaw. Note that pitch, roll, and yaw are written using the single variable notation p, r, h (h = heading = yaw). \\(D = \\left(\\begin{array}{c|c|c|c|c|c} d_0 & d_1 & d_2 & d_3 & d_4 & d_5 \\end{array}\\right) = \\left(\\begin{array}{c|c|c|c|c|c} d_x & d_y & d_z & d_p & d_r & d_h \\end{array}\\right)\\) Each column of the DoF matrix, \\(d_i\\) is a set of thruster speeds that result in motion exclusively in the column's DoF. Additionally, the resultant motion should be the maximum possible speed, and in the positive direction. Each \\(d_i\\) is an 8 element column vector, with elements corresponding to thrusters (by index). All speeds should be normalized (between -1.0 and 1.0) For the example vehicle shown above, the following is the DoF matrix \\(D = \\begin{pmatrix} -1 & -1 & 0 & 0 & 0 & +1 \\\\ +1 & -1 & 0 & 0 & 0 & -1 \\\\ -1 & +1 & 0 & 0 & 0 & -1 \\\\ +1 & +1 & 0 & 0 & 0 & +1 \\\\ 0 & 0 & -1 & -1 & -1 & 0 \\\\ 0 & 0 & -1 & -1 & +1 & 0 \\\\ 0 & 0 & -1 & +1 & -1 & 0 \\\\ 0 & 0 & -1 & +1 & +1 & 0 \\\\ \\end{pmatrix}\\) Consider the first column: \\(d_0 = d_x\\) . This column's thruster speeds should result in the vehicle moving as fast as possible in the +x direction (only). This is achieved by setting T2, T4 (index 1, 3) to the positive direction and T1, T3 (index 0, 2) to the negative direction at full speed (recall that the arrows are opposite the direction the thruster excerpts force on the vehicle). Thus \\(d_x = \\begin{pmatrix}-1 & +1 & -1 & +1 & 0 & 0 & 0 & 0\\end{pmatrix}^T\\) Note that when constructing the DoF matrix for your vehicle, you should assume an ideal system and environment.","title":"DoF Matrix"},{"location":"firmware/math/#local-mode-motion","text":"In LOCAL mode, motion is specified as a set of speeds in vehicle relative DoFs. The user provides the control board with a local target motion vector ( \\(t_l\\) ) where each element corresponds to a DoF. \\(t_l = \\begin{pmatrix} x & y & z & r_x & r_y & r_z \\end{pmatrix}^T\\) \\(x\\) is normalized velocity in +x direction \\(y\\) is normalized velocity in +y direction \\(z\\) is normalized velocity in +y direction \\(r_x\\) is normalized velocity in +pitch direction (xrot) \\(r_y\\) is normalized velocity in +roll direction (yrot) \\(r_z\\) is normalized velocity in +yaw direction (zrot) By multiplying this target motion by the DoF matrix, \\(D\\) , a speed vector \\(s\\) is obtained where each element of \\(s\\) corresponds to a specific thruster (by index). \\(s = D t_l\\) Consider the example where \\(t_l = \\begin{pmatrix}0 & 1 & 0 & 0 & 0 & 0\\end{pmatrix}^T\\) . This should cause the vehicle to move at full possible speed forward (relative to the vehicle's orientation). \\(s = D t_l = \\begin{pmatrix} -1 & -1 & 0 & 0 & 0 & +1 \\\\ +1 & -1 & 0 & 0 & 0 & -1 \\\\ -1 & +1 & 0 & 0 & 0 & -1 \\\\ +1 & +1 & 0 & 0 & 0 & +1 \\\\ 0 & 0 & -1 & -1 & -1 & 0 \\\\ 0 & 0 & -1 & -1 & +1 & 0 \\\\ 0 & 0 & -1 & +1 & -1 & 0 \\\\ 0 & 0 & -1 & +1 & +1 & 0 \\\\ \\end{pmatrix} \\begin{pmatrix}0 \\\\ 1 \\\\ 0 \\\\ 0 \\\\ 0 \\\\ 0\\end{pmatrix} = \\begin{pmatrix}-1 \\\\ -1 \\\\ +1 \\\\ +1 \\\\ 0 \\\\ 0 \\\\ 0 \\\\ 0\\end{pmatrix}\\) In the above example, it is trivial to see that this is the desired motion. However for a more complex example, a problem appears. Consider \\(t_l = \\begin{pmatrix}0 & 1 & 0 & 0 & 0 & 1\\end{pmatrix}^T\\) . This describes the vehicle both moving forward and yawing at full possible speed. \\(s = D t_l = \\begin{pmatrix} -1 & -1 & 0 & 0 & 0 & +1 \\\\ +1 & -1 & 0 & 0 & 0 & -1 \\\\ -1 & +1 & 0 & 0 & 0 & -1 \\\\ +1 & +1 & 0 & 0 & 0 & +1 \\\\ 0 & 0 & -1 & -1 & -1 & 0 \\\\ 0 & 0 & -1 & -1 & +1 & 0 \\\\ 0 & 0 & -1 & +1 & -1 & 0 \\\\ 0 & 0 & -1 & +1 & +1 & 0 \\\\ \\end{pmatrix} \\begin{pmatrix}0 \\\\ 1 \\\\ 0 \\\\ 0 \\\\ 0 \\\\ 1\\end{pmatrix} = \\begin{pmatrix}0 \\\\ -2 \\\\ 0 \\\\ +2 \\\\ 0 \\\\ 0 \\\\ 0 \\\\ 0\\end{pmatrix}\\) Notice that the resultant speed vector has motors moving in excess of 100% speed (elements with magnitude greater than 1.0). This is not possible. While a simple solution may seem to be dividing all elements of the vector by the one with the largest magnitude. This results in a scaled speed vector \\(\\hat{s}\\) \\(\\hat{s} = s \\div \\text{absmax}(s)\\) this will not work well in all cases. Consider \\(t_l = \\begin{pmatrix}0 & 1 & 1 & 1 & 1 & 1\\end{pmatrix}^T\\) . \\(s = D t_l = \\begin{pmatrix} -1 & -1 & 0 & 0 & 0 & +1 \\\\ +1 & -1 & 0 & 0 & 0 & -1 \\\\ -1 & +1 & 0 & 0 & 0 & -1 \\\\ +1 & +1 & 0 & 0 & 0 & +1 \\\\ 0 & 0 & -1 & -1 & -1 & 0 \\\\ 0 & 0 & -1 & -1 & +1 & 0 \\\\ 0 & 0 & -1 & +1 & -1 & 0 \\\\ 0 & 0 & -1 & +1 & +1 & 0 \\\\ \\end{pmatrix} \\begin{pmatrix}0 \\\\ 1 \\\\ 1 \\\\ 1 \\\\ 1 \\\\ 1\\end{pmatrix} = \\begin{pmatrix}0 \\\\ -2 \\\\ 0 \\\\ +2 \\\\ -3 \\\\ -1 \\\\ -1 \\\\ +1\\end{pmatrix}\\) and \\(\\hat{s} = s \\div \\text{absmax}(s) = s \\div 3 = \\begin{pmatrix}0 \\\\ -0.67 \\\\ 0 \\\\ +0.67 \\\\ -1 \\\\ -0.33 \\\\ -0.33 \\\\ +0.33\\end{pmatrix}\\) While this has resulted in an possible set of thruster speeds, these are not optimal. Look at the example vehicle diagram. Notice that thrusters 1-4 and 5-8 control different motions. In the previous example, thrusters 1-4 were slowed down more than necessary, because thruster 5 was too large of a value. This is not ideal as the vehicle's maximum speed becomes artificially limited. Instead, the following \\(\\hat{s}\\) is ideal. This is scaling down the thrusters within each group (1-4 and 5-8) separately. \\(\\hat{s} = \\begin{pmatrix}0 \\\\ -1 \\\\ 0 \\\\ +1 \\\\ -1 \\\\ -0.33 \\\\ -0.33 \\\\ +0.33\\end{pmatrix}\\) Groupings of thrusters on the example vehicle are easy to observe, however this is not always true. Thus, achieving optimal scaling for any system (any DoF matrix) requires a more sophisticated method to determine groupings and scale speeds. Thruster groupings are determined by \"overlap\" between thrusters. Two thrusters, \\(i\\) and \\(j\\) are said to overlap if they have a non-zero entry in the same column of the DoF matrix ( \\(D\\) ) for at least one column. This is easier to calculate using a contribution matrix , \\(C\\) , defined as \\(D \\neq 0\\) . This results in a binary form of the DoF matrix. For the above example \\(C = \\left[\\begin{pmatrix} -1 & -1 & 0 & 0 & 0 & +1 \\\\ +1 & -1 & 0 & 0 & 0 & -1 \\\\ -1 & +1 & 0 & 0 & 0 & -1 \\\\ +1 & +1 & 0 & 0 & 0 & +1 \\\\ 0 & 0 & -1 & -1 & -1 & 0 \\\\ 0 & 0 & -1 & -1 & +1 & 0 \\\\ 0 & 0 & -1 & +1 & -1 & 0 \\\\ 0 & 0 & -1 & +1 & +1 & 0 \\\\ \\end{pmatrix} \\neq 0 \\right] = \\begin{pmatrix} 1 & 1 & 0 & 0 & 0 & 1 \\\\ 1 & 1 & 0 & 0 & 0 & 1 \\\\ 1 & 1 & 0 & 0 & 0 & 1 \\\\ 1 & 1 & 0 & 0 & 0 & 1 \\\\ 0 & 0 & 1 & 1 & 1 & 0 \\\\ 0 & 0 & 1 & 1 & 1 & 0 \\\\ 0 & 0 & 1 & 1 & 1 & 0 \\\\ 0 & 0 & 1 & 1 & 1 & 0 \\\\ \\end{pmatrix}\\) Then for each thruster \\(i\\) an overlap vector \\(o_i\\) can be constructed as follows \\(o_i = C (c^i)^T\\) where \\(c^i\\) is the \\(i\\) th row of \\(C\\) . Thus, \\(o_i\\) is an 8 element vector where each element corresponds to a thruster (by index). Element \\(j\\) of \\(o_i\\) can either be \\(1\\) or a \\(0\\) . \\(1\\) indicates that thrusters \\(i\\) and \\(j\\) overlap. For example, \\(o_0 = C (c^0)^T = \\begin{pmatrix} 1 & 1 & 1 & 1 & 0 & 0 & 0 & 0 \\end{pmatrix}^T\\) This shows that thruster index 0 (T1) overlaps with indices 0, 1, 2, and 3 (T1, T2, T3, T4). By calculating and storing these overlap vectors for each thruster ( \\(\\left\\{o_i\\right\\}_{i=0}^7\\) ), this effectively forms a lookup table to determine thruster overlap. While this is not the most memory efficient option, it reduces computation time, which is important since this will run very frequently on a microcontroller. Using overlap vectors, the following algorithm can be used to scale motor speeds: Find the thruster ( i ) with the largest magnitude speed Iterate over thruster i 's overlap vector For any thruster i overlaps with ( j ), divide thruster j 's speed by the magnitude of thruster i 's speed Repeat until the largest magnitude does not exceed 1.0 while true // m is value, i is index m, i = max(abs(speed_vector)) if m <= 1.0 // Done scaling break endif // Iterate over all thrusters (0-7 inclusive) for j=0...7 if overlap_vector[i][j] == 1 // i and j overlap. Divide j's speed by m. speed_vector[j] /= m endif endfor endwhile This algorithm results in optimal speed scaling by only reducing the speed of thrusters that share DoF contributions.","title":"LOCAL Mode Motion"},{"location":"firmware/math/#global-mode-motion","text":"GLOBAL mode is very similar to LOCAL mode, however, motion is described partially relative to the world instead of the robot. Specifically, motion of the vehicle is compensated for vehicle pitch and roll (but not yaw). This results in a coordinate system defined by the axes gx , gy , and gz . Note that the world coordinate system is defined as wx , wy , wz . Notably, if the vehicle is pitched 180 degrees, the gx-gy plane becomes aligned to the back of the vehicle ensuring consistent motion. This is shown in the animation below. In GLOBAL mode, the user provides the control board with a global target motion vector , \\(t_g\\) with 6 elements. This target motion vector is a concatenation of two 3 dimensional vectors. The first, a set of translations along gx , gy , and gz . Second a set of rotations to affect vehicle pitch, roll, and yaw. These are referred to by the following names x : Speed in gx direction (translation) y : Speed in gy direction (translation) z : Speed in gz direction (translation) p : Speed at which the vehicle's pitch should increase (negative for decrease pitch). Aka \"pitch_spd\" r : Speed at which the vehicle's roll should increase (negative for decrease pitch). Aka \"roll_spd\" h : Speed at which the vehicle's yaw should increase (negative for decrease pitch). Aka \"yaw_spd\" \\(t_g = \\begin{pmatrix} x & y & z & p & r & h \\end{pmatrix}\\) It is necessary to transform each DoF's motion into motions in the vehicle's DoFs. These speeds can then be passed to LOCAL mode. WARNING: GLOBAL mode is impacted by gimbal lock issues with euler angles. This occurs when the vehicle's pitch is +/- 90 degrees. In this scenario the meaning of \"increase / decrease pitch\" is ambiguous. The vehicle will take the zero-roll route in this scenario. Thus, GLOBAL mode may produce undesirable motion if the roll is non-zero and you pitch through +/- 90. A potential solution for this could be some form of motion hysteresis to handle moving through gimbal lock orientations, however this is not implemented as of now.","title":"GLOBAL Mode Motion"},{"location":"firmware/math/#translation-dofs","text":"The translation DoFs are easily transformed using gravity vectors. By applying a quaternion based rotation matrix to the base gravity vector, \\(g_b = \\begin{pmatrix}0 & 0 & -1\\end{pmatrix}\\) , the following solution is determined for the current gravity vector, \\(g_c\\) given the vehicle's orientation quaternion, \\(q\\) . \\(\\begin{pmatrix} 2*(q.x*q.z+q.w*q.y) \\\\ 2*(q.w*q.x-q.y*q.z) \\\\ -(q.w)^2+(q.x)^2+(q.y)^2-(q.z)^2\\end{pmatrix}^T\\) The minimal rotation from \\(g_b\\) to \\(g_c\\) is then calculated. Let this rotation be called \\(q_{rot}\\) . This rotation will generally include no yaw component, unless the vehicle is upside down and facing backwards (eg pitch of 180 degrees) in which case it will contain a yaw component of 180 degrees. This is desirable as it ensures a continuous definition of what gy is even while the vehicle is flipping via pitch. This quaternion can then be applied to speeds in the gx , gy , gz basis ( x , y , and z here) to rotate them onto the vehicle basis. Thus, this \"converts\" translation speeds from GLOBAL to LOCAL mode DoFs. However, it is not ideal to transform the translation vector all at once. It is best to do it in three stages to allow proper upscaling as needed (explained below). Thus for each global mode translation vector \\(\\begin{pmatrix} 0 & y & 0 \\end{pmatrix}\\) , \\(\\begin{pmatrix} 0 & 0 & z \\end{pmatrix}\\) , and \\(\\begin{pmatrix} x & 0 & 0 \\end{pmatrix}\\) rotate it by \\(q_{rot}\\) to obtain \\(t_x\\) , \\(t_y\\) , and \\(t_z\\) respectively (note that \\(\\left\\{s, v\\right\\}\\) is a quaternion with scalar s and vector v). \\(\\left\\{0, t_x\\right\\} = q_{rot} \\left\\{0, \\begin{pmatrix} x & 0 & 0 \\end{pmatrix} \\right\\} q_{rot}^*\\) \\(\\left\\{0, t_y\\right\\} = q_{rot} \\left\\{0, \\begin{pmatrix} 0 & y & 0 \\end{pmatrix} \\right\\} q_{rot}^*\\) \\(\\left\\{0, t_z\\right\\} = q_{rot} \\left\\{0, \\begin{pmatrix} 0 & 0 & z \\end{pmatrix} \\right\\} q_{rot}^*\\) Each of \\(t_x\\) , \\(t_y\\) , and \\(t_z\\) are speeds in LOCAL mode DoFs, however they may be slower than desired. Consider a speed of 1.0 along gy . If the vehicle were rotated 45 degrees (pitch) the resultant \\(t_y\\) would be \\(t_y = \\begin{pmatrix} 0.0 & 0.7071 & 0.7071 \\end{pmatrix}\\) . This is not as fast as possible in the correct direction. Instead \\(t_y\\) should be \\(t_y = \\begin{pmatrix} 0.0 & 1.0 & 1.0 \\end{pmatrix}\\) . In other words, the largest element of \\(t_y\\) should be the speed along gy . Thus, each of \\(t_x\\) , \\(t_y\\) , \\(t_z\\) needs to be upscaled (note that it will never need to be downscaled; it only needs to be upscaled because one DoF may now be spread between multiple). let \\(m\\) be the magnitude of the element of \\(t_x\\) with the largest magnitude Normalize \\(t_x\\) so that largest element is 1.0: \\(t_x = t_x / m\\) Scale normalized \\(t_x\\) by speed \\(x\\) (gx speed): \\(t_x = t_x * x\\) Repeat this for \\(t_y\\) and \\(t_z\\) using \\(y\\) and \\(z\\) speeds respectively. Once all three \\(t\\) vectors are scaled, they can be combined to create the net LOCAL mode translation vector, \\(l\\) \\(l = t_x + t_y + t_z\\) There are two potential issues with \\(l\\) \\(l\\) is a set of proportionally related speeds to result in the desired motion. However, the vehicle may not be capable of the same speeds in each of it's DoFs. Thus, the ratios between \\(l\\) 's elements may be incorrect. \\(l\\) is a sum of three vectors (each with elements no larger than a magnitude of 1), thus it may have elements with a magnitude greater than 1. Issue 1 should be handled first as correcting it may \"fix\" issue 2. Handling issue 2 first could result in downscaling speeds more than necessary. Handling issue 1 requires the user to provide a little more information about the vehicle: relative speeds in each DoF. These can be used to calculate downscaling factors to slow down the faster directions (note: speeding up the slower directions would result in impossible speeds, but would be handled by solving issue 2; regardless it is less ideal). These downscaling factors are calculated from \"RELDOF\" information provided by the user (see messages page of user guide). Here we will referr to the scale factors as \\(m_x\\) , \\(m_y\\) , \\(m_z\\) , \\(m_{rx}\\) , \\(m_{ry}\\) , and \\(m_{rz}\\) for the x, y, z, xrot, yrot, and zrot DoFs respectively (note that these are vehicle DoFs). Thus, the simplest option would be to let \\(l = \\begin{pmatrix}l.x * m_x & l.y * m_y & l.z * m_z\\end{pmatrix}\\) . However, this may downscale more than necessary. Consider the slowest direction to have a speed of 0 in l. In this case, since the slowest direction is unused, we are downscaling too much. Thus, the following algorithm is used to select the ideal downscaling factors by \"ignoring\" the downscaling required for unused DoFs (DoFs with a speed of 0). // Zero downscale factors for unused DoFs if abs(l.x) == 0 m_x = 0 endif if abs(l.y) == 0 m_y = 0 endif if abs(l.z) == 0 m_z = 0 endif // Rebalance scale factors so largest remaining is 1.0 m_max = max(m_x, max(m_y, m_z)); m_x = m_x / m_max; m_y = m_y / m_max; m_z = m_z / m_max; \\(l\\) is then downscaled as \\(l = \\begin{pmatrix}l.x * m_x & l.y * m_y & l.z * m_z\\end{pmatrix}\\) using the scale factors calculated using the above algorithm. Finally, issue 2 must be handled if any element of \\(l\\) still has a magnitude greater than 1.0. Thus, Let \\(m\\) be the magnitude of the element of \\(l\\) with the largest magnitude If \\(m\\) is less than or equal to 1, do not change $l If \\(m\\) is greater than 1 \\(l = l / m\\) This resultant \\(l\\) is a set of speeds that can be passed to LOCAL mode as it's x , y , and z speeds.","title":"Translation DoFs"},{"location":"firmware/math/#rotation-dofs","text":"Converting the GLOBAL mode rotations (increase/decrease pitch, roll, yaw) to motions about DoFs is a little harder. It requires decomposing the quaternion into euler angles, then calculating three quaternions describing one euler rotation each. In other words, given the vehicle's current rotation \\(q\\) we need to find \\(q_{pitch}\\) , \\(q_{roll}\\) and \\(q_{yaw}\\) such that (based on the euler angle convention used by the control board) \\(q = q_{yaw} q_{pitch} q_{roll}\\) This can be done by converting \\(q\\) to a set of euler angles \\(e = \\begin{pmatrix}pitch & roll & yaw\\end{pmatrix}\\) then constructing the following and converting each to a quaternion \\(e_{pitch} = \\begin{pmatrix}pitch & 0 & 0\\end{pmatrix} \\rightarrow q_{pitch}\\) \\(e_{roll} = \\begin{pmatrix}0 & roll & 0\\end{pmatrix} \\rightarrow q_{roll}\\) \\(e_{yaw} = \\begin{pmatrix}0 & 0 & yaw\\end{pmatrix} \\rightarrow q_{yaw}\\) However, the euler angles obtained from \\(q\\) may not be correct for this use case. An equivalent angle go \\(e\\) (although improper) is \\(e_{alt} = \\begin{pmatrix} \\pi - pitch & roll - \\pi & yaw - \\pi \\end{pmatrix}\\) . We need to compensate for first roll then pitch. Thus, we need the euler angle with minimal roll component. This will be referred to here as \\(e_b\\) (which is either \\(e\\) or \\(_{alt}\\) ). Then, given \\(s\\) vectors describing motion to change the vehicle's pitch, roll, or yaw \\(s_{pitch} = \\begin{pmatrix}p & 0 & 0\\end{pmatrix}\\) \\(s_{roll} = \\begin{pmatrix}0 & r & 0\\end{pmatrix}\\) \\(s_{yaw} = \\begin{pmatrix}0 & 0 & h\\end{pmatrix}\\) We need to transform these onto the robot's axes as \\(w\\) vectors. For roll this is trivial as roll is about the vehicle's y axis. For pitch, this requires undoing roll first (rotate by \\(q_{roll}*\\) ) and for yaw this requires undoing roll then pitch. Thus \\(w_{roll} = s_{roll}\\) \\(\\left\\{0, w_{pitch}\\right\\} = q_{roll}^* \\left\\{0, s_{pitch}\\right\\} q_{roll}\\) \\(\\left\\{0, w_{yaw}\\right\\} = q_{pitch}^* q_{roll}^* \\left\\{0, s_{yaw}\\right\\} q_{roll} q_{pitch}\\) These vectors are angular speeds about the vehicle's x, y, and z axes. Thus, just as for translations Upscale each \\(w\\) vector using p , r , and h speeds (can skip for roll as this vector is never rotated) Sum the three \\(w\\) vectors into a net \\(w\\) vector Adjust \\(w\\) for relative DoF speeds (using \\(m_{rx}\\) , \\(m_{ry}\\) , \\(m_{rz}\\) ) Downscale \\(w\\) if needed so all elements are less than 1 Then \\(w\\) is the xrot, yrot, and zrot parts of the LOCAL mode target.","title":"Rotation DoFs:"},{"location":"firmware/math/#stability-assist-sassist-mode-motion","text":"Stability assist mode (SASSIST) uses closed-loop control for vehicle depth and orientation in 3D space. This is achieved using four PID controllers Depth PID: Controls translation along world z-axis xrot PID: Controls rotation about vehicle x-axis yrot PID: Controls rotation about vehicle y-axis zrot PID: Controls rotation about vehicle z-axis The inputs to SASSIST mode are as follows x : Translation along gx-axis (same as in GLOBAL mode) y : Translation along gy-axis (same as in GLOBAL mode) d_t : Target depth (meters; negative for below the surface) e_t : Target orientation as euler angles Optionally, a yaw speed ( h ) can be provided. In this case, PIDs will not adjust the vehicle's yaw (heading). Instead the h value works similar to GLOBAL mode (it is a rate of change of vehicle yaw). This effectively abstracts a 2D plane in which the vehicle operates. This is the same gx-gy plane described in the GLOBAL mode section. There are two variants of SASSIST mode Variant 1 (SASSIST1): Speed for yaw ( h ) is used instead of PID control Variant 2 (SASSIST2): PID is used for yaw (yaw speed / h is ignored) These two variants are the same in how depth control works. However, variant 1 adds some additional complexity for orientation control.","title":"Stability Assist (SASSIST) Mode Motion"},{"location":"firmware/math/#depth-control","text":"A PID controller (sassist depth PID) is used to control the vehicle's speed in the world z (or GLOBAL z) DoF. The output of this PID controller is the same z that could be an input to GLOBAL mode. This PID controller's error is the difference between the user provided target depth and the measured current depth of the vehicle.","title":"Depth Control"},{"location":"firmware/math/#translation-dofs_1","text":"The user provided x and y along with the z from the depth PID are handled the same way by SASSIST mode as they are in GLOBAL mode to obtain the final LOCAL mode translation vector \\(l\\) .","title":"Translation DoFs"},{"location":"firmware/math/#sassist2-orientation-control","text":"While translation for SASSIST is nearly identical to GLOBAL mode, rotation DoFs are very different. Orientation is controlled with a set of 3 PID controllers that work in LOCAL DoFs. Thus it is necessary to determine the rotations necessary about the vehicle's axes to achieve the desired orientation. We are given a target orientation as euler angles, \\(e_t\\) . This can be converted to a target orientation quaternion, \\(q_t\\) . Note: For SASSIST1 things after this point are the same (see section below for details on how to get \\(q_t\\) for SASSIST1). The vehicle's current orientation (as a quaternion) is also available from the IMU as \\(q_c\\) . We need to calculate a quaternion \\(q_d\\) that represents the minimal rotation from \\(q_c\\) to \\(q_t\\) . However, importantly we want \\(q_d\\) to be a rotation in the vehicle's basis. Recall that right multiplication of quaternions are applied in the vehicle's basis. Thus, to describe the target orientation as the current orientation plus a rotation in the vehicle's basis \\(q_t = q_c q_d\\) Therefore \\(q_d = q_c^* q_t\\) However, this angle may not be minimal. Recall that \\(q\\) and \\(-q\\) represent the same orientation. Thus another solution to this problem would be \\(q_d = (-q_c)^* q_t\\) The minimal rotation is the one where \\(q_c\\) and \\(q_t\\) are on the same half of the unit quaternion hypersphere (meaning their dot product is not negative). Thus If \\(q_c \\cdot q_t < 0\\) then \\(q_d = (-q_c)^* q_t\\) Otherwise \\(q_d = q_c^* q_t\\) Then convert \\(q_d\\) to axis-angle representation. The following algorithm is used to do so for numeric stability reasons (the common formulas using asin are not numerically stable) let \\(q_d = \\left\\{s, v\\right\\}\\) \\(\\theta = 2 atan2(|v|, s)\\) \\(n = v / |v|\\) if \\(|v| > 0\\) else \\(n = v = 0\\) This axis ( \\(n\\) ) will be a unit vector. Thus it represents proportions of the rotation about each of the vehicle's axes. The angle ( \\(\\theta\\) ) is the magnitude of the rotation that must be taken. Thus, the product of \\(n\\) and \\(\\theta\\) is proportional to the error in angle about each of the vehicle's axes. \\(e = \\theta n\\) This error vector, \\(e\\) , contains the errors to be provided to each orientation PID (xrot, yrot, zrot). The output of these PIDs are angular velocity percentages (-1.0 to 1.0) about each of the vehicle's axes: \\(w = \\begin{pmatrix} w_x & w_y & w_z \\end{pmatrix}\\) Note: for SASSIST 1 there is an extra step here to calculate the correct w (see section below). Finally, it is necessary to downscale the \\(w\\) vectors just as in GLOBAL mode First downscale using \\(m_{rx}\\) , \\(m_{ry}\\) and \\(m_{rz}\\) using the algorithm described in the GLOBAL mode section Then downscale the vector so that all elements are less than 1. While this is never needed for SASSIST2, it is needed for SASSIST1 and it is simpler branching logic (code implementation) to just always check if downscaling is needed. This \\(w\\) can then be passed to LOCAL mode along with the LOCAL translation vector \\(l\\) obtained earlier.","title":"SASSIST2 Orientation Control"},{"location":"firmware/math/#sassist1-orientation-control","text":"SASSIST1 uses much of the same process to control the vehicle's orientation as SASSIST2, however it is necessary to decouple yaw from pitch and roll. In other words, we want to construct a target quaternion using the user provided pitch and roll, but matching the vehicle's current yaw. The most intuitive option would be to decompose \\(q_c\\) into euler angles and obtain the yaw from those. However, this does not account for the fact that the yaw can be altered by pitch or roll. For example, (p=115, r=0, h=90) would be decomposed as (p=65, r=180, h=-90). Here the heading is 180 degrees off. This would be a significant issue. Thus instead, the target quaternion can be decomposed using the swing-twist decomposition of quaternion rotations. We twist about the world z axis (since this is the axis the vehicle initially yawed about). The vehicle's yaw can be calculated from this twist quaternion (using euler conversion formula). The target quaternion is constructed from the target pitch and roll provided by the user and the yaw provided by the twist quaternion as described above. This target quaternion is \\(q_t\\) and is used the same way described for SASSIST2. After calculating \\(w\\) as described for SASSIST2, there is one extra step before handling DoF scaling. The yaw speed ( h ) provided by the user must be transformed to the vehicle's axes and added to the \\(w\\) from the PIDs. This can be done similar to GLOBAL mode \\(\\left\\{0, w_{yaw}\\right\\} = q_{rot} \\left\\{0, \\begin{pmatrix}0 & 0 & h\\end{pmatrix}\\right\\} q_{rot}^*\\) \\(w_{yaw}\\) will then be upscaled just as in GLOBAL mode. Then \\(w = w + w_{yaw}\\) . This is then downscaled as described for SASSIST2.","title":"SASSIST1 Orientation Control"},{"location":"firmware/math/#depth-hold-dhold-mode-motion","text":"Depth hold (DHOLD) mode is GLOBAL mode but using a PID to control the vehicle's depth. The same depth PID used for SASSIST mode is used for DHOLD mode. This mode uses the vehicle's current depth and a user provided target depth to calcualte the depth PIDs error. The depth PID provides the gz-axis speed. Other speeds ( x , y , p , r , and h ) are provided by the user and mean the same thing as in GLOBAL mode. The calculated z along with user-provided speeds are passed directly to GLOBAL mode after calculating z using the depth PID.","title":"Depth Hold (DHOLD) Mode Motion"},{"location":"firmware/math/#sensor-processing","text":"TODO: Euler angle accumulation","title":"Sensor Processing"},{"location":"firmware/math/#other-derivations","text":"TODO: Euler / Quaternion conversion TODO: Gravity vector calculation TODO: Angle between vectors TODO: Min diff quat between two quats","title":"Other Derivations"},{"location":"firmware/overview/","text":"Overview TODO: Project Structure and Build System TODO: Generator projects TODO: System architecture","title":"Overview"},{"location":"firmware/overview/#overview","text":"TODO: Project Structure and Build System TODO: Generator projects TODO: System architecture","title":"Overview"},{"location":"firmware/simhijack/","text":"Simulation Support TODO","title":"Simulation Support"},{"location":"firmware/simhijack/#simulation-support","text":"TODO","title":"Simulation Support"},{"location":"hardware/sensors/","text":"Off-Board Sensors The control board has an integrated IMU (gyro + accel) and is not designed to support off-board IMUs. However, for full functionality, vehicle depth data is also required. This data is provided by an off-board depth sensor. Currently, only one such sensor is supported: MS5837-30BA pressure sensor based depth sensors. The sensor used during development and tested with the control board is BlueRobotics' Bar30 Sensor . The depth sensor is to be connected to the control board via the \"Depth I2C\" header. See the pinout images on the v1 or v2 hardware pages for more details. If using the BlueRobotics sensor, you will need to cut off the connector it comes with and install \"DuPont\" connectors.","title":"Off-Board Sensors"},{"location":"hardware/sensors/#off-board-sensors","text":"The control board has an integrated IMU (gyro + accel) and is not designed to support off-board IMUs. However, for full functionality, vehicle depth data is also required. This data is provided by an off-board depth sensor. Currently, only one such sensor is supported: MS5837-30BA pressure sensor based depth sensors. The sensor used during development and tested with the control board is BlueRobotics' Bar30 Sensor . The depth sensor is to be connected to the control board via the \"Depth I2C\" header. See the pinout images on the v1 or v2 hardware pages for more details. If using the BlueRobotics sensor, you will need to cut off the connector it comes with and install \"DuPont\" connectors.","title":"Off-Board Sensors"},{"location":"hardware/v1/","text":"AUV Control Board v1 Note that some pictures show a version with a pressure / temperature sensor. This is no longer used and should not be included when building the board. The default coordinate system as defined by the IMU is shown below. Note that this is a right hand coordinate system. The red arrows define axes. Rotation about these axes is in the right hand direction (indicated by green arrows). Notice that the green arrows are on top of the red axis arrows, thus a \"left to right\" arrow is left to right across the top of the axis. The axis configuration can be changed to match any plane-aligned mounting position of the control board on a robot. See the BNO055 datasheet for more information. Components 1x Adafruit ItsyBitsy M4 1x Adafruit BNO055 Breakout STEMMA QT version can be substituted, however be aware that the pin order is different. Protoboard (2.54mm spacing; 24 by 18 holes; 5cm by 7cm) These can be found from many vendors Solid Core Wire (22AWG) Female Pin Headers (2.54mm pitch) Two 1x14 headers One 1x6 header One 1x4 header Note: These can be cut between pins carefully Male pin headers (2.54mm pitch) Two 1x8 headers One 1x4 header Two 1x2 headers (optional; for debug interface) Note: These can easily be cut / broken between pins. Two 10K resistors (through hole, 1/4 W) Wiring Diagram Assembly Instructions Solder header strips in the positions shown below. The female headers avoid soldering breakouts / dev boards directly to protoboard which allows easily replacing components if needed (or reusing them for other purposes later). After soldering, breakouts can be populated to make identifying pins easier. The crossed out header can be omitted as it was formerly used for the pressure / temp sensor (not used anymore). Wire the protoboard according to the wiring diagram. Note that the first image shows the pressure / temperature sensor (this should be omitted). The first photo also does not show the pullup resistors or debug headers. The second picture is closer to what a fully assembled Control Board v1 should look like. Hot glue can be used to ensure the resistor leads do not short anything. This photo is an older assembly that includes the temp / pressure sensor (should be omitted) and excludes the pullup resistors and debug headers (should be included). This photo shows the pullup resistors and debug headers Back side wiring","title":"Version 1"},{"location":"hardware/v1/#auv-control-board-v1","text":"Note that some pictures show a version with a pressure / temperature sensor. This is no longer used and should not be included when building the board. The default coordinate system as defined by the IMU is shown below. Note that this is a right hand coordinate system. The red arrows define axes. Rotation about these axes is in the right hand direction (indicated by green arrows). Notice that the green arrows are on top of the red axis arrows, thus a \"left to right\" arrow is left to right across the top of the axis. The axis configuration can be changed to match any plane-aligned mounting position of the control board on a robot. See the BNO055 datasheet for more information.","title":"AUV Control Board v1"},{"location":"hardware/v1/#components","text":"1x Adafruit ItsyBitsy M4 1x Adafruit BNO055 Breakout STEMMA QT version can be substituted, however be aware that the pin order is different. Protoboard (2.54mm spacing; 24 by 18 holes; 5cm by 7cm) These can be found from many vendors Solid Core Wire (22AWG) Female Pin Headers (2.54mm pitch) Two 1x14 headers One 1x6 header One 1x4 header Note: These can be cut between pins carefully Male pin headers (2.54mm pitch) Two 1x8 headers One 1x4 header Two 1x2 headers (optional; for debug interface) Note: These can easily be cut / broken between pins. Two 10K resistors (through hole, 1/4 W)","title":"Components"},{"location":"hardware/v1/#wiring-diagram","text":"","title":"Wiring Diagram"},{"location":"hardware/v1/#assembly-instructions","text":"Solder header strips in the positions shown below. The female headers avoid soldering breakouts / dev boards directly to protoboard which allows easily replacing components if needed (or reusing them for other purposes later). After soldering, breakouts can be populated to make identifying pins easier. The crossed out header can be omitted as it was formerly used for the pressure / temp sensor (not used anymore). Wire the protoboard according to the wiring diagram. Note that the first image shows the pressure / temperature sensor (this should be omitted). The first photo also does not show the pullup resistors or debug headers. The second picture is closer to what a fully assembled Control Board v1 should look like. Hot glue can be used to ensure the resistor leads do not short anything. This photo is an older assembly that includes the temp / pressure sensor (should be omitted) and excludes the pullup resistors and debug headers (should be included). This photo shows the pullup resistors and debug headers Back side wiring","title":"Assembly Instructions"},{"location":"hardware/v2/","text":"AUV Control Board v2 The default coordinate system as defined by the IMU is shown below. Note that this is a right hand coordinate system. The red arrows define axes. Rotation about these axes is in the right hand direction (indicated by green arrows). Notice that the green arrows are on top of the red axis arrows, thus a \"left to right\" arrow is left to right across the top of the axis. The axis configuration can be changed to match any plane-aligned mounting position of the control board on a robot. See the BNO055 datasheet for more information. Components 1x WeAct Studio Black Pill (w / STM32F411 notSTM32F401 ) Note: There are many counterfeit boards sold. These should be avoided. Adafruit Store Aliexpress (Offical WeAct Studio Store) 1x Adafruit BNO055 Breakout STEMMA QT version can be substituted, however be aware that the pin order is different. Protoboard (2.54mm spacing; 24 by 18 holes; 5cm by 7cm) These can be found from many vendors Solid Core Wire (22AWG) Female Pin Headers (2.54mm pitch) Two 1x20 headers One 1x6 header One 1x4 header Note: These can be cut between pins carefully Male pin headers (2.54mm pitch) Two 1x8 headers One 1x4 header Note: These can easily be cut / broken between pins. Resistors (through hole, 1/4 W) Two 10K resistors Two 10 Ohm resistors One 100 Ohm resistor One QBL8RGB60D0-2897 RGB LED Wiring Diagram Assembly Instructions Solder header strips in the positions shown below. The female headers avoid soldering breakouts / dev boards directly to protoboard which allows easily replacing components if needed (or reusing them for other purposes later). After soldering, breakouts can be populated to make identifying pins easier. The location of the LED is also indicated here. Wire the protoboard according to the wiring diagram.","title":"Version 2"},{"location":"hardware/v2/#auv-control-board-v2","text":"The default coordinate system as defined by the IMU is shown below. Note that this is a right hand coordinate system. The red arrows define axes. Rotation about these axes is in the right hand direction (indicated by green arrows). Notice that the green arrows are on top of the red axis arrows, thus a \"left to right\" arrow is left to right across the top of the axis. The axis configuration can be changed to match any plane-aligned mounting position of the control board on a robot. See the BNO055 datasheet for more information.","title":"AUV Control Board v2"},{"location":"hardware/v2/#components","text":"1x WeAct Studio Black Pill (w / STM32F411 notSTM32F401 ) Note: There are many counterfeit boards sold. These should be avoided. Adafruit Store Aliexpress (Offical WeAct Studio Store) 1x Adafruit BNO055 Breakout STEMMA QT version can be substituted, however be aware that the pin order is different. Protoboard (2.54mm spacing; 24 by 18 holes; 5cm by 7cm) These can be found from many vendors Solid Core Wire (22AWG) Female Pin Headers (2.54mm pitch) Two 1x20 headers One 1x6 header One 1x4 header Note: These can be cut between pins carefully Male pin headers (2.54mm pitch) Two 1x8 headers One 1x4 header Note: These can easily be cut / broken between pins. Resistors (through hole, 1/4 W) Two 10K resistors Two 10 Ohm resistors One 100 Ohm resistor One QBL8RGB60D0-2897 RGB LED","title":"Components"},{"location":"hardware/v2/#wiring-diagram","text":"","title":"Wiring Diagram"},{"location":"hardware/v2/#assembly-instructions","text":"Solder header strips in the positions shown below. The female headers avoid soldering breakouts / dev boards directly to protoboard which allows easily replacing components if needed (or reusing them for other purposes later). After soldering, breakouts can be populated to make identifying pins easier. The location of the LED is also indicated here. Wire the protoboard according to the wiring diagram.","title":"Assembly Instructions"},{"location":"user_guide/calibration/","text":"Sensor Calibration BNO055 (IMU) Calibration Calibration Script It is highly recommended to use the calibration script to calibrate the BNO055. Even if you are not using the python interface to the control board, the calibration script can be used to manage the calibration state. Launch the script by using the following command (note that python3 along with the pyserial library must be installed). Run this command in the iface folder. Replace [PORT] with the serial port of the control board. python3 launch.py example/bno055_calibrate.py -p [PORT] If a calibration is currently saved to the control board, the script will show that configuration and prompt you to erase it. You must erase any stored configuration before you can recalibrate the BNO055. Refusing to erase the calibration will result in the script exiting with no further action taken (this can be used as a way to view the currently saved calibration). If the above prompt is not shown, there is no calibration currently saved on the control board. Next, the script will prompt you to run either \"guided\" or \"manual\" calibration. Guided calibration provides instructions to use the BNO055's automatic calibration routine. This is recommended. Manual calibration allows a user to manually enter values for each calibration constant. Select guided mode. Next, instructions on the calibration process will be provided. Read and follow the instructions. Then press enter to begin calibration. The script will then periodically show you the calibration status of both sensor. Perform the described motions until the calibration status of both sensors shows as \"3\". When both values show \"3\", the script will automatically retrieve the calibration generated by the BNO055. It will be shown and you will be prompted to save the calibration to the control board. If you choose to save the calibration, it will be applied each time the control board resets or powers on until the calibration is erased or changed. This is generally what you will want to do . Choosing not to save the calibration will not alter the calibration state of the device until reset. The BNO055 will retain it's calibration and re-running the calibration script (guided) will result in the calibration immediately being \"good\" (all sensors show \"3\"). However, resetting the control board (or power cycling it) will cause the calibration to be lost. Details This section provides details on how BNO055 calibration works. If attempting to implement a calibration routine yourself instead of using the calibration script, this information will be useful. Otherwise, probably not. The BNO055 IMU is calibrated using a set of \"calibration constants\". These constants can be stored to the control board so that they are applied to the sensor when the control board powers up. If not calibration constants are stored on the control board, the IMU will instead run an automatic calibration routine in the background. This routine can be used to generate calibration constants for its sensors. When a set of calibration constants is saved to the control board, they will be applied to the BNO055 each time the control board is powered on or is reset. When the control board applies a saved calibration to the BNO055, this disables the BNO055's automatic calibration routine. Thus, it is necessary to erase any calibration stored on the control board before recalibrating the BNO055. Note that the act of saving a calibration to or erasing a calibration from the control board will reconfigure the BNO055. Thus, saving a calibration to the control board will disable the BNO055's calibration routine whereas erasing a calibration from the control board will enable the BNO055's calibration routine. This means that a power cycle of the control board is not required after saving / erasing a calibration. There are two places calibration constants could be located Saved on the control board (referred to as the stored calibration constants) On the BNO055 (referred to as the live calibration constants) The stored calibration constants are written to the BNO055 when the control board starts. Thus, if any constants are saved, the live calibration constants will be the same as the stored calibration constants. However, if there are no stored calibration constants (they are erased or have never been stored), the live calibration constants will be generated by the BNO055's automatic calibration routine. The live calibration constants are only valid when the BNO055's calibration status register indicates a status code of 3 for each sensor in use (accelerometer and gyroscope). The control board provides commands to manage both the stored calibration constants as well as read the live calibration constants and calibration status directly from the BNO055. The python interface scripts provide functions to do so as well. The read_stored_bno055_calibration , erase_stored_bno055_calibration , and store_bno055_calibration functions manage the stored calibration constants. The bno055_read_calibration and bno055_read_calibration_status functions will read the live calibration constants and the calibration status form the BNO055. Erase any stored calibration. This will reset the IMU without applying any calibration. Thus, the live calibration constants will be generated by the BNO055's calibration routine. Reset the BNO055 (this is done via command to the control board). This will ensure that any calibration already generated is erased. Read the BNO055's calibration status register. Bitwise operations can be used to determine the calibration status of individual sensors. Each sensor is 2-bits of data. See the BNO055 datasheet for more information on the CALIB_STAT register. For the control board, only the accelerometer (ACC) and gyroscope (GYR) calibration status is relevant. Each of these will be a value from 0-3. A value of 3 indicates a good calibration. Perform the required operations described in the BNO055 datasheet for gyro and accelerometer calibration. Once the BNO055's calibration status reads 3 for both sensors, the calibration is complete. Read the live calibration constants from the BNO055 Store the calibration constants read in the previous step to the control board. The BNO055 will be reset, but the calibration will be applied. This same calibration that was stored to the control board will be applied to the BNO055 each time the control board is reset (or powered on). When to Re-Calibrate You should always recalibrate if you change the physical sensor in use on the control board (swap a different BNO055) or if you are using a different control board. Calibration constants will vary between sensors, thus constants from one control board cannot be used on another. Likewise, if you change the sensor on your control board the old constants will no longer be valid. Additionally, significant operating environment changes (pressure, temperature, elevation, etc) can cause enough of a change in sensor behavior to require re-calibration. Similarly, a change of the position of the sensor in the vehicle could require re-calibration. It is recommended to recalibrate if any such changes seem to result in degradation of sensor performance. If the BNO055 axis configuration used by your vehicle changes, the BNO055 should be recalibrated. MS5837 (Depth Sensor) Calibration The depth sensor is really just a pressure & temperature sensor. The depth is calculated using two \"constant\" values: the density of the water the vehicle is operating in and the atmospheric pressure at the surface of the water. For the MS5837 atmospheric pressure must be provided in Pascals and the fluid density must be provided in kg / m^3. The default values are Atmospheric Pressure: 101325 Pa Fluid Density: 997 kg / m^3 These default values are applied on control board reset / power on. MS5837 calibration is not persistent (it cannot be stored on the control board like the BNO055 can). These values can be adjusted using a command sent to the control board or by using the python interface script. The fluid density must be provided by the user (there is no good way to experimentally determine this on the vehicle). However, the pressure can be measured while the vehicle (and sensor) are in air at / above the surface. The example interface script ms5837_calibration.py demonstrates calibration of the depth sensor. Again, since the calibration is not persistent it must be applied by command / interface script function each time the device is started. Note that depth sensor calibration is not persistent due to this being of limited use. The atmospheric conditions the vehicle is operating in will change with time. Thus, any persistent configuration would not be trusted and would be frequently overwritten.","title":"Sensor Calibration"},{"location":"user_guide/calibration/#sensor-calibration","text":"","title":"Sensor Calibration"},{"location":"user_guide/calibration/#bno055-imu-calibration","text":"","title":"BNO055 (IMU) Calibration"},{"location":"user_guide/calibration/#calibration-script","text":"It is highly recommended to use the calibration script to calibrate the BNO055. Even if you are not using the python interface to the control board, the calibration script can be used to manage the calibration state. Launch the script by using the following command (note that python3 along with the pyserial library must be installed). Run this command in the iface folder. Replace [PORT] with the serial port of the control board. python3 launch.py example/bno055_calibrate.py -p [PORT] If a calibration is currently saved to the control board, the script will show that configuration and prompt you to erase it. You must erase any stored configuration before you can recalibrate the BNO055. Refusing to erase the calibration will result in the script exiting with no further action taken (this can be used as a way to view the currently saved calibration). If the above prompt is not shown, there is no calibration currently saved on the control board. Next, the script will prompt you to run either \"guided\" or \"manual\" calibration. Guided calibration provides instructions to use the BNO055's automatic calibration routine. This is recommended. Manual calibration allows a user to manually enter values for each calibration constant. Select guided mode. Next, instructions on the calibration process will be provided. Read and follow the instructions. Then press enter to begin calibration. The script will then periodically show you the calibration status of both sensor. Perform the described motions until the calibration status of both sensors shows as \"3\". When both values show \"3\", the script will automatically retrieve the calibration generated by the BNO055. It will be shown and you will be prompted to save the calibration to the control board. If you choose to save the calibration, it will be applied each time the control board resets or powers on until the calibration is erased or changed. This is generally what you will want to do . Choosing not to save the calibration will not alter the calibration state of the device until reset. The BNO055 will retain it's calibration and re-running the calibration script (guided) will result in the calibration immediately being \"good\" (all sensors show \"3\"). However, resetting the control board (or power cycling it) will cause the calibration to be lost.","title":"Calibration Script"},{"location":"user_guide/calibration/#details","text":"This section provides details on how BNO055 calibration works. If attempting to implement a calibration routine yourself instead of using the calibration script, this information will be useful. Otherwise, probably not. The BNO055 IMU is calibrated using a set of \"calibration constants\". These constants can be stored to the control board so that they are applied to the sensor when the control board powers up. If not calibration constants are stored on the control board, the IMU will instead run an automatic calibration routine in the background. This routine can be used to generate calibration constants for its sensors. When a set of calibration constants is saved to the control board, they will be applied to the BNO055 each time the control board is powered on or is reset. When the control board applies a saved calibration to the BNO055, this disables the BNO055's automatic calibration routine. Thus, it is necessary to erase any calibration stored on the control board before recalibrating the BNO055. Note that the act of saving a calibration to or erasing a calibration from the control board will reconfigure the BNO055. Thus, saving a calibration to the control board will disable the BNO055's calibration routine whereas erasing a calibration from the control board will enable the BNO055's calibration routine. This means that a power cycle of the control board is not required after saving / erasing a calibration. There are two places calibration constants could be located Saved on the control board (referred to as the stored calibration constants) On the BNO055 (referred to as the live calibration constants) The stored calibration constants are written to the BNO055 when the control board starts. Thus, if any constants are saved, the live calibration constants will be the same as the stored calibration constants. However, if there are no stored calibration constants (they are erased or have never been stored), the live calibration constants will be generated by the BNO055's automatic calibration routine. The live calibration constants are only valid when the BNO055's calibration status register indicates a status code of 3 for each sensor in use (accelerometer and gyroscope). The control board provides commands to manage both the stored calibration constants as well as read the live calibration constants and calibration status directly from the BNO055. The python interface scripts provide functions to do so as well. The read_stored_bno055_calibration , erase_stored_bno055_calibration , and store_bno055_calibration functions manage the stored calibration constants. The bno055_read_calibration and bno055_read_calibration_status functions will read the live calibration constants and the calibration status form the BNO055. Erase any stored calibration. This will reset the IMU without applying any calibration. Thus, the live calibration constants will be generated by the BNO055's calibration routine. Reset the BNO055 (this is done via command to the control board). This will ensure that any calibration already generated is erased. Read the BNO055's calibration status register. Bitwise operations can be used to determine the calibration status of individual sensors. Each sensor is 2-bits of data. See the BNO055 datasheet for more information on the CALIB_STAT register. For the control board, only the accelerometer (ACC) and gyroscope (GYR) calibration status is relevant. Each of these will be a value from 0-3. A value of 3 indicates a good calibration. Perform the required operations described in the BNO055 datasheet for gyro and accelerometer calibration. Once the BNO055's calibration status reads 3 for both sensors, the calibration is complete. Read the live calibration constants from the BNO055 Store the calibration constants read in the previous step to the control board. The BNO055 will be reset, but the calibration will be applied. This same calibration that was stored to the control board will be applied to the BNO055 each time the control board is reset (or powered on).","title":"Details"},{"location":"user_guide/calibration/#when-to-re-calibrate","text":"You should always recalibrate if you change the physical sensor in use on the control board (swap a different BNO055) or if you are using a different control board. Calibration constants will vary between sensors, thus constants from one control board cannot be used on another. Likewise, if you change the sensor on your control board the old constants will no longer be valid. Additionally, significant operating environment changes (pressure, temperature, elevation, etc) can cause enough of a change in sensor behavior to require re-calibration. Similarly, a change of the position of the sensor in the vehicle could require re-calibration. It is recommended to recalibrate if any such changes seem to result in degradation of sensor performance. If the BNO055 axis configuration used by your vehicle changes, the BNO055 should be recalibrated.","title":"When to Re-Calibrate"},{"location":"user_guide/calibration/#ms5837-depth-sensor-calibration","text":"The depth sensor is really just a pressure & temperature sensor. The depth is calculated using two \"constant\" values: the density of the water the vehicle is operating in and the atmospheric pressure at the surface of the water. For the MS5837 atmospheric pressure must be provided in Pascals and the fluid density must be provided in kg / m^3. The default values are Atmospheric Pressure: 101325 Pa Fluid Density: 997 kg / m^3 These default values are applied on control board reset / power on. MS5837 calibration is not persistent (it cannot be stored on the control board like the BNO055 can). These values can be adjusted using a command sent to the control board or by using the python interface script. The fluid density must be provided by the user (there is no good way to experimentally determine this on the vehicle). However, the pressure can be measured while the vehicle (and sensor) are in air at / above the surface. The example interface script ms5837_calibration.py demonstrates calibration of the depth sensor. Again, since the calibration is not persistent it must be applied by command / interface script function each time the device is started. Note that depth sensor calibration is not persistent due to this being of limited use. The atmospheric conditions the vehicle is operating in will change with time. Thus, any persistent configuration would not be trusted and would be frequently overwritten.","title":"MS5837 (Depth Sensor) Calibration"},{"location":"user_guide/comm_protocol/","text":"Communication Protocol Communication with the control board relies on sending messages between the control board and PC. This section focuses on how messages are sent, not what messages are sent. Hardware Communication Layer Messages are sent to the control board over the MCU's builtin USB port. The control board acts as a USB ACM CDC device. In practice, this means that it shows up as a serial (UART) port on the computer it is connected to. However, baud rate settings are irrelevant (and changing baud rates has no effect). As such, messages are sent to / received from the control board using \"UART\" with an undefined baud rate*. It is still necessary to set a baud rate when opening a UART port (as that information is provided to the device on the other side), but the rate is unused. Additionally, it is expected to operate in 8N1 data mode (8 data bits, no parity, 1 stop bit). A stream of data is sent to the control board over this port. This data is interpreted as described below. * NOTE: The baud rate 1200 is an exception. Openening then closing the port at this baud rate is used to trigger the control board to reboot to its bootloader. Do not use 1200 baud! Message Format and Construction The messages sent to / received from the control board have a specific format. Each message transfers a raw set of bytes (unsigned byte array). This set of bytes is the \"payload data\" of the message. The \"payload data\" is the data that is actually being send via the message. Messages are limited to a maximum payload size of 96 bytes. To be able to identify what data is part of a single message, it is necessary to add some additional information around the payload. The control board uses a special byte to indicate the start of a message ( START_BYTE ) and another one to identify the end of a message ( END_BYTE ). Since the payload could itself contain a start or end byte, there is also an escape byte ( ESCAPE_BYTE ) used to escape a START_BYTE , END_BYTE , or an ESCAPE_BYTE in the payload. START_BYTE becomes ESCAPE_BYTE , START_BYTE END_BYTE becomes ESCAPE_BYTE , END_BYTE ESCAPE_BYTE becomes ESCAPE_BYTE , ESCAPE_BYTE This is similar to escaping a quote in a string using a backslash. For the control board: START_BYTE = 253 (unsigned 8-bit) = -3 (signed 8-bit) END_BYTE = 254 (unsigned 8-bit) = -2 (signed 8-bit) ESCAPE_BYTE = 255 (unsigned 8-bit) = -1 (signed 8-bit) In addition to the control bytes and the payload, each message contains two other pieces of information: First, each message includes a prepended* ID number (16-bit unsigned big-endian integer). These ID numbers are required to be unique only in one direction . This means that two messages sent from the PC to the control board cannot have the same id. Likewise, two messages sent from the control board to the PC cannot have the same id. However, a message sent from PC to control board can have the same id as another message sent from control board to PC. Note that in practice, eventually (after 65535 messages sent one way) ID numbers must eventually repeat. This is acceptable as long as no two messages that are sent \"close together\" have the same id. Effectively, no two \"active\" messages in a single direction may have the same ID (what \"active\" means can vary, but in practice by the time 60,000 messages have been sent, old messages can be assumed inactive). When sending messages from PC to control board, it is required to restrict message ID between 0 and 59999 (inclusive). This is due to how the simulator is implemented. IDs 60000-65535 are reserved for simulator use. Note that IDs generated by the control board will not be restricted to this range. Second, each message has a CRC appended* to it. This is a 16-bit CRC using the CCITT-FALSE algorithm. It is appended* to the message big endian. The CRC is calculated on the concatenation of the message id bytes and the raw (unescaped) payload bytes. Just like the payload data, when prepending or appending message id or crc, it is necessary to escape bytes that are equal to control bytes (start, end, escape). * Note that append and prepend still mean contained between control (start and end) bytes. This results in message construction looking like the following (the \"payload\" is the raw message being sent).","title":"Communication Protocol"},{"location":"user_guide/comm_protocol/#communication-protocol","text":"Communication with the control board relies on sending messages between the control board and PC. This section focuses on how messages are sent, not what messages are sent.","title":"Communication Protocol"},{"location":"user_guide/comm_protocol/#hardware-communication-layer","text":"Messages are sent to the control board over the MCU's builtin USB port. The control board acts as a USB ACM CDC device. In practice, this means that it shows up as a serial (UART) port on the computer it is connected to. However, baud rate settings are irrelevant (and changing baud rates has no effect). As such, messages are sent to / received from the control board using \"UART\" with an undefined baud rate*. It is still necessary to set a baud rate when opening a UART port (as that information is provided to the device on the other side), but the rate is unused. Additionally, it is expected to operate in 8N1 data mode (8 data bits, no parity, 1 stop bit). A stream of data is sent to the control board over this port. This data is interpreted as described below. * NOTE: The baud rate 1200 is an exception. Openening then closing the port at this baud rate is used to trigger the control board to reboot to its bootloader. Do not use 1200 baud!","title":"Hardware Communication Layer"},{"location":"user_guide/comm_protocol/#message-format-and-construction","text":"The messages sent to / received from the control board have a specific format. Each message transfers a raw set of bytes (unsigned byte array). This set of bytes is the \"payload data\" of the message. The \"payload data\" is the data that is actually being send via the message. Messages are limited to a maximum payload size of 96 bytes. To be able to identify what data is part of a single message, it is necessary to add some additional information around the payload. The control board uses a special byte to indicate the start of a message ( START_BYTE ) and another one to identify the end of a message ( END_BYTE ). Since the payload could itself contain a start or end byte, there is also an escape byte ( ESCAPE_BYTE ) used to escape a START_BYTE , END_BYTE , or an ESCAPE_BYTE in the payload. START_BYTE becomes ESCAPE_BYTE , START_BYTE END_BYTE becomes ESCAPE_BYTE , END_BYTE ESCAPE_BYTE becomes ESCAPE_BYTE , ESCAPE_BYTE This is similar to escaping a quote in a string using a backslash. For the control board: START_BYTE = 253 (unsigned 8-bit) = -3 (signed 8-bit) END_BYTE = 254 (unsigned 8-bit) = -2 (signed 8-bit) ESCAPE_BYTE = 255 (unsigned 8-bit) = -1 (signed 8-bit) In addition to the control bytes and the payload, each message contains two other pieces of information: First, each message includes a prepended* ID number (16-bit unsigned big-endian integer). These ID numbers are required to be unique only in one direction . This means that two messages sent from the PC to the control board cannot have the same id. Likewise, two messages sent from the control board to the PC cannot have the same id. However, a message sent from PC to control board can have the same id as another message sent from control board to PC. Note that in practice, eventually (after 65535 messages sent one way) ID numbers must eventually repeat. This is acceptable as long as no two messages that are sent \"close together\" have the same id. Effectively, no two \"active\" messages in a single direction may have the same ID (what \"active\" means can vary, but in practice by the time 60,000 messages have been sent, old messages can be assumed inactive). When sending messages from PC to control board, it is required to restrict message ID between 0 and 59999 (inclusive). This is due to how the simulator is implemented. IDs 60000-65535 are reserved for simulator use. Note that IDs generated by the control board will not be restricted to this range. Second, each message has a CRC appended* to it. This is a 16-bit CRC using the CCITT-FALSE algorithm. It is appended* to the message big endian. The CRC is calculated on the concatenation of the message id bytes and the raw (unescaped) payload bytes. Just like the payload data, when prepending or appending message id or crc, it is necessary to escape bytes that are equal to control bytes (start, end, escape). * Note that append and prepend still mean contained between control (start and end) bytes. This results in message construction looking like the following (the \"payload\" is the raw message being sent).","title":"Message Format and Construction"},{"location":"user_guide/general_use/","text":"Using Control Board TODO General Procedure Connecting to Control Board System configuration (motor matrix, thruster inversions) Sensor configuration Validating sensor connectivity Modes of operation & setting speed Motor Watchdog Reading Sensor data Example program using python interface script LED Indicator Info","title":"Using Control board"},{"location":"user_guide/general_use/#using-control-board","text":"TODO General Procedure Connecting to Control Board System configuration (motor matrix, thruster inversions) Sensor configuration Validating sensor connectivity Modes of operation & setting speed Motor Watchdog Reading Sensor data Example program using python interface script LED Indicator Info","title":"Using Control Board"},{"location":"user_guide/messages/","text":"Messages This section describes what specific messages are sent to / received from the control board and what they do / mean. This does not address how messages are constructed or sent. For such information, see Communication Protocol . Note: The Communication Protocol page uses the term \"payload\" for the data being transferred and \"message\" for the formatted / fully constructed set of data. Here, what we refer to as \"messages\" are actually the \"payload\" data, not the constructed data. Types of Messages Commands : Messages instructing an action be taken. These messages must be acknowledged upon receipt. The acknowledgement typically contains no data. Sent from PC to control board. Queries : Messages requesting information. These messages must be acknowledged upon receipt. The acknowledgement will contain the requested information. Sent from PC to control board. Acknowledgements : A very specific type of message acknowledging receipt of another message (with an error code and optional data). Sent from control board to PC. Status Messages : Unprompted messages containing information about state / data changes. Sent from control board to PC. Message Definition Conventions In the following sections, the following standard is used to describe message contents: Each message's contents are shown as a comma separated list of bytes. Each comma separated item is a single byte, with one exception for parameters (as described below) Parameters are shown inside square brackets. Parameters represent a value that will be described in more detail below the message structure information. Parameters can be multiple bytes (even though they take only one entry between commas). ASCII characters are shown in single quotes. These are single byte unsigned ASCII characters. Numbers are not contained within any symbols. Numbers may be in hex (prefix 0x), binary (prefix 0b), or decimal (no prefix). Commands Configuration Commands Motor Matrix Set Motor matrix set command is used to set a single row of the motor matrix. It has the following format 'M', 'M', 'A', 'T', 'S', [thruster_num], [x], [y], [z], [pitch], [roll], [yaw] [thruster_num] : A single byte who'se unsigned value is the thruster number the row data should be set for (1-8). [x] , [y] , [z] , [pitch] , [roll] , [yaw] : Columns of the motor matrix row being set. Each is a 32-bit float (little endian). This message will be acknowledged. The acknowledge message will contain no result data. Motor Matrix Update Motor matrix update command is used to inform the control board the motor matrix has changed. Causes the control board to perform some calculations with the new motor matrix. This should be sent after writing all rows of the motor matrix that should change using the motor matrix set command. The motor matrix update command has the following format 'M', 'M', 'A', 'T', 'U' This message will be acknowledged. The acknowledge message will contain no result data. Thruster Inversion Set Thruster inversion set command is used to invert the positive and negative direction of thrusters. It has the following format 'T', 'I', 'N', 'V', [inv] [inv] : A single byte where each bit represents the inversion status of a thruster. The MSB (bit 7) corresponds to thruster 8 and the LSB corresponds to thruster 1 (bit + 1 = thruster). A bit value of 1 means the thruster is inverted. A bit value of 0 means the thruster is not inverted. This message will be acknowledged. The acknowledge message will contain no result data. Relative DoF Speed Set Used to set relative speeds of motion in each DoF. There are two groups: linear (x, y, z) and angular (xrot, yrot, zrot). Within each group, use 1.0 for the fastest DoF. Other DoFs in the group are percentages of the fastest speed (from -1.0 to 1.0). This message has the following format 'R', 'E', 'L', 'D', 'O', 'F', [x], [y], [z], [xrot], [yrot], [zrot] [x] , [y] , [z] , [xrot] , [yrot] , [zrot] : 32-bit little endian floats. This message will be acknowledged. The acknowledge message will contain no result data. BNO055 IMU Axis Configure Command Used to configure the BNO055 IMU's axis orientation. Note: This will also reset the accumulated euler angles to zero . 'B', 'N', 'O', '0', '5', '5', 'A', [config] [config] : A single byte. The value of this byte is between 0 and 7 (inclusive) representing on of the BNO055 axis configs (P0 to P7) as described in the BNO055 datasheet. Note: Changing the axis config changes IMU mode. Thus, there will be a brief time afterwards where the IMU may report zeros for all data. This message will be acknowledged. The acknowledge message will contain no result data. Stability Assist Mode PID Tune Command Used to tune stability assist mode PID controllers (note that the depth PID is also used for depth hold mode). It has the following format 'S', 'A', 'S', 'S', 'I', 'S', 'T', 'T', 'N', [which], [kp], [ki], [kd], [limit], [invert] [which] indicates which PID to tune ('X' = xrot, 'Y' = yrot, 'Z' = zrot, 'D' = depth hold). [kp] , [ki] , [kd] are proportional, integral, derivative, and feed-forward gains (32-bit float little endian). [limit] Is the PID controller's max output (limits max speed in the controlled DoF). Must be between 0.0 and 1.0. 32-bit float little endian. [invert] Set to one to invert PID output. Zero otherwise. Motor Control Commands Raw Speed Set Used to set motor speeds in RAW mode. This command has the following format. 'R', 'A', 'W', [speed_1], [speed_2], [speed_3], [speed_4], [speed_5], [speed_6], [speed_7], [speed_8] [speed_n] : The speed of thruster n from -1.0 to 1.0. A 32-bit float (little endian). This message will be acknowledged. The acknowledge message will contain no result data. Local Speed Set Used to set motor speeds in LOCAL mode. This command has the following format 'L', 'O', 'C', 'A', 'L', [x], [y], [z], [xrot], [yrot], [zrot] [x] , [y] , [z] , [xrot] , [yrot] , [zrot] : Speed for each DoF relative to the robot -1.0 to 1.0. A 32-bit float (little endian). This message will be acknowledged. The acknowledge message will contain no result data. Global Speed Set Used to set motor speeds in GLOBAL mode. This command has the following format 'G', 'L', 'O', 'B', 'A', 'L', [x], [y], [z], [pitch_spd], [roll_spd], [yaw_spd] [x] , [y] , [z] : Speed for each \"world-relative\" (pitch and roll compensated) DoF -1.0 to 1.0. 32-bit float (little endian). [pitch_spd] , [roll_spd] , [yaw_spd] : Rate of change of vehicle pitch, roll, and yaw -1.0 to 1.0. This message will be acknowledged. The acknowledge message will contain no result data. Note that if the IMU is not working properly, this command will be acknowledged with the \"Invalid Command\" error code. This can occur if the axis config of the IMU is changed immediately before issuing this command. Stability Assist Speed Set (Variant 1) Used to set motor speeds in STABILITY_ASSIST mode using a speed for yaw. This command has the following format 'S', 'A', 'S', 'S', 'I', 'S', 'T', 'S', 'T', '1', [x], [y], [yaw_spd], [target_pitch], [target_roll], [target_depth] Each value is a 32-bit float little endian. Pitch and roll are euler angles (in degrees). These are intrinsic euler angles (z-x'-y'' convention per the control board's coordinate system). Depth is in meters where negative numbers are below the surface. x, y, and yaw_spd are x, y, and yaw_spd just as in global mode. This message will be acknowledged with no data. Note that if the IMU or depth sensor is not working properly, this command will be acknowledged with the \"Invalid Command\" error code. This can occur if the axis config of the IMU is changed immediately before issuing this command. Stability Assist Speed Set (Variant 2) Used to set motor speeds in STABILITY_ASSIST mode using a PID to maintain a target yaw. This command has the following format 'S', 'A', 'S', 'S', 'I', 'S', 'T', 'S', 'T', '2', [x], [y], [target_pitch], [target_roll], [target_yaw], [target_depth] Each value is a 32-bit float little endian. Target Pitch, roll, and yaw are euler angles (in degrees). These are intrinsic euler angles (z-x'-y'' convention per the control board's coordinate system). Depth is in meters where negative numbers are below the surface. x and y are speeds in the x and y DoFs the same as in GLOBAL mode. This message will be acknowledged with no data. Note that if the IMU or depth sensor is not working properly, this command will be acknowledged with the \"Invalid Command\" error code. This can occur if the axis config of the IMU is changed immediately before issuing this command. Depth Hold Speed Set Used to set motor speeds in DEPTH_HOLD mode. This command has the following format 'D', 'H', 'O', 'L', 'D', [x], [y], [pitch_spd], [roll_spd], [yaw_spd], [target_depth] Each value is a 32-bit float. Everything except [target_depth] is a speed (same as GLOBAL mode speeds). Target depth is in meters (negative for below surface). Other Commands Feed Motor Watchdog Used to feed the motor watchdog so it does not kill the motors. This command has the following format 'W', 'D', 'G', 'F' This message will be acknowledged. The acknowledge message will contain no result data. BNO055 Periodic Read Used to enable / disable periodic reading of BNO055 data. This will only impact data being sent from control board to the pc. The control board itself will continue to read and use IMU data. 'B', 'N', 'O', '0', '5', '5', 'P', [enable] [enable] is an 8-bit integer with a value of either 1 or 0. If 1, reading data periodically is enabled. If 0, reading data periodically is disabled. This message will be acknowledged. The acknowledge message will contain no result data. MS5837 Periodic Read Used to enable / disable periodic reading of MS5837 data. This will only impact data being sent from control board to the pc. The control board itself will continue to read and use depth sensor data. 'M', 'S', '5', '8', '3', '7', 'P', [enable] [enable] is an 8-bit integer with a value of either 1 or 0. If 1, reading data periodically is enabled. If 0, reading data periodically is disabled. This message will be acknowledged. The acknowledge message will contain no result data. Reset Command This command is used to rest the control board itself. This will reset the microcontroller on the control board, thus the USB device will disconnect and reconnect (note that if your program still holds the port when this happens, the USB device will likely be assigned a different port number). 'R', 'E', 'S', 'E', 'T', 0x0D, 0x1E This message is not acknowledged. Simulator Hijack Command This command is used by the simulator to hijack a real control board. This allows the simulator to pass certain information to and receive certain information from the control board. This enables testing of the actual firmware and reproducing bugs under simulation. The command has the following format. 'S', 'I', 'M', 'H', 'I', 'J', 'A', 'C', 'K', [hijack] [hijack] is an 8-bit integer (unsigned) with a value of 1 or 0. If 1, the control board is put into simulator hijack mode. If 0, it is removed from simulator hijack mode. This message will be acknowledged. The acknowledge message will contain no result data. Save BNO055 Stored Calibration Command This command is used to store a set of calibration constants for the BNO055 to the control board. This will write the \"stored calibration constants\". This command will also cause the IMU to be reconfigured (this can take some time, so acknowledgements for this command may take longer than most). The command has the following format 'S', 'C', 'B', 'N', 'O', '0', '5', '5', 'S', [accel_offset_x], [accel_offset_y], [accel_offset_z], [accel_radius], [gyro_offset_x], [gyro_offset_y], [gyro_offset_z] Each value is a signed 16-bit integer. The meaning of each value is described in the BNO055 datasheet. This message will be acknowledged. The acknowledge message will contain no result data. Erase BNO055 Stored Calibration Command This command is used to erase calibration constants for the BNO055 from the control board. This will erase the \"stored calibration constants\". This command will also cause the IMU to be reconfigured (this can take some time, so acknowledgements for this command may take longer than most). The command has the following format 'S', 'C', 'B', 'N', 'O', '0', '5', '5', 'E' This message will be acknowledged. The acknowledge message will contain no result data. Write MS5837 Calibration Command This command is used to write the values of the MS5837 calibration constants. The command has the following format 'M', 'S', '5', '8', '3', '7', 'C', 'A', 'L', 'S', [atm_pressure], [fluid_density] Both values are 32-bit little endian floats. This message will be acknowledged. The acknowledge message will contain no result data. Reset BNO055 Command This command is used to reset / reconfigure the BNO055. This is typically used to clear any auto generated calibration constants. The command has the following format 'B', 'N', 'O', '0', '5', '5', 'R', 'S', 'T' This message will be acknowledged. The acknowledge message will contain no result data. Queries Sensor Status Query Gets the status of all sensors (BNO055 and MS5837). 'S', 'S', 'T', 'A', 'T' This message will be acknowledged. If acknowledged with no error, the response will contain data in the following format [status_byte] [status_byte] : Single byte containing bits for the status of all sensors. Bit 0 (LSB) is BNO055 status. Bit 1 is MS5837 status. A status bit of 1 indicates the sensor is \"ready\" (connected and can be used). A status bit of 0 indicates the sensor is \"not ready\". BNO055 Read Reads BNO055 IMU data once. 'B', 'N', 'O', '0', '5', '5', 'R' This message will be acknowledged. If acknowledged with no error, the response will contain data in the following format. Note that this is the same format as the data contained within the BNO055 data status message. [quat_w], [quat_x], [quat_y], [quat_z], [accum_pitch], [accum_roll], [accum_yaw] Each value is a 32-bit float, little endian. quat_ values are components of the orientation quaternion. accum_ values are accumulated euler angles. MS5837 Read Reads MS5837 data once. 'M', 'S', '5', '8', '3', '7', 'R' This message will be acknowledged. If acknowledged with no error, the response will contain data in the following format. Note that this is the same format as the data contained within the MS5837 data status message. [depth_m], [pressure_pa], [temp_c] depth_m is a 32-bit float, little endian (meters below surface). pressure_pa is a 32-bit float, little endian (measured pressure in Pa). temp_c is a 32-bit float, little endian (temperature of air / water). Last Reset Cause Query Get error code for last system reset cause of the control board. Generally not useful for end users, except for reporting errors. Mainly a debug / development tool. See error codes in firmware source debug.h . 'R', 'S', 'T', 'W', 'H', 'Y' This message will be acknowledged. If acknowledged with no error, the response will contain data in the following format. [error_code] error_code is a 32-bit integer (signed), little endian. Read BNO055 Stored Calibration Query This command is used to read a set of calibration constants for the BNO055 from the control board. This will read the \"stored calibration constants\". The command has the following format 'S', 'C', 'B', 'N', 'O', '0', '5', '5', 'R' This message will be acknowledged. If acknowledged with no error, the response will contain data in the following format. [valid], [accel_offset_x], [accel_offset_y], [accel_offset_z], [accel_radius], [gyro_offset_x], [gyro_offset_y], [gyro_offset_z] valid is an 8-bit integer. A value of 0 indicates that no calibration is stored on the control board (other values have no meaning). A value of 1 indicates that a calibration is stored (other values are that calibration). All other values in the acknowledge data are signed 16-bit integers. The meaning of these integers is described in the BNO055 datasheet. Read BNO055 Live Calibration Status Query This command is used to read the status of the BNO055's calibration routine. Note that this reads the value directly from the BNO055. This value is meaningless if a calibration was manually applied to the sensor. Thus, this is only useful if any \"stored calibration constants\" are first erased. The command has the following format 'B', 'N', 'O', '0', '5', '5', 'C', 'S' This message will be acknowledged. Note that if the IMU is not working properly, this command will be acknowledged with the \"Invalid Command\" error code. If acknowledged with no error, the response will contain data in the following format. [status] status is an 8-bit integer. The value of status is the value of the BNO055's CALIB_STAT register. The meaning of this number is described in the BNO055 datasheet. Read BNO055 Live Calibration Values Query This command is used to read a set of calibration constants from the BNO055. This will read the \"live calibration constants\" directly from the BNO055. Note that the calibration constants are only valid if the calibration status from the BNO055 is 3 for the accelerometer and gyroscope. The command has the following format 'B', 'N', 'O', '0', '5', '5', 'C', 'V' This message will be acknowledged. Note that if the IMU is not working properly, this command will be acknowledged with the \"Invalid Command\" error code. If acknowledged with no error, the response will contain data in the following format. [accel_offset_x], [accel_offset_y], [accel_offset_z], [accel_radius], [gyro_offset_x], [gyro_offset_y], [gyro_offset_z] All values in the acknowledge data are signed 16-bit integers. The meaning of these integers is described in the BNO055 datasheet. Read MS5837 Calibration Query This command is used to read the values of the MS5837 calibration constants. The command has the following format 'M', 'S', '5', '8', '3', '7', 'C', 'A', 'L', 'G' This message will be acknowledged. If acknowledged with no error, the response will contain data in the following format. [atm_pressure], [fluid_density] Both values are 32-bit little endian floats. Acknowledgements An acknowledgement message has the following format 'A', 'C', 'K', [ack_id], [error_code], [result] [ack_id] : The ID of the message being acknowledged. Unsigned 16-bit integer (big endian). [error_code] : A single byte error code. 0 = None: No error. 1 = Unknown Message: Control board does not recognize the message. 2 = Invalid arguments: Message is recognized, but arguments are invalid 3 = Invalid Command: Command is known, but is not valid at this time. 255 = Reserved: Control board will not use this code. Typically used as timeout. [result] : Optional data of variable size attached to the acknowledge message. Its size, format, and meaning depends on the message being acknowledged. Status Messages Motor Watchdog Status Motor watch status message is used by the control board to notify the PC about changes to motor (watchdog) state. It has the following format 'W', 'D', 'G', 'S', [status] [status] is a single byte. A value of 1 indicates the motors are enabled. A value of zero indicates the motors are currently killed by the watchdog. BNO055 Data Status Used by the control board to periodically send IMU data to the PC. Only sent when BNO055 periodic reads are enabled via the BNO055 periodic read command. The message has the following format 'B', 'N', 'O', '0', '5', '5', 'D', [quat_w], [quat_x], [quat_y], [quat_z], [accum_pitch], [accum_roll], [accum_yaw] Each value is a 32-bit float, little endian. quat_ values are components of the orientation quaternion. accum_ values are accumulated euler angles. MS5837 Data Status Used by the control board to periodically send IMU data to the PC. Only sent when BNO055 periodic reads are enabled via the BNO055 periodic read command. The message has the following format 'M', 'S', '5', '8', '3', '7', 'D', [depth_m], [pressure_pa], [temp_c] depth_m is a 32-bit float, little endian (meters below surface). pressure_pa is a 32-bit float, little endian (measured pressure in Pa). temp_c is a 32-bit float, little endian (temperature of air / water). Debug Status Messages Used only during development. These will not occur on release builds of the firmware. These are arbitrary messages sent by the control board to the PC for the firmware developer's use during development. They have the following format 'D', 'E', 'B', 'U', 'G', [msg] msg is an ascii string. Debug Data Status Messages Used only during development. These will not occur on release builds of the firmware. These are arbitrary messages sent by the control board to the PC for the firmware developer's use during development. They have the following format 'D', 'B', 'G', 'D', 'A', 'T', [msg] msg is arbitrary data.","title":"Messages"},{"location":"user_guide/messages/#messages","text":"This section describes what specific messages are sent to / received from the control board and what they do / mean. This does not address how messages are constructed or sent. For such information, see Communication Protocol . Note: The Communication Protocol page uses the term \"payload\" for the data being transferred and \"message\" for the formatted / fully constructed set of data. Here, what we refer to as \"messages\" are actually the \"payload\" data, not the constructed data.","title":"Messages"},{"location":"user_guide/messages/#types-of-messages","text":"Commands : Messages instructing an action be taken. These messages must be acknowledged upon receipt. The acknowledgement typically contains no data. Sent from PC to control board. Queries : Messages requesting information. These messages must be acknowledged upon receipt. The acknowledgement will contain the requested information. Sent from PC to control board. Acknowledgements : A very specific type of message acknowledging receipt of another message (with an error code and optional data). Sent from control board to PC. Status Messages : Unprompted messages containing information about state / data changes. Sent from control board to PC.","title":"Types of Messages"},{"location":"user_guide/messages/#message-definition-conventions","text":"In the following sections, the following standard is used to describe message contents: Each message's contents are shown as a comma separated list of bytes. Each comma separated item is a single byte, with one exception for parameters (as described below) Parameters are shown inside square brackets. Parameters represent a value that will be described in more detail below the message structure information. Parameters can be multiple bytes (even though they take only one entry between commas). ASCII characters are shown in single quotes. These are single byte unsigned ASCII characters. Numbers are not contained within any symbols. Numbers may be in hex (prefix 0x), binary (prefix 0b), or decimal (no prefix).","title":"Message Definition Conventions"},{"location":"user_guide/messages/#commands","text":"","title":"Commands"},{"location":"user_guide/messages/#configuration-commands","text":"Motor Matrix Set Motor matrix set command is used to set a single row of the motor matrix. It has the following format 'M', 'M', 'A', 'T', 'S', [thruster_num], [x], [y], [z], [pitch], [roll], [yaw] [thruster_num] : A single byte who'se unsigned value is the thruster number the row data should be set for (1-8). [x] , [y] , [z] , [pitch] , [roll] , [yaw] : Columns of the motor matrix row being set. Each is a 32-bit float (little endian). This message will be acknowledged. The acknowledge message will contain no result data. Motor Matrix Update Motor matrix update command is used to inform the control board the motor matrix has changed. Causes the control board to perform some calculations with the new motor matrix. This should be sent after writing all rows of the motor matrix that should change using the motor matrix set command. The motor matrix update command has the following format 'M', 'M', 'A', 'T', 'U' This message will be acknowledged. The acknowledge message will contain no result data. Thruster Inversion Set Thruster inversion set command is used to invert the positive and negative direction of thrusters. It has the following format 'T', 'I', 'N', 'V', [inv] [inv] : A single byte where each bit represents the inversion status of a thruster. The MSB (bit 7) corresponds to thruster 8 and the LSB corresponds to thruster 1 (bit + 1 = thruster). A bit value of 1 means the thruster is inverted. A bit value of 0 means the thruster is not inverted. This message will be acknowledged. The acknowledge message will contain no result data. Relative DoF Speed Set Used to set relative speeds of motion in each DoF. There are two groups: linear (x, y, z) and angular (xrot, yrot, zrot). Within each group, use 1.0 for the fastest DoF. Other DoFs in the group are percentages of the fastest speed (from -1.0 to 1.0). This message has the following format 'R', 'E', 'L', 'D', 'O', 'F', [x], [y], [z], [xrot], [yrot], [zrot] [x] , [y] , [z] , [xrot] , [yrot] , [zrot] : 32-bit little endian floats. This message will be acknowledged. The acknowledge message will contain no result data. BNO055 IMU Axis Configure Command Used to configure the BNO055 IMU's axis orientation. Note: This will also reset the accumulated euler angles to zero . 'B', 'N', 'O', '0', '5', '5', 'A', [config] [config] : A single byte. The value of this byte is between 0 and 7 (inclusive) representing on of the BNO055 axis configs (P0 to P7) as described in the BNO055 datasheet. Note: Changing the axis config changes IMU mode. Thus, there will be a brief time afterwards where the IMU may report zeros for all data. This message will be acknowledged. The acknowledge message will contain no result data. Stability Assist Mode PID Tune Command Used to tune stability assist mode PID controllers (note that the depth PID is also used for depth hold mode). It has the following format 'S', 'A', 'S', 'S', 'I', 'S', 'T', 'T', 'N', [which], [kp], [ki], [kd], [limit], [invert] [which] indicates which PID to tune ('X' = xrot, 'Y' = yrot, 'Z' = zrot, 'D' = depth hold). [kp] , [ki] , [kd] are proportional, integral, derivative, and feed-forward gains (32-bit float little endian). [limit] Is the PID controller's max output (limits max speed in the controlled DoF). Must be between 0.0 and 1.0. 32-bit float little endian. [invert] Set to one to invert PID output. Zero otherwise.","title":"Configuration Commands"},{"location":"user_guide/messages/#motor-control-commands","text":"Raw Speed Set Used to set motor speeds in RAW mode. This command has the following format. 'R', 'A', 'W', [speed_1], [speed_2], [speed_3], [speed_4], [speed_5], [speed_6], [speed_7], [speed_8] [speed_n] : The speed of thruster n from -1.0 to 1.0. A 32-bit float (little endian). This message will be acknowledged. The acknowledge message will contain no result data. Local Speed Set Used to set motor speeds in LOCAL mode. This command has the following format 'L', 'O', 'C', 'A', 'L', [x], [y], [z], [xrot], [yrot], [zrot] [x] , [y] , [z] , [xrot] , [yrot] , [zrot] : Speed for each DoF relative to the robot -1.0 to 1.0. A 32-bit float (little endian). This message will be acknowledged. The acknowledge message will contain no result data. Global Speed Set Used to set motor speeds in GLOBAL mode. This command has the following format 'G', 'L', 'O', 'B', 'A', 'L', [x], [y], [z], [pitch_spd], [roll_spd], [yaw_spd] [x] , [y] , [z] : Speed for each \"world-relative\" (pitch and roll compensated) DoF -1.0 to 1.0. 32-bit float (little endian). [pitch_spd] , [roll_spd] , [yaw_spd] : Rate of change of vehicle pitch, roll, and yaw -1.0 to 1.0. This message will be acknowledged. The acknowledge message will contain no result data. Note that if the IMU is not working properly, this command will be acknowledged with the \"Invalid Command\" error code. This can occur if the axis config of the IMU is changed immediately before issuing this command. Stability Assist Speed Set (Variant 1) Used to set motor speeds in STABILITY_ASSIST mode using a speed for yaw. This command has the following format 'S', 'A', 'S', 'S', 'I', 'S', 'T', 'S', 'T', '1', [x], [y], [yaw_spd], [target_pitch], [target_roll], [target_depth] Each value is a 32-bit float little endian. Pitch and roll are euler angles (in degrees). These are intrinsic euler angles (z-x'-y'' convention per the control board's coordinate system). Depth is in meters where negative numbers are below the surface. x, y, and yaw_spd are x, y, and yaw_spd just as in global mode. This message will be acknowledged with no data. Note that if the IMU or depth sensor is not working properly, this command will be acknowledged with the \"Invalid Command\" error code. This can occur if the axis config of the IMU is changed immediately before issuing this command. Stability Assist Speed Set (Variant 2) Used to set motor speeds in STABILITY_ASSIST mode using a PID to maintain a target yaw. This command has the following format 'S', 'A', 'S', 'S', 'I', 'S', 'T', 'S', 'T', '2', [x], [y], [target_pitch], [target_roll], [target_yaw], [target_depth] Each value is a 32-bit float little endian. Target Pitch, roll, and yaw are euler angles (in degrees). These are intrinsic euler angles (z-x'-y'' convention per the control board's coordinate system). Depth is in meters where negative numbers are below the surface. x and y are speeds in the x and y DoFs the same as in GLOBAL mode. This message will be acknowledged with no data. Note that if the IMU or depth sensor is not working properly, this command will be acknowledged with the \"Invalid Command\" error code. This can occur if the axis config of the IMU is changed immediately before issuing this command. Depth Hold Speed Set Used to set motor speeds in DEPTH_HOLD mode. This command has the following format 'D', 'H', 'O', 'L', 'D', [x], [y], [pitch_spd], [roll_spd], [yaw_spd], [target_depth] Each value is a 32-bit float. Everything except [target_depth] is a speed (same as GLOBAL mode speeds). Target depth is in meters (negative for below surface).","title":"Motor Control Commands"},{"location":"user_guide/messages/#other-commands","text":"Feed Motor Watchdog Used to feed the motor watchdog so it does not kill the motors. This command has the following format 'W', 'D', 'G', 'F' This message will be acknowledged. The acknowledge message will contain no result data. BNO055 Periodic Read Used to enable / disable periodic reading of BNO055 data. This will only impact data being sent from control board to the pc. The control board itself will continue to read and use IMU data. 'B', 'N', 'O', '0', '5', '5', 'P', [enable] [enable] is an 8-bit integer with a value of either 1 or 0. If 1, reading data periodically is enabled. If 0, reading data periodically is disabled. This message will be acknowledged. The acknowledge message will contain no result data. MS5837 Periodic Read Used to enable / disable periodic reading of MS5837 data. This will only impact data being sent from control board to the pc. The control board itself will continue to read and use depth sensor data. 'M', 'S', '5', '8', '3', '7', 'P', [enable] [enable] is an 8-bit integer with a value of either 1 or 0. If 1, reading data periodically is enabled. If 0, reading data periodically is disabled. This message will be acknowledged. The acknowledge message will contain no result data. Reset Command This command is used to rest the control board itself. This will reset the microcontroller on the control board, thus the USB device will disconnect and reconnect (note that if your program still holds the port when this happens, the USB device will likely be assigned a different port number). 'R', 'E', 'S', 'E', 'T', 0x0D, 0x1E This message is not acknowledged. Simulator Hijack Command This command is used by the simulator to hijack a real control board. This allows the simulator to pass certain information to and receive certain information from the control board. This enables testing of the actual firmware and reproducing bugs under simulation. The command has the following format. 'S', 'I', 'M', 'H', 'I', 'J', 'A', 'C', 'K', [hijack] [hijack] is an 8-bit integer (unsigned) with a value of 1 or 0. If 1, the control board is put into simulator hijack mode. If 0, it is removed from simulator hijack mode. This message will be acknowledged. The acknowledge message will contain no result data. Save BNO055 Stored Calibration Command This command is used to store a set of calibration constants for the BNO055 to the control board. This will write the \"stored calibration constants\". This command will also cause the IMU to be reconfigured (this can take some time, so acknowledgements for this command may take longer than most). The command has the following format 'S', 'C', 'B', 'N', 'O', '0', '5', '5', 'S', [accel_offset_x], [accel_offset_y], [accel_offset_z], [accel_radius], [gyro_offset_x], [gyro_offset_y], [gyro_offset_z] Each value is a signed 16-bit integer. The meaning of each value is described in the BNO055 datasheet. This message will be acknowledged. The acknowledge message will contain no result data. Erase BNO055 Stored Calibration Command This command is used to erase calibration constants for the BNO055 from the control board. This will erase the \"stored calibration constants\". This command will also cause the IMU to be reconfigured (this can take some time, so acknowledgements for this command may take longer than most). The command has the following format 'S', 'C', 'B', 'N', 'O', '0', '5', '5', 'E' This message will be acknowledged. The acknowledge message will contain no result data. Write MS5837 Calibration Command This command is used to write the values of the MS5837 calibration constants. The command has the following format 'M', 'S', '5', '8', '3', '7', 'C', 'A', 'L', 'S', [atm_pressure], [fluid_density] Both values are 32-bit little endian floats. This message will be acknowledged. The acknowledge message will contain no result data. Reset BNO055 Command This command is used to reset / reconfigure the BNO055. This is typically used to clear any auto generated calibration constants. The command has the following format 'B', 'N', 'O', '0', '5', '5', 'R', 'S', 'T' This message will be acknowledged. The acknowledge message will contain no result data.","title":"Other Commands"},{"location":"user_guide/messages/#queries","text":"Sensor Status Query Gets the status of all sensors (BNO055 and MS5837). 'S', 'S', 'T', 'A', 'T' This message will be acknowledged. If acknowledged with no error, the response will contain data in the following format [status_byte] [status_byte] : Single byte containing bits for the status of all sensors. Bit 0 (LSB) is BNO055 status. Bit 1 is MS5837 status. A status bit of 1 indicates the sensor is \"ready\" (connected and can be used). A status bit of 0 indicates the sensor is \"not ready\". BNO055 Read Reads BNO055 IMU data once. 'B', 'N', 'O', '0', '5', '5', 'R' This message will be acknowledged. If acknowledged with no error, the response will contain data in the following format. Note that this is the same format as the data contained within the BNO055 data status message. [quat_w], [quat_x], [quat_y], [quat_z], [accum_pitch], [accum_roll], [accum_yaw] Each value is a 32-bit float, little endian. quat_ values are components of the orientation quaternion. accum_ values are accumulated euler angles. MS5837 Read Reads MS5837 data once. 'M', 'S', '5', '8', '3', '7', 'R' This message will be acknowledged. If acknowledged with no error, the response will contain data in the following format. Note that this is the same format as the data contained within the MS5837 data status message. [depth_m], [pressure_pa], [temp_c] depth_m is a 32-bit float, little endian (meters below surface). pressure_pa is a 32-bit float, little endian (measured pressure in Pa). temp_c is a 32-bit float, little endian (temperature of air / water). Last Reset Cause Query Get error code for last system reset cause of the control board. Generally not useful for end users, except for reporting errors. Mainly a debug / development tool. See error codes in firmware source debug.h . 'R', 'S', 'T', 'W', 'H', 'Y' This message will be acknowledged. If acknowledged with no error, the response will contain data in the following format. [error_code] error_code is a 32-bit integer (signed), little endian. Read BNO055 Stored Calibration Query This command is used to read a set of calibration constants for the BNO055 from the control board. This will read the \"stored calibration constants\". The command has the following format 'S', 'C', 'B', 'N', 'O', '0', '5', '5', 'R' This message will be acknowledged. If acknowledged with no error, the response will contain data in the following format. [valid], [accel_offset_x], [accel_offset_y], [accel_offset_z], [accel_radius], [gyro_offset_x], [gyro_offset_y], [gyro_offset_z] valid is an 8-bit integer. A value of 0 indicates that no calibration is stored on the control board (other values have no meaning). A value of 1 indicates that a calibration is stored (other values are that calibration). All other values in the acknowledge data are signed 16-bit integers. The meaning of these integers is described in the BNO055 datasheet. Read BNO055 Live Calibration Status Query This command is used to read the status of the BNO055's calibration routine. Note that this reads the value directly from the BNO055. This value is meaningless if a calibration was manually applied to the sensor. Thus, this is only useful if any \"stored calibration constants\" are first erased. The command has the following format 'B', 'N', 'O', '0', '5', '5', 'C', 'S' This message will be acknowledged. Note that if the IMU is not working properly, this command will be acknowledged with the \"Invalid Command\" error code. If acknowledged with no error, the response will contain data in the following format. [status] status is an 8-bit integer. The value of status is the value of the BNO055's CALIB_STAT register. The meaning of this number is described in the BNO055 datasheet. Read BNO055 Live Calibration Values Query This command is used to read a set of calibration constants from the BNO055. This will read the \"live calibration constants\" directly from the BNO055. Note that the calibration constants are only valid if the calibration status from the BNO055 is 3 for the accelerometer and gyroscope. The command has the following format 'B', 'N', 'O', '0', '5', '5', 'C', 'V' This message will be acknowledged. Note that if the IMU is not working properly, this command will be acknowledged with the \"Invalid Command\" error code. If acknowledged with no error, the response will contain data in the following format. [accel_offset_x], [accel_offset_y], [accel_offset_z], [accel_radius], [gyro_offset_x], [gyro_offset_y], [gyro_offset_z] All values in the acknowledge data are signed 16-bit integers. The meaning of these integers is described in the BNO055 datasheet. Read MS5837 Calibration Query This command is used to read the values of the MS5837 calibration constants. The command has the following format 'M', 'S', '5', '8', '3', '7', 'C', 'A', 'L', 'G' This message will be acknowledged. If acknowledged with no error, the response will contain data in the following format. [atm_pressure], [fluid_density] Both values are 32-bit little endian floats.","title":"Queries"},{"location":"user_guide/messages/#acknowledgements","text":"An acknowledgement message has the following format 'A', 'C', 'K', [ack_id], [error_code], [result] [ack_id] : The ID of the message being acknowledged. Unsigned 16-bit integer (big endian). [error_code] : A single byte error code. 0 = None: No error. 1 = Unknown Message: Control board does not recognize the message. 2 = Invalid arguments: Message is recognized, but arguments are invalid 3 = Invalid Command: Command is known, but is not valid at this time. 255 = Reserved: Control board will not use this code. Typically used as timeout. [result] : Optional data of variable size attached to the acknowledge message. Its size, format, and meaning depends on the message being acknowledged.","title":"Acknowledgements"},{"location":"user_guide/messages/#status-messages","text":"Motor Watchdog Status Motor watch status message is used by the control board to notify the PC about changes to motor (watchdog) state. It has the following format 'W', 'D', 'G', 'S', [status] [status] is a single byte. A value of 1 indicates the motors are enabled. A value of zero indicates the motors are currently killed by the watchdog. BNO055 Data Status Used by the control board to periodically send IMU data to the PC. Only sent when BNO055 periodic reads are enabled via the BNO055 periodic read command. The message has the following format 'B', 'N', 'O', '0', '5', '5', 'D', [quat_w], [quat_x], [quat_y], [quat_z], [accum_pitch], [accum_roll], [accum_yaw] Each value is a 32-bit float, little endian. quat_ values are components of the orientation quaternion. accum_ values are accumulated euler angles. MS5837 Data Status Used by the control board to periodically send IMU data to the PC. Only sent when BNO055 periodic reads are enabled via the BNO055 periodic read command. The message has the following format 'M', 'S', '5', '8', '3', '7', 'D', [depth_m], [pressure_pa], [temp_c] depth_m is a 32-bit float, little endian (meters below surface). pressure_pa is a 32-bit float, little endian (measured pressure in Pa). temp_c is a 32-bit float, little endian (temperature of air / water). Debug Status Messages Used only during development. These will not occur on release builds of the firmware. These are arbitrary messages sent by the control board to the PC for the firmware developer's use during development. They have the following format 'D', 'E', 'B', 'U', 'G', [msg] msg is an ascii string. Debug Data Status Messages Used only during development. These will not occur on release builds of the firmware. These are arbitrary messages sent by the control board to the PC for the firmware developer's use during development. They have the following format 'D', 'B', 'G', 'D', 'A', 'T', [msg] msg is arbitrary data.","title":"Status Messages"},{"location":"user_guide/preparing_board/","text":"Preparing a Control Board TODO: Flashing firmware Wiring Testing USB","title":"Preparing a Control Board"},{"location":"user_guide/preparing_board/#preparing-a-control-board","text":"TODO: Flashing firmware Wiring Testing USB","title":"Preparing a Control Board"},{"location":"user_guide/simulator/","text":"Using the Simulator TODO","title":"Using the Simulator"},{"location":"user_guide/simulator/#using-the-simulator","text":"TODO","title":"Using the Simulator"}]}