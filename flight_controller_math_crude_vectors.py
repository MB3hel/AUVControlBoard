#!/usr/bin/env python3

import numpy as np
import math


# Commonly used constants
s2o2 = math.sqrt(2) / 2.0


# Target translational vector
# Magnitude must be between 0 and 1 (represents percent max speed)
# THIS IS IN WORLD SPACE (NOT RELATIVE TO ROBOT)
vtarget = [1, 0, 0]

# Motor vectors
# Unit vectors that represent motor orientations
# In direction of force generated by the motor on robot
# NOT the direction the thurster pushes water
u1 = [s2o2, s2o2, 0]
u2 = [-s2o2, s2o2, 0]
u3 = [s2o2, -s2o2, 0]
u4 = [-s2o2, -s2o2, 0]
u5 = [0, 0, 1]
u6 = [0, 0, 1]
u7 = [0, 0, 1]
u8 = [0, 0, 1]
u_all = [u1, u2, u3, u4, u5, u6, u7, u8]


# TODO: This is probably a bad method. Should really not compensate for world position using a drifting sensor such as gyro...
# Compass could work though is not able to be trusted near motors and reqires calibration
# Best option seems to be to only compensate in the vertical direction using accelerometer to determine a downward vector

# Current gyro readings (Euler angles; rotations about given axes)
x = 0 * (math.pi / 180.0)
y = 0 * (math.pi / 180.0)
z = 0 * (math.pi / 180.0)


if __name__ == "__main__":
    v_target = [0, 0, 1]
    
    for i in range(len(u_all)):
        
        # Rotate motor vector to match robot's orientation
        rot_x = np.array([[1, 0, 0], [0, math.cos(x), -math.sin(x)], [0, math.sin(x), math.cos(x)]], dtype=np.double)
        rot_y = np.array([[math.cos(y), 0, math.sin(y)], [0, 1, 0], [-math.sin(y), 0, math.cos(y)]], dtype=np.double)
        rot_z = np.array([[math.cos(z), -math.sin(z), 0], [math.sin(z), math.cos(z), 0], [0, 0, 1]], dtype=np.double)
        u_rotated = np.dot(np.dot(np.dot(u_all[i], rot_z), rot_y), rot_x) 
        print("v{0} = {1}".format(i + 1, np.dot(u_rotated, v_target)))

