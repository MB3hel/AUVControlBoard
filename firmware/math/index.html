<!DOCTYPE html>
<html class="writer-html5" lang="en" >
<head>
    <meta charset="utf-8" />
    <meta http-equiv="X-UA-Compatible" content="IE=edge" />
    <meta name="viewport" content="width=device-width, initial-scale=1.0" />
      <link rel="shortcut icon" href="../../img/favicon.ico" />
    <title>Math - AUV Control Board</title>
    <link rel="stylesheet" href="../../css/theme.css" />
    <link rel="stylesheet" href="../../css/theme_extra.css" />
        <link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/highlight.js/10.5.0/styles/github.min.css" />
    
      <script>
        // Current page data
        var mkdocs_page_name = "Math";
        var mkdocs_page_input_path = "firmware\\math.md";
        var mkdocs_page_url = null;
      </script>
    
    <script src="../../js/jquery-3.6.0.min.js" defer></script>
    <!--[if lt IE 9]>
      <script src="../../js/html5shiv.min.js"></script>
    <![endif]-->
      <script src="https://cdnjs.cloudflare.com/ajax/libs/highlight.js/10.5.0/highlight.min.js"></script>
      <script>hljs.initHighlightingOnLoad();</script> 
</head>

<body class="wy-body-for-nav" role="document">

  <div class="wy-grid-for-nav">
    <nav data-toggle="wy-nav-shift" class="wy-nav-side stickynav">
    <div class="wy-side-scroll">
      <div class="wy-side-nav-search">
          <a href="../.." class="icon icon-home"> AUV Control Board
        </a><div role="search">
  <form id ="rtd-search-form" class="wy-form" action="../../search.html" method="get">
      <input type="text" name="q" placeholder="Search docs" title="Type search term here" />
  </form>
</div>
      </div>

      <div class="wy-menu wy-menu-vertical" data-spy="affix" role="navigation" aria-label="Navigation menu">
              <ul>
                <li class="toctree-l1"><a class="reference internal" href="../..">Home</a>
                </li>
              </ul>
              <p class="caption"><span class="caption-text">Hardware</span></p>
              <ul>
                  <li class="toctree-l1"><a class="reference internal" href="../../hardware/v1/">Version 1</a>
                  </li>
                  <li class="toctree-l1"><a class="reference internal" href="../../hardware/v2/">Version 2</a>
                  </li>
                  <li class="toctree-l1"><a class="reference internal" href="../../hardware/sensors/">Off-Board Sensors</a>
                  </li>
              </ul>
              <p class="caption"><span class="caption-text">Firmware</span></p>
              <ul class="current">
                  <li class="toctree-l1"><a class="reference internal" href="../overview/">Overview</a>
                  </li>
                  <li class="toctree-l1"><a class="reference internal" href="../build/">Build and Flash</a>
                  </li>
                  <li class="toctree-l1 current"><a class="reference internal current" href="./">Math</a>
    <ul class="current">
    <li class="toctree-l2"><a class="reference internal" href="#coordinate-system-definition">Coordinate System Definition</a>
    </li>
    <li class="toctree-l2"><a class="reference internal" href="#robot-local-coordinate-system">Robot Local Coordinate System</a>
    </li>
    <li class="toctree-l2"><a class="reference internal" href="#robot-thruster-arrangement">Robot Thruster Arrangement</a>
    </li>
    <li class="toctree-l2"><a class="reference internal" href="#6dof-motor-control-math">6DOF Motor Control Math</a>
        <ul>
    <li class="toctree-l3"><a class="reference internal" href="#motor-matrix">Motor Matrix</a>
    </li>
    <li class="toctree-l3"><a class="reference internal" href="#dof-matrix">DoF Matrix</a>
    </li>
    <li class="toctree-l3"><a class="reference internal" href="#local-targets">Local Targets</a>
    </li>
    <li class="toctree-l3"><a class="reference internal" href="#scaling-motor-outputs">Scaling Motor Outputs</a>
    </li>
    <li class="toctree-l3"><a class="reference internal" href="#global-targets">Global Targets</a>
    </li>
        </ul>
    </li>
    <li class="toctree-l2"><a class="reference internal" href="#stability-assist-mode-math">Stability Assist Mode Math</a>
        <ul>
    <li class="toctree-l3"><a class="reference internal" href="#orientation-closed-loop-control">Orientation Closed-Loop Control</a>
    </li>
    <li class="toctree-l3"><a class="reference internal" href="#depth-closed-loop-control">Depth Closed-Loop Control</a>
    </li>
        </ul>
    </li>
    <li class="toctree-l2"><a class="reference internal" href="#imu-angle-accumulation">IMU Angle Accumulation</a>
    </li>
    </ul>
                  </li>
                  <li class="toctree-l1"><a class="reference internal" href="../developing/">Firmware Development</a>
                  </li>
              </ul>
              <p class="caption"><span class="caption-text">User Guide</span></p>
              <ul>
                  <li class="toctree-l1"><a class="reference internal" href="../../user_guide/preparing_board/">Preparing a Control Board</a>
                  </li>
                  <li class="toctree-l1"><a class="reference internal" href="../../user_guide/general_use/">Using Control board</a>
                  </li>
                  <li class="toctree-l1"><a class="reference internal" href="../../user_guide/comm_protocol/">Communication Protocol</a>
                  </li>
                  <li class="toctree-l1"><a class="reference internal" href="../../user_guide/messages/">Messages</a>
                  </li>
              </ul>
      </div>
    </div>
    </nav>

    <section data-toggle="wy-nav-shift" class="wy-nav-content-wrap">
      <nav class="wy-nav-top" role="navigation" aria-label="Mobile navigation menu">
          <i data-toggle="wy-nav-top" class="fa fa-bars"></i>
          <a href="../..">AUV Control Board</a>
        
      </nav>
      <div class="wy-nav-content">
        <div class="rst-content"><div role="navigation" aria-label="breadcrumbs navigation">
  <ul class="wy-breadcrumbs">
    <li><a href="../.." class="icon icon-home" alt="Docs"></a> &raquo;</li>
          <li>Firmware &raquo;</li><li>Math</li>
    <li class="wy-breadcrumbs-aside">
        <a href="https://github.com/MB3hel/AUVControlBoard/blob/main/docs/docs/firmware/math.md"
          class="icon icon-github"> Edit on GitHub</a>
    </li>
  </ul>
  <hr/>
</div>

          <div role="main" class="document" itemscope="itemscope" itemtype="http://schema.org/Article">
            <div class="section" itemprop="articleBody">
              
                <h1 id="control-math">Control Math</h1>
<h2 id="coordinate-system-definition">Coordinate System Definition</h2>
<ul>
<li>The coordinate system is defined by the images below</li>
<li>Pitch is defined as rotation about the x-axis</li>
<li>Roll is defined as rotation about the y-axis</li>
<li>Yaw is defined as rotation about the z-axis</li>
<li>Positive pitch, roll, and yaw are defined by the right hand rule<ul>
<li>Point your right thumb in the positive direction of the axis being rotated about. The fingers of the hand curve in the direction of positive rotation. <a href="https://en.wikipedia.org/wiki/Right-hand_rule">Reference</a></li>
<li>Positive pitch is defined as counter-clockwise rotation in the yz plane when view from the +x side</li>
<li>Positive roll is defined as counter-clockwise rotation in the xz plan when view from the +y side</li>
<li>Positive yaw is defined as counter-clockwise rotation in the xy plane when viewed from the +z side</li>
</ul>
</li>
</ul>
<p><center>
<img alt="" src="../math_res/coord_system_1.png" style="height:250px;" />
<img alt="" src="../math_res/coord_system_2.png" style="height:250px;" />
<img alt="" src="../math_res/coord_system_rotations.png" style="height:250px;" />
</center></p>
<h2 id="robot-local-coordinate-system">Robot Local Coordinate System</h2>
<ul>
<li>The robot's local coordinate system is defined as shown below where +y is forward, +x is right, and +z is up.</li>
<li>Pitch and roll definitions remain the same as previously defined<ul>
<li>+pitch raises front of the robot</li>
<li>+roll raises left of the robot</li>
<li>+yaw moves the front to the left</li>
</ul>
</li>
</ul>
<p><center>
<img alt="" src="../math_res/robot_local_coord.png" style="height:400px;" />
</center></p>
<h2 id="robot-thruster-arrangement">Robot Thruster Arrangement</h2>
<ul>
<li>The arrows on the diagrams below are the direction the thrusters push water when given a positive speed (meaning the force excreted on the robot is in the opposite direction).</li>
<li>Note: Thruster numbers can be easily switched later if thrusters are connected to different pwm outputs.</li>
<li>Note: Thruster directions can be inverted by the control board firmware if needed (without changing the math).</li>
</ul>
<p><center>
<img alt="" src="../math_res/thruster_config.png" style="height:400px;" />
</center></p>
<h2 id="6dof-motor-control-math">6DOF Motor Control Math</h2>
<p>The following section covers math to calculate individual motor speeds to achieve the desired motion with a 6 degree of freedom system (6DoF = 3 translation and 3 rotation). The math remains valid for motor configurations where motion in some DoFs is not possible.</p>
<p><em><a href="../math_res/numpy_motor_math.py">motor_control_math.py</a> is an implementation of the motor control math using numpy. It is used for prototyping / testing.</em></p>
<h3 id="motor-matrix">Motor Matrix</h3>
<p>The motor matrix is generated based on physical frame and thruster configuration. The motor matrix associates motor numbers with their contributions to motion in different degrees of freedom.</p>
<p>The motor matrix can be thought of as a "table" where each column represents one degree of freedom and each row represents a motor. Each column is a set of motor speeds that cause motion <strong>only</strong> in the column's degree of freedom (and in the positive direction and at maximum possible speed). There are always 7 columns in the matrix. The number of rows is equal to the number of motors. Note that the motor numbers can be in any order (ie row order does not matter) whereas columns must be ordered as shown in the image below.</p>
<p><center>
<img alt="" src="../math_res/motor_matrix.png" style="height:250px;" />
</center></p>
<p>To construct the motor matrix for a given thruster configuration, work one column at a time (after assigning motor numbers to rows). For each column determine the speeds for each motor to cause motion <strong>only</strong> in the positive direction of the column's DoF at the maximum possible speed. The motor speeds in each column must not cause motion in any other DoF (in an ideal scenario; in the real world things are never perfect). Note that all motor speeds are specified as a number between negative one and positive one.</p>
<p>The motor matrix for the thruster configuration shown above is as follows</p>
<p><center>
<img alt="" src="../math_res/motor_matrix_sw8.png" style="height:250px;" />
</center></p>
<h3 id="dof-matrix">DoF Matrix</h3>
<p>The motor matrix is not directly used in calculations. Only a subset of it is. The DoF Matrix is a submatrix of the motor matrix excluding the first column (motor numbers). This matrix is used for all calculations. The motor number column is extracted and stored as a column vector and used to associate speed calculation results with the correct motor numbers after other calculations.</p>
<p><center>
<img alt="" src="../math_res/dof_matrix_split.png" style="height:250px;" />
</center></p>
<h3 id="local-targets">Local Targets</h3>
<p>Next it is necessary to define a motion target, or a goal for the robot's motion in each DoF. For now, assume this target is relative to the robot, not the world (meaning the robot's orientation in space is irrelevant).</p>
<p>A motion target is a column vector where each row corresponds to a DoF (order matches order of DoFs in motor matrix columns). The value in each cell is a number from negative one to positive one and represents the target speed in each degree of freedom. The target can have motion in as many DoFs as desired. </p>
<p><center>
<img alt="" src="../math_res/target_vector.png" style="height:250px;" />
</center></p>
<p>This target motion vector can then be used to calculate individual motor speeds by multiplying it by the DoF matrix. The result of this multiplication is a column vector with as many entries as there are motors. Each entry is a motor speed. The motor speeds are in the same order as the motor number column vector (first column of motor matrix). This vector is the speed vector.</p>
<p><center>
<img alt="" src="../math_res/motor_speed_calc.png" style="height:250px;" />
</center></p>
<p>Motion in multiple DoFs can be used to create any net motion the robot is capable of. For example, positive y translation and positive yaw of equal magnitudes (speeds) will result in the robot moving in a circle in the xy plane about the left edge of the robot (positive directions). The calculation for this scenario is shown below (at 100% speed).</p>
<p><center>
<img alt="" src="../math_res/two_dof_calc.png" style="height:250px;" />
</center></p>
<p>Notice that the resultant motor speed vector has motor speeds that exceed 100% speed. This is because it is not possible to move at 100% speed in both of the specified DoFs at the same time. As such, motor speeds will need to be scaled down. This is discussed in the next section.</p>
<h3 id="scaling-motor-outputs">Scaling Motor Outputs</h3>
<p>The above example illustrates the need to scale down motor speeds. However, doing so is less trivial than it may initially appear.</p>
<p>The most intuitive option would be to divide all motor speeds by the largest magnitude (<code>m = max(abs(speed_vector))</code>) if <code>m</code> is larger than 1.0 (no need to divide if no value is larger than 1 because the motion is already possible). This solution works in the above example resulting in the following scaled speed vector</p>
<p><center>
<img alt="" src="../math_res/scaled_speed_vec_all.png" style="height:250px;" />
</center></p>
<p>While this is the correct result for the above example, consider the following more complex example (where motion in more DoFs is added).</p>
<p><center>
<img alt="" src="../math_res/many_dof_speed_calc.png" style="height:250px;" />
</center></p>
<p>If the previously described algorithm is applied <code>m = 3</code> which results in the following scaled speed vector</p>
<p><center>
<img alt="" src="../math_res/scaled_all_many_dof.png" style="height:225px;" />
</center></p>
<p>However, this speed vector is scaled non-optimally. Notice that the maximum speed occurred at motor 5. However, motors 1, 2, 3, and 4 do not affect any of the same directions as motor 5. As such, it is not necessary to divide motor 1, 2, 3, 4 speeds by 3. Instead they should only be divided by 2 otherwise some DoF motions are slowed more than required (artificially reducing max speed).</p>
<p>In reality, it is only necessary to divide the speeds of some motors depending on where the max speed is located. If the max speed occurs at motor <em>i</em>, it is only necessary to divide the speed of any motors that "overlap" with motor <em>i</em>. Overlap is defined as sharing a contribution in any DoF. In terms of the DoF matrix, two motors <em>i</em> and <em>j</em> overlap if the row for motor <em>i</em> and the row for motor <em>j</em> have a non-zero entry in the same column for at least one column. Mathematically, this is easier to calculate if a contribution matrix is defined as "the dof matrix is not equal to zero". The contribution matrix is a "binary version" of the dof matrix, where any non-zero entry in the dof matrix becomes a 1 in the contribution matrix (and any zero remains a zero). </p>
<p><center>
<img alt="" src="../math_res/contribution_matrix_calc.png" style="height:300px;" />
</center></p>
<p>Then, in terms of the contribution matrix, two motors <em>i</em> and <em>j</em> overlap if the row for motor <em>i</em> and motor <em>j</em> have a one entry in the same column for at least one column. Mathematically, the number of shared non-zero entries is the dot product of the two rows.</p>
<p>To simplify later calculations an overlap vector will be generated for each motor in the dof matrix. The overlap vector is a vector of 1's and 0's indicating whether overlap occurs with the corresponding index motor in the speed vector. For motor i the overlap vector (<code>overlap_vec[i]</code>) is defined as "the product of the contribution matrix and the transpose of row <code>i</code> of the contribution matrix is not equal to zero". For example <code>overlap_vec[0]</code> is defined as follows</p>
<p><center>
<img alt="" src="../math_res/overlap_vec_calc.png" style="height:425px;" />
</center></p>
<p>One overlap vector must be calculated for <em>each</em> motor. These are calculated ahead of time to reduce the number of operations that must be performed to calculate motor speeds (important when this is implemented on a microcontroller).</p>
<p>Finally, the following algorithm (described in pseudocode) is used to properly scale each motor. The scaling is done when no speed in the vector has a magnitude greater than 1.</p>
<pre><code>while true
    // index is index in speed_vector at which m occurs
    m, index = max(abs(speed_vector))
    if m &lt;= 1
        // No speeds exceed max magnitude, so done scaling
        break
    endif

    // Scale speed_vector as needed
    for i = 0; i &lt; length(overlap_vector[index]); ++i
        if overlap_vector[index][i] == 1
            speed_vector[i] /= m;
        endif
    endfor
endwhile
</code></pre>
<p>Using this algorithm the earlier example results in the following scaled speed vector (which is optimal for the requested motions).</p>
<p><center>
<img alt="" src="../math_res/proper_scaling.png" style="height:250px;" /></p>
<p><em>Motor 1, 2, 3, 4 speeds divided by 2 and motor 5, 6, 7, 8 speeds divided by 3. This results in the fastest motor within each group being at 100% speed, thus this is optimal scaling.</em>
</center></p>
<h3 id="global-targets">Global Targets</h3>
<p>Instead of providing desired motion relative to the robot's orientation, it is often easier to specify motion relative to the world (at least partially). This requires knowing information about the robot's orientation in 3D space. However, for this application the robot's heading will be ignored (meaning x and y are relative to the robot's orientation, but z is world-relative). </p>
<p>This effectively turns the target vector previously provided into a pseudo world-relative motion target (DoFs are world coordinate system DoFs not robot coordinate system DoFs). <em>However, y still means forward relative to robot heading </em><em>not</em><em> relative to the world coordinate system (same idea for x too).</em></p>
<p>This method is used instead of a true global target for two reasons
- The method described above does not require knowing the robot's heading in 3D space. As such, the required information can be entirely obtained using an accelerometer. No use of gyroscope or magnetometer is required. This is beneficial as gyroscopes drift and magnetometers become unreliable in close proximity to motors.
- Missing code's knowledge of the robot's position relative to objects of interest often has no knowledge of a world coordinate system. As such, keeping x and y translations robot-relative simplifies mission code and reduces errors for closed loop control in mission code.</p>
<p>The target vector can be split into two parts: a translation vector and a rotation vector.</p>
<p><center>
<img alt="" src="../math_res/target_vector_split.png" style="height:250px;" />
</center></p>
<p>Both vectors are in an [x, y, z] order.
- Translations are along the given axes
- Rotations are about the given axes</p>
<p>The idea is to determine a rotation matrix to translate the world gravity vector to the robot's measured gravity vector. This is the same rotation that should then be applied to each of the vectors described above (translation and rotation).</p>
<p>It is assumed that when the robot's coordinate frame matches the world's coordinate frame, the measured gravity vector will be [0, 0, -g] (meaning in the negative z direction). This must be configured to be the case (IMU supports axis remapping internally to allow this regardless of how the IMU is mounted). Then, given a world gravity vector (<code>g_w</code>) and a measured gravity vector <code>g_r</code> a rotation matrix (<code>R</code>) to rotate vectors from the world coordinate system into the robot's coordinate system can be calculated as shown below</p>
<p><center>
<img alt="" src="../math_res/rotation_matrix_calc.png" style="height:100px;" />
</center></p>
<p>Where <code>[v_c]_x</code> is the skew symmetric cross product matrix of <code>v_c</code> defined as follows</p>
<p><center>
<img alt="" src="../math_res/skew_symmetric.png" style="height:100px;" />
</center></p>
<p>Then each of the translation and rotation targets can be rotated by multiplication by the rotation matrix (<code>R</code>). The translation and rotation vectors are then concatenated to create the full local target vector.</p>
<p><center>
<img alt="" src="../math_res/apply_rotation.png" style="height:100px;" />
</center></p>
<h2 id="stability-assist-mode-math">Stability Assist Mode Math</h2>
<p>Stability assist mode is used to abstract a "2D" working plane to control the vehicle in. This is done by using closed-loop control to maintain pitch, roll, and depth in 3D space (leaving the x, y, and yaw DoFs). Optionally, closed-loop control can also be used for yaw leaving just the x and y DoFs.</p>
<p>This is built on top of global mode. Thus, stability assist mode calculates the current desired speed in each degree of freedom managed by closed loop controllers (pitch, roll, depth, and sometimes yaw). The speeds in other DoFs are specified by the PC just as they would be in global mode.</p>
<h3 id="orientation-closed-loop-control">Orientation Closed-Loop Control</h3>
<p><em><a href="../math_res/orientation_math.py">orientation_math.py</a> is an implementation of the orientation closed-loop math using numpy. It is used for prototyping / testing.</em></p>
<p>Separate PID controllers are used to track the target pitch, roll, and yaw. This allows the output of each PID to be used as a "speed" for one DoF for global mode.</p>
<p>The target (desired) orientation is specified using Euler angles (3-2-1, ZYX), however it will be converted to a Quaternion before use. The use of euler angles allows easily "ignoring" yaw in the event that only pitch and roll are to be managed by closed-loop controllers.</p>
<p>The current angle is read from the IMU (as a quaternion due to bugs in some versions of the BNO055 firmware with its euler angles). It is converted to euler angles (ZYX) additionally. The target orientation is specified using euler angles (ZYX) from the PC. If yaw is not managed by closed-loop control, the current yaw from the IMU reading is copied into the target euler angles (replacing the target yaw). This ensures that the yaw difference between the target and current angle will be zero.</p>
<p>Next, the target is converted to a quaternion. The angle between the current and target quaternion is then calculated. This is done using the following</p>
<p>
<script type="math/tex">q_\textrm{diff} = (q_\textrm{target}) (q_\textrm{current})^{-1}</script>
</p>
<p>However, this is not guaranteed to be the minimal angle between the current and target quaternions. If the dot product of the two quaternions is negative, the following equation is instead used to get the minimum angle.</p>
<p>
<script type="math/tex">q_\textrm{diff} = (q_\textrm{target}) (-q_\textrm{current})^{-1}</script>
</p>
<p>This minimum angle quaternion (<script type="math/tex">q_\textrm{diff}</script>) is then converted to euler angles. The pitch, roll, and yaw of the euler angles are used as the current error for the pitch, roll, and yaw closed-loop PID controllers.</p>
<p><img alt="" src="../math_res/construct_orientation_errors.png" /></p>
<h3 id="depth-closed-loop-control">Depth Closed-Loop Control</h3>
<p>Depth closed-loop control is implemented using a PID. This PID's output is used as the target speed in the z DoF. The error is the difference between the current depth sensor reading and the specified target depth (in meters; negative for below the surface).</p>
<h2 id="imu-angle-accumulation">IMU Angle Accumulation</h2>
<p><em><a href="../math_res/accumulate_angles.py">accumulate_angles.py</a> is an implementation of the math used to determine the difference between two quaternions (used to determine change in euler angles for accumulation).</em></p>
<p>The euler and quaternion values provided by the IMU are not directly useful for tracking multiple rotations of the vehicle. Unlike simply integrating gyroscope data, euler angles (pitch, roll, yaw) and quaternions do not track the number of times the vehicle has rotated about a particular axis.</p>
<p>While integrating raw gyro data would provide this, such a solution would not be rotations about the robot's axes, not the world's axes (gyro z of 500 does not necessarily mean the robot has yawed 500 degrees; the robot could have been oriented at a pitch of 90).</p>
<p>To address this, it is necessary to track changes between subsequent quaternions from the IMU. Quaternions are used for three reasons</p>
<ol>
<li>Firmware bugs in some BNO055 firmware versions lead to unstable euler angles</li>
<li>It is mathematically easier to determine the "shortest rotation" between two quaternions</li>
<li>Quaternions still allow accumulation to work in "gimbal lock" situations</li>
</ol>
<p>The idea is to compare each quaternion read from the IMU with the previous quaternion received from the IMU (note that quaternions of all zeros are ignored to avoid issues with invalid IMU data after exiting config mode). For each read quaternion:</p>
<ul>
<li>Calculate the shortest set of rotations from the previous to the current quaternion</li>
<li>Convert the shortest angle to euler angles</li>
<li>Add the pitch, roll, and yaw from the shortest euler angles to accumulated pitch, roll, and yaw variables</li>
<li>Note that if the IMU axis config changes, the accumulated data should be zeroed and the previously read quaternion discarded.</li>
</ul>
<p>This method makes the assumption that the smallest rotation between two quaternions is the most probable path the robot took to change its orientation. This is an approximation, however it is a fairly good one as long as sample rate of data is sufficiently high. The specifics of the path are lost. However, if the sample rate is high enough, the length of the path is sufficiently small that this is a good approximation.</p>
<p>The second "issue" with this approximation has to do with rotations exceeding 180 degrees. The method for determining shortest path between two quaternions will be incorrect if the vehicle rotates more than 180 degrees in any axis (because the shortest path would have involved rotating the other direction). To guarantee rotations between two samples never exceed 180 degrees, the max measured rotation rate of the gyro is considered. For the BNO055 this is 2000 degrees per second. Thus, with a sample period of <script type="math/tex">l</script> milliseconds, the largest angle change between samples is</p>
<p>
<script type="math/tex">\frac{2000 \textrm{ deg}}{1 \textrm{ sec}} \cdot \frac{1 \textrm{ sec}}{1000 \textrm{ ms}} \cdot \frac{l \textrm{ ms}}{1 \textrm{ sample}} = 2l \textrm{ deg / sample}</script>
</p>
<p>To ensure that changes of more than 180 degrees do not occur, the following must be satisfied</p>
<p>
<script type="math/tex">2l < 180 \rightarrow l < 90 \textrm{ milliseconds}</script>
</p>
<p>However, it is possible for some samples from the IMU to be delayed (ie I2C bus busy with another sensor) or lost (I2C failure). Thus, it is necessary to choose a value for <script type="math/tex">l</script> that allows for at least one sample to be lost. When a sample is lost, this doubles the effective time between samples. Thus, it is necessary to half <script type="math/tex">l</script>
</p>
<p>
<script type="math/tex">l < 45 \textrm{ milliseconds}</script>
</p>
<p>By further reducing <script type="math/tex">l</script> it is possible to allow for larger delays or more lost samples. The current firmware samples IMU data every 15ms (the max rate supported by the BNO055 in fusion mode is 100Hz = 10ms period). Using <script type="math/tex">l=15 \textrm{ ms}</script> it is possible for 5 consecutive samples to be lost while still guaranteeing that no more than 90ms passes between valid samples (thus still ensuring no more than 180 degree change between samples).</p>
              
            </div>
          </div><footer>
    <div class="rst-footer-buttons" role="navigation" aria-label="Footer Navigation">
        <a href="../build/" class="btn btn-neutral float-left" title="Build and Flash"><span class="icon icon-circle-arrow-left"></span> Previous</a>
        <a href="../developing/" class="btn btn-neutral float-right" title="Firmware Development">Next <span class="icon icon-circle-arrow-right"></span></a>
    </div>

  <hr/>

  <div role="contentinfo">
    <!-- Copyright etc -->
  </div>

  Built with <a href="https://www.mkdocs.org/">MkDocs</a> using a <a href="https://github.com/readthedocs/sphinx_rtd_theme">theme</a> provided by <a href="https://readthedocs.org">Read the Docs</a>.
</footer>
          
        </div>
      </div>

    </section>

  </div>

  <div class="rst-versions" role="note" aria-label="Versions">
  <span class="rst-current-version" data-toggle="rst-current-version">
    
        <span>
          <a href="https://github.com/MB3hel/AUVControlBoard" class="fa fa-github" style="color: #fcfcfc"> GitHub</a>
        </span>
    
    
      <span><a href="../build/" style="color: #fcfcfc">&laquo; Previous</a></span>
    
    
      <span><a href="../developing/" style="color: #fcfcfc">Next &raquo;</a></span>
    
  </span>
</div>
    <script>var base_url = '../..';</script>
    <script src="../../js/theme_extra.js" defer></script>
    <script src="../../js/theme.js" defer></script>
      <script src="https://cdn.mathjax.org/mathjax/latest/MathJax.js?config=TeX-AMS_HTML" defer></script>
      <script src="../../search/main.js" defer></script>
    <script defer>
        window.onload = function () {
            SphinxRtdTheme.Navigation.enable(true);
        };
    </script>

</body>
</html>
