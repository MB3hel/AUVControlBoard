<!DOCTYPE html>
<html class="writer-html5" lang="en" >
<head>
    <meta charset="utf-8" />
    <meta http-equiv="X-UA-Compatible" content="IE=edge" />
    <meta name="viewport" content="width=device-width, initial-scale=1.0" /><link rel="canonical" href="https://mb3hel.github.io/AUVControlBoard/firmware/math/" />
      <link rel="shortcut icon" href="../../img/favicon.ico" />
    <title>Math - AUV Control Board</title>
    <link rel="stylesheet" href="../../css/theme.css" />
    <link rel="stylesheet" href="../../css/theme_extra.css" />
        <link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/highlight.js/10.5.0/styles/github.min.css" />
    
      <script>
        // Current page data
        var mkdocs_page_name = "Math";
        var mkdocs_page_input_path = "firmware/math.md";
        var mkdocs_page_url = "/AUVControlBoard/firmware/math/";
      </script>
    
    <script src="../../js/jquery-3.6.0.min.js" defer></script>
    <!--[if lt IE 9]>
      <script src="../../js/html5shiv.min.js"></script>
    <![endif]-->
      <script src="https://cdnjs.cloudflare.com/ajax/libs/highlight.js/10.5.0/highlight.min.js"></script>
      <script>hljs.initHighlightingOnLoad();</script> 
</head>

<body class="wy-body-for-nav" role="document">

  <div class="wy-grid-for-nav">
    <nav data-toggle="wy-nav-shift" class="wy-nav-side stickynav">
    <div class="wy-side-scroll">
      <div class="wy-side-nav-search">
          <a href="../.." class="icon icon-home"> AUV Control Board
        </a><div role="search">
  <form id ="rtd-search-form" class="wy-form" action="../../search.html" method="get">
      <input type="text" name="q" placeholder="Search docs" title="Type search term here" />
  </form>
</div>
      </div>

      <div class="wy-menu wy-menu-vertical" data-spy="affix" role="navigation" aria-label="Navigation menu">
              <ul>
                <li class="toctree-l1"><a class="reference internal" href="../..">Home</a>
                </li>
              </ul>
              <p class="caption"><span class="caption-text">User Guide</span></p>
              <ul>
                  <li class="toctree-l1"><a class="reference internal" href="../../user_guide/preparing_board/">Preparing a Control Board</a>
                  </li>
                  <li class="toctree-l1"><a class="reference internal" href="../../user_guide/general_use/">Using Control board</a>
                  </li>
                  <li class="toctree-l1"><a class="reference internal" href="../../user_guide/simulator/">Using the Simulator</a>
                  </li>
                  <li class="toctree-l1"><a class="reference internal" href="../../user_guide/comm_protocol/">Communication Protocol</a>
                  </li>
                  <li class="toctree-l1"><a class="reference internal" href="../../user_guide/messages/">Messages</a>
                  </li>
              </ul>
              <p class="caption"><span class="caption-text">Hardware</span></p>
              <ul>
                  <li class="toctree-l1"><a class="reference internal" href="../../hardware/v1/">Version 1</a>
                  </li>
                  <li class="toctree-l1"><a class="reference internal" href="../../hardware/v2/">Version 2</a>
                  </li>
                  <li class="toctree-l1"><a class="reference internal" href="../../hardware/sensors/">Off-Board Sensors</a>
                  </li>
              </ul>
              <p class="caption"><span class="caption-text">Developers</span></p>
              <ul class="current">
                  <li class="toctree-l1"><a class="reference internal" href="../overview/">Overview</a>
                  </li>
                  <li class="toctree-l1"><a class="reference internal" href="../build/">Build and Flash</a>
                  </li>
                  <li class="toctree-l1 current"><a class="reference internal current" href="./">Math</a>
    <ul class="current">
    <li class="toctree-l2"><a class="reference internal" href="#coordinate-system-definition">Coordinate System Definition</a>
    </li>
    <li class="toctree-l2"><a class="reference internal" href="#6-degree-of-freedom-motion-control">6 Degree of Freedom Motion Control</a>
        <ul>
    <li class="toctree-l3"><a class="reference internal" href="#nomenclature-convention-notes">Nomenclature &amp; Convention Notes</a>
    </li>
    <li class="toctree-l3"><a class="reference internal" href="#system-assumptions">System Assumptions</a>
    </li>
    <li class="toctree-l3"><a class="reference internal" href="#example-vehicle">Example Vehicle</a>
    </li>
    <li class="toctree-l3"><a class="reference internal" href="#dof-matrix">DoF Matrix</a>
    </li>
    <li class="toctree-l3"><a class="reference internal" href="#local-mode-motion">LOCAL Mode Motion</a>
    </li>
    <li class="toctree-l3"><a class="reference internal" href="#global-mode-motion">GLOBAL Mode Motion</a>
    </li>
    <li class="toctree-l3"><a class="reference internal" href="#stability-assist-sassist-mode-motion">Stability Assist (SASSIST) Mode Motion</a>
    </li>
    <li class="toctree-l3"><a class="reference internal" href="#depth-hold-dhold-mode-motion">Depth Hold (DHOLD) Mode Motion</a>
    </li>
        </ul>
    </li>
    <li class="toctree-l2"><a class="reference internal" href="#sensor-processing">Sensor Processing</a>
    </li>
    <li class="toctree-l2"><a class="reference internal" href="#other-derivations">Other Derivations</a>
    </li>
    </ul>
                  </li>
                  <li class="toctree-l1"><a class="reference internal" href="../developing/">Firmware Development</a>
                  </li>
                  <li class="toctree-l1"><a class="reference internal" href="../simhijack/">Simulation Support</a>
                  </li>
              </ul>
      </div>
    </div>
    </nav>

    <section data-toggle="wy-nav-shift" class="wy-nav-content-wrap">
      <nav class="wy-nav-top" role="navigation" aria-label="Mobile navigation menu">
          <i data-toggle="wy-nav-top" class="fa fa-bars"></i>
          <a href="../..">AUV Control Board</a>
        
      </nav>
      <div class="wy-nav-content">
        <div class="rst-content"><div role="navigation" aria-label="breadcrumbs navigation">
  <ul class="wy-breadcrumbs">
    <li><a href="../.." class="icon icon-home" alt="Docs"></a> &raquo;</li>
          <li>Developers &raquo;</li>
      <li>Math</li>
    <li class="wy-breadcrumbs-aside">
          <a href="https://github.com/MB3hel/AUVControlBoard/blob/main/docs/docs/firmware/math.md" class="icon icon-github"> Edit on GitHub</a>
    </li>
  </ul>
  <hr/>
</div>
          <div role="main" class="document" itemscope="itemscope" itemtype="http://schema.org/Article">
            <div class="section" itemprop="articleBody">
              
                <h1 id="math">Math</h1>
<h2 id="coordinate-system-definition">Coordinate System Definition</h2>
<p>The control board uses a coordinate system that is somewhat non-standard.</p>
<ul>
<li>The coordinate system is right handed</li>
<li><code>+y</code> is forward, <code>+z</code> is up, <code>+x</code> is right</li>
<li>Pitch is about x, roll is about y, yaw is about z</li>
</ul>
<p><center>
<img alt="" src="../math_res/coord_system_1.png" style="height:250px;" />
<img alt="" src="../math_res/coord_system_2.png" style="height:250px;" />
<img alt="" src="../math_res/coord_system_rotations.png" style="height:250px;" />
</center></p>
<p>While this coordinate system may seem strange to some (especially anyone who has worked with planes), the name of axes doesn't really matter.</p>
<h2 id="6-degree-of-freedom-motion-control">6 Degree of Freedom Motion Control</h2>
<h3 id="nomenclature-convention-notes">Nomenclature &amp; Convention Notes</h3>
<ol>
<li>Matrices are assumed to be zero indexed (not 1 indexed). This means the first element of a matrix <span class="arithmatex">\(M\)</span> is <span class="arithmatex">\(m_{00}\)</span> not <span class="arithmatex">\(m_{11}\)</span>. This is because the math will be implemented in C (which uses zero indexed arrays).</li>
<li>Thruster numbers (1-8) are used by the control board's user facing components. However, this math will use thruster indices (0-7) where <code>index = number - 1</code>. This is b</li>
<li>Rotations about axis (angular velocities / DoFs) are referred to as "xrot" (about x), "yrot" (about y), and "zrot" (about z).</li>
<li>The terms "pitch", "roll", and "yaw" are used to describe the vehicle's orientation in space. "Pitch" is angular velocity about the x-axis, "roll" is angular rotation about the y-axis, and "yaw" is angular velocity about the z-axis.</li>
<li>Velocities in DoFs are normalized (meaning -1.0 to 1.0).</li>
</ol>
<h3 id="system-assumptions">System Assumptions</h3>
<ul>
<li>Vehicle is capable of motion exclusively in each of 6 degrees of freedom (DoFs). These are three translational DoFs, and three rotational DoFs.</li>
<li>The vehicle's speed in positive and negative directions are roughly equal for each DoF.</li>
<li>Thruster orientations are fixed. Gimbaled thruster vehicles are not supported.</li>
<li>At most 8 thrusters (less is fine)</li>
<li>System has 3D orientation information</li>
<li>System has depth information</li>
<li>System does <strong>not</strong> have translational position information</li>
</ul>
<h3 id="example-vehicle">Example Vehicle</h3>
<p>The examples on this page will use AquaPack robotics's SeaWolf VIII robot. This robot's thruster configuration is as shown below. The arrows indicate the direction a thruster moves water (meaning the arrows are opposite the direction the thruster excerpts force on the vehicle).</p>
<p><center>
<img alt="" src="../math_res/thruster_config.png" style="height:400px;" />
</center></p>
<p>The arrows indicate the direction the thruster moves water when powered in the positive direction. These arrows are opposite the direction force is excerpted on the vehicle. Note that the diagram above uses thruster numbers, not indices.</p>
<h3 id="dof-matrix">DoF Matrix</h3>
<p>The <em>DoF Matrix</em>, <span class="arithmatex">\(D\)</span>, is constructed based on the vehicle's thruster configuration. Rows of the matrix correspond to thrusters (by index). And columns of the matrix correspond to vehicle relative DoFs. Thus, this is an 8x6 matrix. Columns correspond to DoFs in the following order (0-5): x, y, z, pitch, roll, yaw. Note that pitch, roll, and yaw are written using the single variable notation p, r, h (h = heading = yaw).</p>
<p><span class="arithmatex">\(D = \left(\begin{array}{c|c|c|c|c|c} d_0 &amp; d_1 &amp; d_2  &amp; d_3 &amp; d_4 &amp; d_5 \end{array}\right) = \left(\begin{array}{c|c|c|c|c|c} d_x &amp; d_y &amp; d_z  &amp; d_p &amp; d_r &amp; d_h \end{array}\right)\)</span></p>
<p>Each column of the DoF matrix, <span class="arithmatex">\(d_i\)</span> is a set of thruster speeds that result in motion <em>exclusively</em> in the column's DoF. Additionally, the resultant motion should be the maximum possible speed, and in the positive direction. Each <span class="arithmatex">\(d_i\)</span> is an 8 element column vector, with elements corresponding to thrusters (by index). All speeds should be normalized (between -1.0 and 1.0)</p>
<p>For the example vehicle shown above, the following is the DoF matrix</p>
<p><span class="arithmatex">\(D = 
\begin{pmatrix}
-1 &amp; -1 &amp; 0 &amp; 0 &amp; 0 &amp; +1 \\
+1 &amp; -1 &amp; 0 &amp; 0 &amp; 0 &amp; -1 \\
-1 &amp; +1 &amp; 0 &amp; 0 &amp; 0 &amp; -1 \\
+1 &amp; +1 &amp; 0 &amp; 0 &amp; 0 &amp; +1 \\
0 &amp; 0 &amp; -1 &amp; -1 &amp; -1 &amp; 0 \\
0 &amp; 0 &amp; -1 &amp; -1 &amp; +1 &amp; 0 \\
0 &amp; 0 &amp; -1 &amp; +1 &amp; -1 &amp; 0 \\
0 &amp; 0 &amp; -1 &amp; +1 &amp; +1 &amp; 0 \\
\end{pmatrix}\)</span></p>
<p>Consider the first column: <span class="arithmatex">\(d_0 = d_x\)</span>. This column's thruster speeds should result in the vehicle moving as fast as possible in the +x direction (only). This is achieved by setting T2, T4 (index 1, 3) to the positive direction and T1, T3 (index 0, 2) to the negative direction at full speed (recall that the arrows are opposite the direction the thruster excerpts force on the vehicle). Thus</p>
<p><span class="arithmatex">\(d_x = \begin{pmatrix}-1 &amp; +1 &amp; -1 &amp; +1 &amp; 0 &amp; 0 &amp; 0 &amp; 0\end{pmatrix}^T\)</span></p>
<p>Note that when constructing the DoF matrix for your vehicle, you should assume an ideal system and environment.</p>
<h3 id="local-mode-motion">LOCAL Mode Motion</h3>
<p>In LOCAL mode, motion is specified as a set of speeds in vehicle relative DoFs. The user provides the control board with a <em>local target motion vector</em> (<span class="arithmatex">\(t_l\)</span>) where each element corresponds to a DoF.</p>
<p><span class="arithmatex">\(t_l = \begin{pmatrix} x &amp; y &amp; z &amp; r_x &amp; r_y &amp; r_z \end{pmatrix}^T\)</span></p>
<p><span class="arithmatex">\(x\)</span> is normalized velocity in +x direction<br />
<span class="arithmatex">\(y\)</span> is normalized velocity in +y direction<br />
<span class="arithmatex">\(z\)</span> is normalized velocity in +y direction<br />
<span class="arithmatex">\(r_x\)</span> is normalized velocity in +pitch direction (xrot)
<span class="arithmatex">\(r_y\)</span> is normalized velocity in +roll direction (yrot)
<span class="arithmatex">\(r_z\)</span> is normalized velocity in +yaw direction (zrot)</p>
<p>By multiplying this target motion by the DoF matrix, <span class="arithmatex">\(D\)</span>, a <em>speed vector</em> <span class="arithmatex">\(s\)</span> is obtained where each element of <span class="arithmatex">\(s\)</span> corresponds to a specific thruster (by index).</p>
<p><span class="arithmatex">\(s = D t_l\)</span></p>
<p>Consider the example where <span class="arithmatex">\(t_l = \begin{pmatrix}0 &amp; 1 &amp; 0 &amp; 0 &amp; 0 &amp; 0\end{pmatrix}^T\)</span>. This should cause the vehicle to move at full possible speed forward (relative to the vehicle's orientation).</p>
<p><span class="arithmatex">\(s = D t_l = 
\begin{pmatrix}
-1 &amp; -1 &amp; 0 &amp; 0 &amp; 0 &amp; +1 \\
+1 &amp; -1 &amp; 0 &amp; 0 &amp; 0 &amp; -1 \\
-1 &amp; +1 &amp; 0 &amp; 0 &amp; 0 &amp; -1 \\
+1 &amp; +1 &amp; 0 &amp; 0 &amp; 0 &amp; +1 \\
0 &amp; 0 &amp; -1 &amp; -1 &amp; -1 &amp; 0 \\
0 &amp; 0 &amp; -1 &amp; -1 &amp; +1 &amp; 0 \\
0 &amp; 0 &amp; -1 &amp; +1 &amp; -1 &amp; 0 \\
0 &amp; 0 &amp; -1 &amp; +1 &amp; +1 &amp; 0 \\
\end{pmatrix}
\begin{pmatrix}0 \\ 1 \\ 0 \\ 0 \\ 0 \\ 0\end{pmatrix}
=
\begin{pmatrix}-1 \\ -1 \\ +1 \\ +1 \\ 0 \\ 0 \\ 0 \\ 0\end{pmatrix}\)</span></p>
<p>In the above example, it is trivial to see that this is the desired motion. However for a more complex example, a problem appears. Consider <span class="arithmatex">\(t_l = \begin{pmatrix}0 &amp; 1 &amp; 0 &amp; 0 &amp; 0 &amp; 1\end{pmatrix}^T\)</span>. This describes the vehicle both moving forward and yawing at full possible speed.</p>
<p><span class="arithmatex">\(s = D t_l = 
\begin{pmatrix}
-1 &amp; -1 &amp; 0 &amp; 0 &amp; 0 &amp; +1 \\
+1 &amp; -1 &amp; 0 &amp; 0 &amp; 0 &amp; -1 \\
-1 &amp; +1 &amp; 0 &amp; 0 &amp; 0 &amp; -1 \\
+1 &amp; +1 &amp; 0 &amp; 0 &amp; 0 &amp; +1 \\
0 &amp; 0 &amp; -1 &amp; -1 &amp; -1 &amp; 0 \\
0 &amp; 0 &amp; -1 &amp; -1 &amp; +1 &amp; 0 \\
0 &amp; 0 &amp; -1 &amp; +1 &amp; -1 &amp; 0 \\
0 &amp; 0 &amp; -1 &amp; +1 &amp; +1 &amp; 0 \\
\end{pmatrix}
\begin{pmatrix}0 \\ 1 \\ 0 \\ 0 \\ 0 \\ 1\end{pmatrix}
=
\begin{pmatrix}0 \\ -2 \\ 0 \\ +2 \\ 0 \\ 0 \\ 0 \\ 0\end{pmatrix}\)</span></p>
<p>Notice that the resultant speed vector has motors moving in excess of 100% speed (elements with magnitude greater than 1.0). This is not possible. While a simple solution may seem to be dividing all elements of the vector by the one with the largest magnitude. This results in a scaled speed vector <span class="arithmatex">\(\hat{s}\)</span></p>
<p><span class="arithmatex">\(\hat{s} = s \div \text{absmax}(s)\)</span></p>
<p>this will not work well in all cases. Consider <span class="arithmatex">\(t_l = \begin{pmatrix}0 &amp; 1 &amp; 1 &amp; 1 &amp; 1 &amp; 1\end{pmatrix}^T\)</span>.</p>
<p><span class="arithmatex">\(s = D t_l = 
\begin{pmatrix}
-1 &amp; -1 &amp; 0 &amp; 0 &amp; 0 &amp; +1 \\
+1 &amp; -1 &amp; 0 &amp; 0 &amp; 0 &amp; -1 \\
-1 &amp; +1 &amp; 0 &amp; 0 &amp; 0 &amp; -1 \\
+1 &amp; +1 &amp; 0 &amp; 0 &amp; 0 &amp; +1 \\
0 &amp; 0 &amp; -1 &amp; -1 &amp; -1 &amp; 0 \\
0 &amp; 0 &amp; -1 &amp; -1 &amp; +1 &amp; 0 \\
0 &amp; 0 &amp; -1 &amp; +1 &amp; -1 &amp; 0 \\
0 &amp; 0 &amp; -1 &amp; +1 &amp; +1 &amp; 0 \\
\end{pmatrix}
\begin{pmatrix}0 \\ 1 \\ 1 \\ 1 \\ 1 \\ 1\end{pmatrix}
=
\begin{pmatrix}0 \\ -2 \\ 0 \\ +2 \\ -3 \\ -1 \\ -1 \\ +1\end{pmatrix}\)</span></p>
<p>and</p>
<p><span class="arithmatex">\(\hat{s} = s \div \text{absmax}(s) = s \div 3 = \begin{pmatrix}0 \\ -0.67 \\ 0 \\ +0.67 \\ -1 \\ -0.33 \\ -0.33 \\ +0.33\end{pmatrix}\)</span></p>
<p>While this has resulted in an possible set of thruster speeds, these are not optimal. Look at the example vehicle diagram. Notice that thrusters 1-4 and 5-8 control different motions. In the previous example, thrusters 1-4 were slowed down more than necessary, because thruster 5 was too large of a value. This is not ideal as the vehicle's maximum speed becomes artificially limited. Instead, the following <span class="arithmatex">\(\hat{s}\)</span> is ideal. This is scaling down the thrusters within each group (1-4 and 5-8) separately.</p>
<p><span class="arithmatex">\(\hat{s} = \begin{pmatrix}0 \\ -1 \\ 0 \\ +1 \\ -1 \\ -0.33 \\ -0.33 \\ +0.33\end{pmatrix}\)</span></p>
<p>Groupings of thrusters on the example vehicle are easy to observe, however this is not always true. Thus, achieving optimal scaling for any system (any DoF matrix) requires a more sophisticated method to determine groupings and scale speeds.</p>
<p>Thruster groupings are determined by "overlap" between thrusters. Two thrusters, <span class="arithmatex">\(i\)</span> and <span class="arithmatex">\(j\)</span> are said to overlap if they have a non-zero entry in the same column of the DoF matrix (<span class="arithmatex">\(D\)</span>) for at least one column. This is easier to calculate using a <em>contribution matrix</em>, <span class="arithmatex">\(C\)</span>, defined as <span class="arithmatex">\(D \neq 0\)</span>. This results in a binary form of the DoF matrix. For the above example</p>
<p><span class="arithmatex">\(C = 
\left[\begin{pmatrix}
-1 &amp; -1 &amp; 0 &amp; 0 &amp; 0 &amp; +1 \\
+1 &amp; -1 &amp; 0 &amp; 0 &amp; 0 &amp; -1 \\
-1 &amp; +1 &amp; 0 &amp; 0 &amp; 0 &amp; -1 \\
+1 &amp; +1 &amp; 0 &amp; 0 &amp; 0 &amp; +1 \\
0 &amp; 0 &amp; -1 &amp; -1 &amp; -1 &amp; 0 \\
0 &amp; 0 &amp; -1 &amp; -1 &amp; +1 &amp; 0 \\
0 &amp; 0 &amp; -1 &amp; +1 &amp; -1 &amp; 0 \\
0 &amp; 0 &amp; -1 &amp; +1 &amp; +1 &amp; 0 \\
\end{pmatrix}
\neq 0 \right] = 
\begin{pmatrix}
1 &amp; 1 &amp; 0 &amp; 0 &amp; 0 &amp; 1 \\
1 &amp; 1 &amp; 0 &amp; 0 &amp; 0 &amp; 1 \\
1 &amp; 1 &amp; 0 &amp; 0 &amp; 0 &amp; 1 \\
1 &amp; 1 &amp; 0 &amp; 0 &amp; 0 &amp; 1 \\
0 &amp; 0 &amp; 1 &amp; 1 &amp; 1 &amp; 0 \\
0 &amp; 0 &amp; 1 &amp; 1 &amp; 1 &amp; 0 \\
0 &amp; 0 &amp; 1 &amp; 1 &amp; 1 &amp; 0 \\
0 &amp; 0 &amp; 1 &amp; 1 &amp; 1 &amp; 0 \\
\end{pmatrix}\)</span></p>
<p>Then for each thruster <span class="arithmatex">\(i\)</span> an overlap vector <span class="arithmatex">\(o_i\)</span> can be constructed as follows</p>
<p><span class="arithmatex">\(o_i = C (c^i)^T\)</span></p>
<p>where <span class="arithmatex">\(c^i\)</span> is the <span class="arithmatex">\(i\)</span>th row of <span class="arithmatex">\(C\)</span>. Thus, <span class="arithmatex">\(o_i\)</span> is an 8 element vector where each element corresponds to a thruster (by index). Element <span class="arithmatex">\(j\)</span> of <span class="arithmatex">\(o_i\)</span> can either be <span class="arithmatex">\(1\)</span> or a <span class="arithmatex">\(0\)</span>. <span class="arithmatex">\(1\)</span> indicates that thrusters <span class="arithmatex">\(i\)</span> and <span class="arithmatex">\(j\)</span> overlap.</p>
<p>For example, </p>
<p><span class="arithmatex">\(o_0 = C (c^0)^T = \begin{pmatrix} 1 &amp; 1 &amp; 1 &amp; 1 &amp; 0 &amp; 0 &amp; 0 &amp; 0 \end{pmatrix}^T\)</span></p>
<p>This shows that thruster index 0 (T1) overlaps with indices 0, 1, 2, and 3 (T1, T2, T3, T4).</p>
<p>By calculating and storing these overlap vectors for each thruster (<span class="arithmatex">\(\left\{o_i\right\}_{i=0}^7\)</span>), this effectively forms a lookup table to determine thruster overlap. While this is not the most memory efficient option, it reduces computation time, which is important since this will run very frequently on a microcontroller.</p>
<p>Using overlap vectors, the following algorithm can be used to scale motor speeds:</p>
<ul>
<li>Find the thruster (<code>i</code>) with the largest magnitude speed</li>
<li>Iterate over thruster <code>i</code>'s overlap vector</li>
<li>For any thruster <code>i</code> overlaps with (<code>j</code>), divide thruster <code>j</code>'s speed by the magnitude of thruster <code>i</code>'s speed</li>
<li>Repeat until the largest magnitude does not exceed 1.0</li>
</ul>
<pre><code>while true
    // m is value, i is index
    m, i = max(abs(speed_vector))
    if m &lt;= 1.0
        // Done scaling
        break
    endif

    // Iterate over all thrusters (0-7 inclusive)
    for j=0...7
        if overlap_vector[i][j] == 1
            // i and j overlap. Divide j's speed by m.
            speed_vector[j] /= m
        endif
    endfor
endwhile
</code></pre>
<p>This algorithm results in optimal speed scaling by only reducing the speed of thrusters that share DoF contributions.</p>
<h3 id="global-mode-motion">GLOBAL Mode Motion</h3>
<p>GLOBAL mode is very similar to LOCAL mode, however, motion is described <em>partially</em> relative to the world instead of the robot. Specifically, motion of the vehicle is compensated for vehicle pitch and roll (but <strong>not</strong> yaw). This results in a coordinate system defined by the axes <code>gx</code>, <code>gy</code>, and <code>gz</code>. Note that the world coordinate system is defined as <code>wx</code>, <code>wy</code>, <code>wz</code>.</p>
<p><img alt="" src="../math_res/global_coord2.png" /></p>
<p><img alt="" src="../math_res/global_coord1.png" /></p>
<p><em>Notably, if the vehicle is pitched 180 degrees, the gx-gy plane becomes aligned to the back of the vehicle ensuring consistent motion. This is shown in the animation below.</em></p>
<p><img alt="" src="../math_res/global_invert.gif" /></p>
<p><br /></p>
<p>In GLOBAL mode, the user provides the control board with a <em>global target motion vector</em>, <span class="arithmatex">\(t_g\)</span> with 6 elements. This target motion vector is a concatenation of two 3 dimensional vectors. The first, a set of translations along <code>gx</code>, <code>gy</code>, and <code>gz</code>. Second a set of rotations to affect vehicle pitch, roll, and yaw. These are referred to by the following names</p>
<ul>
<li><code>x</code>: Speed in <code>gx</code> direction (translation)</li>
<li><code>y</code>: Speed in <code>gy</code> direction (translation)</li>
<li><code>z</code>: Speed in <code>gz</code> direction (translation)</li>
<li><code>p</code>: Speed at which the vehicle's pitch should increase (negative for decrease pitch). Aka "pitch_spd"</li>
<li><code>r</code>: Speed at which the vehicle's roll should increase (negative for decrease pitch). Aka "roll_spd"</li>
<li><code>h</code>: Speed at which the vehicle's yaw should increase (negative for decrease pitch). Aka "yaw_spd"</li>
</ul>
<p><span class="arithmatex">\(t_g = \begin{pmatrix} x &amp; y &amp; z &amp; p &amp; r &amp; h \end{pmatrix}\)</span></p>
<p>It is necessary to transform each DoF's motion into motions in the vehicle's DoFs. These speeds can then be passed to LOCAL mode.</p>
<p><strong><em>WARNING:</em></strong> <em>GLOBAL mode is impacted by gimbal lock issues with euler angles. This occurs when the vehicle's pitch is +/- 90 degrees. In this scenario the meaning of "increase / decrease pitch" is ambiguous. The vehicle will take the zero-roll route in this scenario. Thus, GLOBAL mode may produce undesirable motion if the roll is non-zero and you pitch through +/- 90.</em></p>
<p><br /></p>
<p><strong>Translation DoFs:</strong></p>
<p>The translation DoFs are easily transformed using gravity vectors. By applying a quaternion based rotation matrix to the base gravity vector, <span class="arithmatex">\(g_b = \begin{pmatrix}0 &amp; 0 &amp; -1\end{pmatrix}\)</span>, the following solution is determined for the current gravity vector, <span class="arithmatex">\(g_c\)</span> given the vehicle's orientation quaternion, <span class="arithmatex">\(q\)</span>.</p>
<p><span class="arithmatex">\(\begin{pmatrix} 2*(q.x*q.z+q.w*q.y) \\  2*(q.w*q.x-q.y*q.z) \\ -(q.w)^2+(q.x)^2+(q.y)^2-(q.z)^2\end{pmatrix}^T\)</span></p>
<p>The minimal rotation from <span class="arithmatex">\(g_b\)</span> to <span class="arithmatex">\(g_c\)</span> is then calculated. Let this rotation be called <span class="arithmatex">\(q_{rot}\)</span>. <em>This rotation will generally include no yaw component, unless the vehicle is upside down and facing backwards (eg pitch of 180 degrees) in which case it will contain a yaw component of 180 degrees. This is desirable as it ensures a continuous definition of what <code>gy</code> is even while the vehicle is flipping via pitch.</em></p>
<p>This quaternion can then be applied to speeds in the <code>gx</code>, <code>gy</code>, <code>gz</code> basis (<code>x</code>, <code>y</code>, and <code>z</code> here) to rotate them onto the vehicle basis. Thus, this "converts" translation speeds from GLOBAL to LOCAL mode DoFs.</p>
<p>However, it is not ideal to transform the translation vector all at once. It is best to do it in three stages to allow proper upscaling as needed (explained below).</p>
<p>Thus for each global mode translation vector <span class="arithmatex">\(\begin{pmatrix} 0 &amp; y &amp; 0 \end{pmatrix}\)</span>, <span class="arithmatex">\(\begin{pmatrix} 0 &amp; 0 &amp; z \end{pmatrix}\)</span>, and <span class="arithmatex">\(\begin{pmatrix} x &amp; 0 &amp; 0 \end{pmatrix}\)</span> rotate it by <span class="arithmatex">\(q_{rot}\)</span> to obtain <span class="arithmatex">\(t_x\)</span>, <span class="arithmatex">\(t_y\)</span>, and <span class="arithmatex">\(t_z\)</span> respectively (note that <span class="arithmatex">\(\left\{s, v\right\}\)</span> is a quaternion with scalar s and vector v).</p>
<p><span class="arithmatex">\(\left\{0, t_x\right\} = q_{rot} \left\{0, \begin{pmatrix} x &amp; 0 &amp; 0 \end{pmatrix} \right\} q_{rot}^*\)</span></p>
<p><span class="arithmatex">\(\left\{0, t_y\right\} = q_{rot} \left\{0, \begin{pmatrix} 0 &amp; y &amp; 0 \end{pmatrix} \right\} q_{rot}^*\)</span></p>
<p><span class="arithmatex">\(\left\{0, t_z\right\} = q_{rot} \left\{0, \begin{pmatrix} 0 &amp; 0 &amp; z \end{pmatrix} \right\} q_{rot}^*\)</span></p>
<p>Each of <span class="arithmatex">\(t_x\)</span>, <span class="arithmatex">\(t_y\)</span>, and <span class="arithmatex">\(t_z\)</span> are speeds in LOCAL mode DoFs, however they may be slower than desired. Consider a speed of 1.0 along <code>gy</code>. If the vehicle were rotated 45 degrees (pitch) the resultant <span class="arithmatex">\(t_y\)</span> would be <span class="arithmatex">\(t_y = \begin{pmatrix} 0.0 &amp; 0.7071 &amp; 0.7071 \end{pmatrix}\)</span>. This is not as fast as possible in the correct direction. Instead <span class="arithmatex">\(t_y\)</span> should be <span class="arithmatex">\(t_y = \begin{pmatrix} 0.0 &amp; 1.0 &amp; 1.0 \end{pmatrix}\)</span>. In other words, the largest element of <span class="arithmatex">\(t_y\)</span> should be the speed along <code>gy</code>. Thus, each of <span class="arithmatex">\(t_x\)</span>, <span class="arithmatex">\(t_y\)</span>, <span class="arithmatex">\(t_z\)</span> needs to be upscaled (note that it will never need to be downscaled; it only needs to be upscaled because one DoF may now be spread between multiple).</p>
<ul>
<li>let <span class="arithmatex">\(m\)</span> be the magnitude of the element of <span class="arithmatex">\(t_x\)</span> with the largest magnitude</li>
<li>Normalize <span class="arithmatex">\(t_x\)</span> so that largest element is 1.0: <span class="arithmatex">\(t_x = t_x / m\)</span></li>
<li>Scale normalized <span class="arithmatex">\(t_x\)</span> by speed <span class="arithmatex">\(x\)</span> (gx speed): <span class="arithmatex">\(t_x = t_x * x\)</span></li>
<li>Repeat this for <span class="arithmatex">\(t_y\)</span> and <span class="arithmatex">\(t_z\)</span> using <span class="arithmatex">\(y\)</span> and <span class="arithmatex">\(z\)</span> speeds respectively.</li>
</ul>
<p>Once all three <span class="arithmatex">\(t\)</span> vectors are scaled, they can be combined to create the net LOCAL mode translation vector, <span class="arithmatex">\(l\)</span></p>
<p><span class="arithmatex">\(l = t_x + t_y + t_z\)</span></p>
<p>There are two potential issues with <span class="arithmatex">\(l\)</span></p>
<ol>
<li><span class="arithmatex">\(l\)</span> is a set of proportionally related speeds to result in the desired motion. However, the vehicle may not be capable of the same speeds in each of it's DoFs. Thus, the ratios between <span class="arithmatex">\(l\)</span>'s elements may be incorrect.</li>
<li><span class="arithmatex">\(l\)</span> is a sum of three vectors (each with elements no larger than a magnitude of 1), thus it may have elements with a magnitude greater than 1.</li>
</ol>
<p>Issue 1 should be handled first as correcting it may "fix" issue 2. Handling issue 2 first could result in downscaling speeds more than necessary.</p>
<p>Handling issue 1 requires the user to provide a little more information about the vehicle: relative speeds in each DoF. These can be used to calculate downscaling factors to slow down the faster directions (note: speeding up the slower directions would result in impossible speeds, but would be handled by solving issue 2; regardless it is less ideal).</p>
<p>These downscaling factors are calculated from "RELDOF" information provided by the user (see messages page of user guide). Here we will referr to the scale factors as <span class="arithmatex">\(m_x\)</span>, <span class="arithmatex">\(m_y\)</span>, <span class="arithmatex">\(m_z\)</span>, <span class="arithmatex">\(m_{rx}\)</span>, <span class="arithmatex">\(m_{ry}\)</span>, and <span class="arithmatex">\(m_{rz}\)</span> for the x, y, z, xrot, yrot, and zrot DoFs respectively (note that these are vehicle DoFs).</p>
<p>Thus, the simplest option would be to let <span class="arithmatex">\(l = \begin{pmatrix}l.x * m_x &amp; l.y * m_y &amp; l.z * m_z\end{pmatrix}\)</span>. However, this may downscale more than necessary. Consider the slowest direction to have a speed of 0 in l. In this case, since the slowest direction is unused, we are downscaling too much. Thus, the following algorithm is used to select the ideal downscaling factors by "ignoring" the downscaling required for unused DoFs (DoFs with a speed of 0).</p>
<pre><code>// Zero downscale factors for unused DoFs
if abs(l.x) == 0
    m_x = 0
endif
if abs(l.y) == 0
    m_y = 0
endif
if abs(l.z) == 0
    m_z = 0
endif

// Rebalance scale factors so largest remaining is 1.0
m_max = max(m_x, max(m_y, m_z));
m_x = m_x / m_max;
m_y = m_y / m_max;
m_z = m_z / m_max;
</code></pre>
<p><span class="arithmatex">\(l\)</span> is then downscaled as <span class="arithmatex">\(l = \begin{pmatrix}l.x * m_x &amp; l.y * m_y &amp; l.z * m_z\end{pmatrix}\)</span> using the scale factors calculated using the above algorithm.</p>
<p>Finally, issue 2 must be handled if any element of <span class="arithmatex">\(l\)</span> still has a magnitude greater than 1.0. Thus, </p>
<ul>
<li>Let <span class="arithmatex">\(m\)</span> be the magnitude of the element of <span class="arithmatex">\(l\)</span> with the largest magnitude</li>
<li>If <span class="arithmatex">\(m\)</span> is less than or equal to 1, do not change $l</li>
<li>If <span class="arithmatex">\(m\)</span> is greater than 1 <span class="arithmatex">\(l = l / m\)</span></li>
</ul>
<p>This resultant <span class="arithmatex">\(l\)</span> is a set of speeds that can be passed to LOCAL mode as it's <code>x</code>, <code>y</code>, and <code>z</code> speeds.</p>
<p><br /></p>
<p><strong>Rotation DoFs:</strong></p>
<p>Converting the GLOBAL mode rotations (increase/decrease pitch, roll, yaw) to motions about DoFs is a little harder. It requires decomposing the quaternion into euler angles, then calculating three quaternions describing one euler rotation each. In other words, given the vehicle's current rotation <span class="arithmatex">\(q\)</span> we need to find <span class="arithmatex">\(q_{pitch}\)</span>, <span class="arithmatex">\(q_{roll}\)</span> and <span class="arithmatex">\(q_{yaw}\)</span> such that (based on the euler angle convention used by the control board)</p>
<p><span class="arithmatex">\(q = q_{yaw} q_{pitch} q_{roll}\)</span></p>
<p>This can be done by converting <span class="arithmatex">\(q\)</span> to a set of euler angles <span class="arithmatex">\(e = \begin{pmatrix}pitch &amp; roll &amp; yaw\end{pmatrix}\)</span> then constructing the following and converting each to a quaternion</p>
<p><span class="arithmatex">\(e_{pitch} = \begin{pmatrix}pitch &amp; 0 &amp; 0\end{pmatrix} \rightarrow q_{pitch}\)</span></p>
<p><span class="arithmatex">\(e_{roll} = \begin{pmatrix}0 &amp; roll &amp; 0\end{pmatrix} \rightarrow q_{roll}\)</span></p>
<p><span class="arithmatex">\(e_{yaw} = \begin{pmatrix}0 &amp; 0 &amp; yaw\end{pmatrix} \rightarrow q_{yaw}\)</span></p>
<p>However, the euler angles obtained from <span class="arithmatex">\(q\)</span> may not be correct for this use case. An equivalent angle go <span class="arithmatex">\(e\)</span> (although improper) is <span class="arithmatex">\(e_{alt} = \begin{pmatrix} \pi - pitch &amp; roll - \pi &amp; yaw - \pi \end{pmatrix}\)</span>. We need to compensate for first roll then pitch. Thus, we need the euler angle with minimal roll component. This will be referred to here as <span class="arithmatex">\(e_b\)</span> (which is either <span class="arithmatex">\(e\)</span> or <span class="arithmatex">\(_{alt}\)</span>).</p>
<p>Then, given <span class="arithmatex">\(s\)</span> vectors describing motion to change the vehicle's pitch, roll, or yaw</p>
<p><span class="arithmatex">\(s_{pitch} = \begin{pmatrix}p &amp; 0 &amp; 0\end{pmatrix}\)</span></p>
<p><span class="arithmatex">\(s_{roll} = \begin{pmatrix}0 &amp; r &amp; 0\end{pmatrix}\)</span></p>
<p><span class="arithmatex">\(s_{yaw} = \begin{pmatrix}0 &amp; 0 &amp; h\end{pmatrix}\)</span></p>
<p>We need to transform these onto the robot's axes as <span class="arithmatex">\(w\)</span> vectors. For roll this is trivial as roll is about the vehicle's y axis. For pitch, this requires undoing roll first (rotate by <span class="arithmatex">\(q_{roll}*\)</span>) and for yaw this requires undoing roll then pitch. Thus</p>
<p><span class="arithmatex">\(w_{roll} = s_{roll}\)</span></p>
<p><span class="arithmatex">\(\left\{0, w_{pitch}\right\} = q_{roll}^* \left\{0, s_{pitch}\right\} q_{roll}\)</span></p>
<p><span class="arithmatex">\(\left\{0, w_{yaw}\right\}  = q_{pitch}^* q_{roll}^* \left\{0, s_{yaw}\right\} q_{roll} q_{pitch}\)</span></p>
<p>These vectors are angular speeds about the vehicle's x, y, and z axes. Thus, just as for translations</p>
<ul>
<li>Upscale each <span class="arithmatex">\(w\)</span> vector using <code>p</code>, <code>r</code>, and <code>h</code> speeds (can skip for roll as this vector is never rotated)</li>
<li>Sum the three <span class="arithmatex">\(w\)</span> vectors into a net <span class="arithmatex">\(w\)</span> vector</li>
<li>Adjust <span class="arithmatex">\(w\)</span> for relative DoF speeds (using <span class="arithmatex">\(m_{rx}\)</span>, <span class="arithmatex">\(m_{ry}\)</span>, <span class="arithmatex">\(m_{rz}\)</span>)</li>
<li>Downscale <span class="arithmatex">\(w\)</span> if needed so all elements are less than 1</li>
</ul>
<p>Then <span class="arithmatex">\(w\)</span> is the xrot, yrot, and zrot parts of the LOCAL mode target.</p>
<h3 id="stability-assist-sassist-mode-motion">Stability Assist (SASSIST) Mode Motion</h3>
<p>Stability assist mode (SASSIST) uses closed-loop control for vehicle depth and orientation in 3D space. This is achieved using four PID controllers</p>
<ul>
<li>Depth PID: Controls translation along world z-axis</li>
<li>xrot PID: Controls rotation about vehicle x-axis</li>
<li>yrot PID: Controls rotation about vehicle y-axis</li>
<li>zrot PID: Controls rotation about vehicle z-axis</li>
</ul>
<p>The inputs to SASSIST mode are as follows</p>
<ul>
<li><code>x</code>: Translation along gx-axis (same as in GLOBAL mode)</li>
<li><code>y</code>: Translation along gy-axis (same as in GLOBAL mode)</li>
<li><code>d_t</code>: Target depth (meters; negative for below the surface)</li>
<li><code>e_t</code>: Target orientation as euler angles</li>
</ul>
<p>Optionally, a yaw speed (<code>h</code>) can be provided. In this case, PIDs will not adjust the vehicle's yaw (heading). Instead the <code>h</code> value works similar to GLOBAL mode (it is a rate of change of vehicle yaw).</p>
<p>This effectively abstracts a 2D plane in which the vehicle operates. This is the same gx-gy plane described in the GLOBAL mode section.</p>
<p>There are two variants of SASSIST mode</p>
<ul>
<li>Variant 1 (SASSIST1): Speed for yaw (<code>h</code>) is used instead of PID control</li>
<li>Variant 2 (SASSIST2): PID is used for yaw (yaw speed / <code>h</code> is ignored)</li>
</ul>
<p>These two variants are the same in how depth control works. However, variant 1 adds some additional complexity for orientation control.</p>
<p><br /></p>
<p><strong>Depth Control:</strong></p>
<p>A PID controller (sassist depth PID) is used to control the vehicle's speed in the world z (or GLOBAL z) DoF. The output of this PID controller is the same <code>z</code> that could be an input to GLOBAL mode. This PID controller's error is the difference between the user provided target depth and the measured current depth of the vehicle.</p>
<p><br /></p>
<p><strong>Translation DoFs:</strong></p>
<p>The user provided <code>x</code> and <code>y</code> along with the <code>z</code> from the depth PID are handled the same way by SASSIST mode as they are in GLOBAL mode to obtain the final LOCAL mode translation vector <span class="arithmatex">\(l\)</span>.</p>
<p><br /></p>
<p><strong>SASSIST2 Orientation Control:</strong></p>
<p>While translation for SASSIST is nearly identical to GLOBAL mode, rotation DoFs are very different. Orientation is controlled with a set of 3 PID controllers that work in LOCAL DoFs. Thus it is necessary to determine the rotations necessary about the vehicle's axes to achieve the desired orientation.</p>
<p>We are given a target orientation as euler angles, <span class="arithmatex">\(e_t\)</span>. This can be converted to a target orientation quaternion, <span class="arithmatex">\(q_t\)</span>. </p>
<p><em>Note: For SASSIST1 things after this point are the same (see section below for details on how to get <span class="arithmatex">\(q_t\)</span> for SASSIST1).</em></p>
<p>The vehicle's current orientation (as a quaternion) is also available from the IMU as <span class="arithmatex">\(q_c\)</span>. We need to calculate a quaternion <span class="arithmatex">\(q_d\)</span> that represents the minimal rotation from <span class="arithmatex">\(q_c\)</span> to <span class="arithmatex">\(q_t\)</span>. However, importantly we want <span class="arithmatex">\(q_d\)</span> to be a rotation in the vehicle's basis. Recall that right multiplication of quaternions are applied in the vehicle's basis. Thus, to describe the target orientation as the current orientation plus a rotation in the vehicle's basis</p>
<p><span class="arithmatex">\(q_t = q_c q_d\)</span></p>
<p>Therefore</p>
<p><span class="arithmatex">\(q_d = q_c^* q_t\)</span></p>
<p><br /></p>
<p>However, this angle may not be minimal. Recall that <span class="arithmatex">\(q\)</span> and <span class="arithmatex">\(-q\)</span> represent the same orientation. Thus another solution to this problem would be </p>
<p><span class="arithmatex">\(q_d = (-q_c)^* q_t\)</span></p>
<p>The minimal rotation is the one where <span class="arithmatex">\(q_c\)</span> and <span class="arithmatex">\(q_t\)</span> are on the same half of the unit quaternion hypersphere (meaning their dot product is not negative). Thus</p>
<ul>
<li>If <span class="arithmatex">\(q_c \cdot q_t &lt; 0\)</span> then <span class="arithmatex">\(q_d = (-q_c)^* q_t\)</span></li>
<li>Otherwise <span class="arithmatex">\(q_d = q_c^* q_t\)</span></li>
</ul>
<p>Then convert <span class="arithmatex">\(q_d\)</span> to axis-angle representation. The following algorithm is used to do so for numeric stability reasons (the common formulas using asin are not numerically stable)</p>
<ul>
<li>let <span class="arithmatex">\(q_d = \left\{s, v\right\}\)</span></li>
<li><span class="arithmatex">\(\theta = 2 atan2(|v|, s)\)</span></li>
<li><span class="arithmatex">\(n = v / |v|\)</span> if <span class="arithmatex">\(|v| &gt; 0\)</span> else <span class="arithmatex">\(n = v = 0\)</span></li>
</ul>
<p>This axis (<span class="arithmatex">\(n\)</span>) will be a unit vector. Thus it represents proportions of the rotation about each of the vehicle's axes. The angle (<span class="arithmatex">\(\theta\)</span>) is the magnitude of the rotation that must be taken.</p>
<p>Thus, the product of <span class="arithmatex">\(n\)</span> and <span class="arithmatex">\(\theta\)</span> is proportional to the error in angle about each of the vehicle's axes.</p>
<p><span class="arithmatex">\(e = \theta n\)</span></p>
<p>This error vector, <span class="arithmatex">\(e\)</span>, contains the errors to be provided to each orientation PID (xrot, yrot, zrot). The output of these PIDs are angular velocity percentages (-1.0 to 1.0) about each of the vehicle's axes: <span class="arithmatex">\(w = \begin{pmatrix} w_x &amp; w_y &amp; w_z \end{pmatrix}\)</span></p>
<p><em>Note: for SASSIST 1 there is an extra step here to calculate the correct w (see section below).</em></p>
<p>Finally, it is necessary to downscale the <span class="arithmatex">\(w\)</span> vectors just as in GLOBAL mode</p>
<ul>
<li>First downscale using <span class="arithmatex">\(m_{rx}\)</span>, <span class="arithmatex">\(m_{ry}\)</span> and <span class="arithmatex">\(m_{rz}\)</span> using the algorithm described in the GLOBAL mode section</li>
<li>Then downscale the vector so that all elements are less than 1. While this is never needed for SASSIST2, it is needed for SASSIST1 and it is simpler branching logic (code implementation) to just always check if downscaling is needed.</li>
</ul>
<p>This <span class="arithmatex">\(w\)</span> can then be passed to LOCAL mode along with the LOCAL translation vector <span class="arithmatex">\(l\)</span> obtained earlier.</p>
<p><br /></p>
<p><strong>SASSIST1 Orientation Control:</strong></p>
<p>SASSIS1 uses much of the same process to control the vehicle's orientation as SASSIST2, however it is necessary to decouple yaw from pitch and roll. In other words, we want to construct a target quaternion using the user provided pitch and roll, but matching the vehicle's current yaw.</p>
<p>The most intuitive option would be to decompose <span class="arithmatex">\(q_c\)</span> into euler angles and obtain the yaw from those. However, this does not account for the fact that the yaw can be altered by pitch or roll. For example, (p=115, r=0, h=90) would be decomposed as (p=65, r=180, h=-90). Here the heading is 180 degrees off. This would be a significant issue.</p>
<p>Thus instead, the target quaternion can be decomposed using the swing-twist decomposition of quaternion rotations. We twist about the world z axis (since this is the axis the vehicle initially yawed about). The vehicle's yaw can be calculated from this twist quaternion (using euler conversion formula).</p>
<p>The target quaternion is constructed from the target pitch and roll provided by the user and the yaw provided by the twist quaternion as described above. This target quaternion is <span class="arithmatex">\(q_t\)</span> and is used the same way described for SASSIST2.</p>
<p>After calculating <span class="arithmatex">\(w\)</span> as described for SASSIST2, there is one extra step before handling DoF scaling. The yaw speed (<code>h</code>) provided by the user must be transformed to the vehicle's axes and added to the <span class="arithmatex">\(w\)</span> from the PIDs.</p>
<p>This can be done similar to GLOBAL mode</p>
<p><span class="arithmatex">\(\left\{0, w_{yaw}\right\} = q_{rot} \left\{0, \begin{pmatrix}0 &amp; 0 &amp; h\end{pmatrix}\right\} q_{rot}^*\)</span></p>
<p><span class="arithmatex">\(w_{yaw}\)</span> will then be upscaled just as in GLOBAL mode.</p>
<p>Then <span class="arithmatex">\(w = w + w_{yaw}\)</span>. This is then downscaled as described for SASSIST2.</p>
<h3 id="depth-hold-dhold-mode-motion">Depth Hold (DHOLD) Mode Motion</h3>
<p>Depth hold (DHOLD) mode is GLOBAL mode but using a PID to control the vehicle's depth. The same depth PID used for SASSIST mode is used for DHOLD mode.</p>
<p>This mode uses the vehicle's current depth and a user provided target depth to calcualte the depth PIDs error. The depth PID provides the gz-axis speed. Other speeds (<code>x</code>, <code>y</code>, <code>p</code>, <code>r</code>, and <code>h</code>) are provided by the user and mean the same thing as in GLOBAL mode. </p>
<p>The calculated <code>z</code> along with user-provided speeds are passed directly to GLOBAL mode after calculating <code>z</code> using the depth PID.</p>
<h2 id="sensor-processing">Sensor Processing</h2>
<p>TODO: Euler angle accumulation</p>
<h2 id="other-derivations">Other Derivations</h2>
<p>TODO: Euler / Quaternion conversion</p>
<p>TODO: Gravity vector calculation</p>
<p>TODO: Angle between vectors</p>
<p>TODO: Min diff quat between two quats</p>
              
            </div>
          </div><footer>
    <div class="rst-footer-buttons" role="navigation" aria-label="Footer Navigation">
        <a href="../build/" class="btn btn-neutral float-left" title="Build and Flash"><span class="icon icon-circle-arrow-left"></span> Previous</a>
        <a href="../developing/" class="btn btn-neutral float-right" title="Firmware Development">Next <span class="icon icon-circle-arrow-right"></span></a>
    </div>

  <hr/>

  <div role="contentinfo">
    <!-- Copyright etc -->
  </div>

  Built with <a href="https://www.mkdocs.org/">MkDocs</a> using a <a href="https://github.com/readthedocs/sphinx_rtd_theme">theme</a> provided by <a href="https://readthedocs.org">Read the Docs</a>.
</footer>
          
        </div>
      </div>

    </section>

  </div>

  <div class="rst-versions" role="note" aria-label="Versions">
  <span class="rst-current-version" data-toggle="rst-current-version">
    
        <span>
          <a href="https://github.com/MB3hel/AUVControlBoard" class="fa fa-github" style="color: #fcfcfc"> GitHub</a>
        </span>
    
    
      <span><a href="../build/" style="color: #fcfcfc">&laquo; Previous</a></span>
    
    
      <span><a href="../developing/" style="color: #fcfcfc">Next &raquo;</a></span>
    
  </span>
</div>
    <script>var base_url = '../..';</script>
    <script src="../../js/theme_extra.js" defer></script>
    <script src="../../js/theme.js" defer></script>
      <script src="../../js/mathjax.js" defer></script>
      <script src="https://polyfill.io/v3/polyfill.min.js?features=es6" defer></script>
      <script src="https://cdn.jsdelivr.net/npm/mathjax@3/es5/tex-mml-chtml.js" defer></script>
      <script src="../../search/main.js" defer></script>
    <script defer>
        window.onload = function () {
            SphinxRtdTheme.Navigation.enable(true);
        };
    </script>

</body>
</html>
